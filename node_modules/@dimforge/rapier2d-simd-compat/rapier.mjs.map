{"version":3,"file":"rapier.mjs","sources":["rapier_wasm2d.js","../gen2d/math.ts","../gen2d/dynamics/rigid_body.ts","../gen2d/dynamics/impulse_joint.ts","../gen2d/dynamics/coefficient_combine_rule.ts","../gen2d/geometry/feature.ts","../gen2d/geometry/shape.ts","../gen2d/control/pid_controller.ts","../gen2d/pipeline/event_queue.ts","../gen2d/pipeline/physics_hooks.ts","../gen2d/pipeline/query_pipeline.ts","../gen2d/geometry/collider.ts","../gen2d/coarena.ts","../gen2d/dynamics/rigid_body_set.ts","../gen2d/dynamics/integration_parameters.ts","../gen2d/dynamics/impulse_joint_set.ts","../gen2d/dynamics/multibody_joint.ts","../gen2d/dynamics/multibody_joint_set.ts","../gen2d/dynamics/ccd_solver.ts","../gen2d/dynamics/island_manager.ts","../gen2d/geometry/ray.ts","../gen2d/geometry/point.ts","../gen2d/geometry/toi.ts","../gen2d/geometry/broad_phase.ts","../gen2d/geometry/narrow_phase.ts","../gen2d/geometry/contact.ts","../gen2d/pipeline/physics_pipeline.ts","../gen2d/pipeline/serialization_pipeline.ts","../gen2d/pipeline/debug_render_pipeline.ts","../gen2d/control/character_controller.ts","../gen2d/pipeline/world.ts","../gen2d/geometry/collider_set.ts","../../../node_modules/tslib/tslib.es6.js","../../../node_modules/base64-js/index.js","../gen2d/init.ts","../gen2d/exports.ts"],"sourcesContent":["let wasm;\n\nconst heap = new Array(128).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_export_0(addHeapObject(e));\n    }\n}\n\nconst cachedTextDecoder = (typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }) : { decode: () => { throw Error('TextDecoder not available') } } );\n\nif (typeof TextDecoder !== 'undefined') { cachedTextDecoder.decode(); };\n\nlet cachedUint8ArrayMemory0 = null;\n\nfunction getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachedDataViewMemory0 = null;\n\nfunction getDataViewMemory0() {\n    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || (cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== wasm.memory.buffer)) {\n        cachedDataViewMemory0 = new DataView(wasm.memory.buffer);\n    }\n    return cachedDataViewMemory0;\n}\n\nfunction dropObject(idx) {\n    if (idx < 132) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n/**\n * @returns {string}\n */\nexport function version() {\n    let deferred1_0;\n    let deferred1_1;\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.version(retptr);\n        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n        deferred1_0 = r0;\n        deferred1_1 = r1;\n        return getStringFromWasm0(r0, r1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_export_1(deferred1_0, deferred1_1, 1);\n    }\n}\n\n/**\n * @param {number} extra_bytes_count\n */\nexport function reserve_memory(extra_bytes_count) {\n    wasm.reserve_memory(extra_bytes_count);\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n}\n\nlet stack_pointer = 128;\n\nfunction addBorrowedObject(obj) {\n    if (stack_pointer == 1) throw new Error('out of js stack');\n    heap[--stack_pointer] = obj;\n    return stack_pointer;\n}\n\nlet cachedInt32ArrayMemory0 = null;\n\nfunction getInt32ArrayMemory0() {\n    if (cachedInt32ArrayMemory0 === null || cachedInt32ArrayMemory0.byteLength === 0) {\n        cachedInt32ArrayMemory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachedInt32ArrayMemory0;\n}\n\nfunction getArrayI32FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getInt32ArrayMemory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nlet cachedFloat32ArrayMemory0 = null;\n\nfunction getFloat32ArrayMemory0() {\n    if (cachedFloat32ArrayMemory0 === null || cachedFloat32ArrayMemory0.byteLength === 0) {\n        cachedFloat32ArrayMemory0 = new Float32Array(wasm.memory.buffer);\n    }\n    return cachedFloat32ArrayMemory0;\n}\n\nfunction getArrayF32FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getFloat32ArrayMemory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nlet cachedUint32ArrayMemory0 = null;\n\nfunction getUint32ArrayMemory0() {\n    if (cachedUint32ArrayMemory0 === null || cachedUint32ArrayMemory0.byteLength === 0) {\n        cachedUint32ArrayMemory0 = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachedUint32ArrayMemory0;\n}\n\nfunction getArrayU32FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint32ArrayMemory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArray32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4, 4) >>> 0;\n    getUint32ArrayMemory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction passArrayF32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4, 4) >>> 0;\n    getFloat32ArrayMemory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n/**\n * @enum {0 | 1 | 2}\n */\nexport const RawFeatureType = Object.freeze({\n    Vertex: 0, \"0\": \"Vertex\",\n    Face: 1, \"1\": \"Face\",\n    Unknown: 2, \"2\": \"Unknown\",\n});\n/**\n * @enum {0 | 1 | 2}\n */\nexport const RawJointAxis = Object.freeze({\n    LinX: 0, \"0\": \"LinX\",\n    LinY: 1, \"1\": \"LinY\",\n    AngX: 2, \"2\": \"AngX\",\n});\n/**\n * @enum {0 | 1 | 2 | 3 | 4 | 5}\n */\nexport const RawJointType = Object.freeze({\n    Revolute: 0, \"0\": \"Revolute\",\n    Fixed: 1, \"1\": \"Fixed\",\n    Prismatic: 2, \"2\": \"Prismatic\",\n    Rope: 3, \"3\": \"Rope\",\n    Spring: 4, \"4\": \"Spring\",\n    Generic: 5, \"5\": \"Generic\",\n});\n/**\n * @enum {0 | 1}\n */\nexport const RawMotorModel = Object.freeze({\n    AccelerationBased: 0, \"0\": \"AccelerationBased\",\n    ForceBased: 1, \"1\": \"ForceBased\",\n});\n/**\n * @enum {0 | 1 | 2 | 3}\n */\nexport const RawRigidBodyType = Object.freeze({\n    Dynamic: 0, \"0\": \"Dynamic\",\n    Fixed: 1, \"1\": \"Fixed\",\n    KinematicPositionBased: 2, \"2\": \"KinematicPositionBased\",\n    KinematicVelocityBased: 3, \"3\": \"KinematicVelocityBased\",\n});\n/**\n * @enum {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14}\n */\nexport const RawShapeType = Object.freeze({\n    Ball: 0, \"0\": \"Ball\",\n    Cuboid: 1, \"1\": \"Cuboid\",\n    Capsule: 2, \"2\": \"Capsule\",\n    Segment: 3, \"3\": \"Segment\",\n    Polyline: 4, \"4\": \"Polyline\",\n    Triangle: 5, \"5\": \"Triangle\",\n    TriMesh: 6, \"6\": \"TriMesh\",\n    HeightField: 7, \"7\": \"HeightField\",\n    Compound: 8, \"8\": \"Compound\",\n    ConvexPolygon: 9, \"9\": \"ConvexPolygon\",\n    RoundCuboid: 10, \"10\": \"RoundCuboid\",\n    RoundTriangle: 11, \"11\": \"RoundTriangle\",\n    RoundConvexPolygon: 12, \"12\": \"RoundConvexPolygon\",\n    HalfSpace: 13, \"13\": \"HalfSpace\",\n    Voxels: 14, \"14\": \"Voxels\",\n});\n\nconst RawBroadPhaseFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawbroadphase_free(ptr >>> 0, 1));\n\nexport class RawBroadPhase {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawBroadPhase.prototype);\n        obj.__wbg_ptr = ptr;\n        RawBroadPhaseFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawBroadPhaseFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawbroadphase_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.rawbroadphase_new();\n        this.__wbg_ptr = ret >>> 0;\n        RawBroadPhaseFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {RawNarrowPhase} narrow_phase\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawVector} rayOrig\n     * @param {RawVector} rayDir\n     * @param {number} maxToi\n     * @param {boolean} solid\n     * @param {number} filter_flags\n     * @param {number | null | undefined} filter_groups\n     * @param {number | null | undefined} filter_exclude_collider\n     * @param {number | null | undefined} filter_exclude_rigid_body\n     * @param {Function} filter_predicate\n     * @returns {RawRayColliderHit | undefined}\n     */\n    castRay(narrow_phase, bodies, colliders, rayOrig, rayDir, maxToi, solid, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(narrow_phase, RawNarrowPhase);\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(rayOrig, RawVector);\n            _assertClass(rayDir, RawVector);\n            const ret = wasm.rawbroadphase_castRay(this.__wbg_ptr, narrow_phase.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid, filter_flags, isLikeNone(filter_groups) ? 0x100000001 : (filter_groups) >>> 0, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawRayColliderHit.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @param {RawNarrowPhase} narrow_phase\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawVector} rayOrig\n     * @param {RawVector} rayDir\n     * @param {number} maxToi\n     * @param {boolean} solid\n     * @param {number} filter_flags\n     * @param {number | null | undefined} filter_groups\n     * @param {number | null | undefined} filter_exclude_collider\n     * @param {number | null | undefined} filter_exclude_rigid_body\n     * @param {Function} filter_predicate\n     * @returns {RawRayColliderIntersection | undefined}\n     */\n    castRayAndGetNormal(narrow_phase, bodies, colliders, rayOrig, rayDir, maxToi, solid, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(narrow_phase, RawNarrowPhase);\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(rayOrig, RawVector);\n            _assertClass(rayDir, RawVector);\n            const ret = wasm.rawbroadphase_castRayAndGetNormal(this.__wbg_ptr, narrow_phase.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid, filter_flags, isLikeNone(filter_groups) ? 0x100000001 : (filter_groups) >>> 0, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawRayColliderIntersection.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @param {RawNarrowPhase} narrow_phase\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawVector} rayOrig\n     * @param {RawVector} rayDir\n     * @param {number} maxToi\n     * @param {boolean} solid\n     * @param {Function} callback\n     * @param {number} filter_flags\n     * @param {number | null | undefined} filter_groups\n     * @param {number | null | undefined} filter_exclude_collider\n     * @param {number | null | undefined} filter_exclude_rigid_body\n     * @param {Function} filter_predicate\n     */\n    intersectionsWithRay(narrow_phase, bodies, colliders, rayOrig, rayDir, maxToi, solid, callback, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(narrow_phase, RawNarrowPhase);\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(rayOrig, RawVector);\n            _assertClass(rayDir, RawVector);\n            wasm.rawbroadphase_intersectionsWithRay(this.__wbg_ptr, narrow_phase.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid, addBorrowedObject(callback), filter_flags, isLikeNone(filter_groups) ? 0x100000001 : (filter_groups) >>> 0, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @param {RawNarrowPhase} narrow_phase\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawVector} shapePos\n     * @param {RawRotation} shapeRot\n     * @param {RawShape} shape\n     * @param {number} filter_flags\n     * @param {number | null | undefined} filter_groups\n     * @param {number | null | undefined} filter_exclude_collider\n     * @param {number | null | undefined} filter_exclude_rigid_body\n     * @param {Function} filter_predicate\n     * @returns {number | undefined}\n     */\n    intersectionWithShape(narrow_phase, bodies, colliders, shapePos, shapeRot, shape, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(narrow_phase, RawNarrowPhase);\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(shapePos, RawVector);\n            _assertClass(shapeRot, RawRotation);\n            _assertClass(shape, RawShape);\n            wasm.rawbroadphase_intersectionWithShape(retptr, this.__wbg_ptr, narrow_phase.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, shape.__wbg_ptr, filter_flags, isLikeNone(filter_groups) ? 0x100000001 : (filter_groups) >>> 0, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r2 = getDataViewMemory0().getFloat64(retptr + 8 * 1, true);\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @param {RawNarrowPhase} narrow_phase\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawVector} point\n     * @param {boolean} solid\n     * @param {number} filter_flags\n     * @param {number | null | undefined} filter_groups\n     * @param {number | null | undefined} filter_exclude_collider\n     * @param {number | null | undefined} filter_exclude_rigid_body\n     * @param {Function} filter_predicate\n     * @returns {RawPointColliderProjection | undefined}\n     */\n    projectPoint(narrow_phase, bodies, colliders, point, solid, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(narrow_phase, RawNarrowPhase);\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(point, RawVector);\n            const ret = wasm.rawbroadphase_projectPoint(this.__wbg_ptr, narrow_phase.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, point.__wbg_ptr, solid, filter_flags, isLikeNone(filter_groups) ? 0x100000001 : (filter_groups) >>> 0, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawPointColliderProjection.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @param {RawNarrowPhase} narrow_phase\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawVector} point\n     * @param {number} filter_flags\n     * @param {number | null | undefined} filter_groups\n     * @param {number | null | undefined} filter_exclude_collider\n     * @param {number | null | undefined} filter_exclude_rigid_body\n     * @param {Function} filter_predicate\n     * @returns {RawPointColliderProjection | undefined}\n     */\n    projectPointAndGetFeature(narrow_phase, bodies, colliders, point, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(narrow_phase, RawNarrowPhase);\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(point, RawVector);\n            const ret = wasm.rawbroadphase_projectPointAndGetFeature(this.__wbg_ptr, narrow_phase.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, point.__wbg_ptr, filter_flags, isLikeNone(filter_groups) ? 0x100000001 : (filter_groups) >>> 0, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawPointColliderProjection.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @param {RawNarrowPhase} narrow_phase\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawVector} point\n     * @param {Function} callback\n     * @param {number} filter_flags\n     * @param {number | null | undefined} filter_groups\n     * @param {number | null | undefined} filter_exclude_collider\n     * @param {number | null | undefined} filter_exclude_rigid_body\n     * @param {Function} filter_predicate\n     */\n    intersectionsWithPoint(narrow_phase, bodies, colliders, point, callback, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(narrow_phase, RawNarrowPhase);\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(point, RawVector);\n            wasm.rawbroadphase_intersectionsWithPoint(this.__wbg_ptr, narrow_phase.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, point.__wbg_ptr, addBorrowedObject(callback), filter_flags, isLikeNone(filter_groups) ? 0x100000001 : (filter_groups) >>> 0, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @param {RawNarrowPhase} narrow_phase\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawVector} shapePos\n     * @param {RawRotation} shapeRot\n     * @param {RawVector} shapeVel\n     * @param {RawShape} shape\n     * @param {number} target_distance\n     * @param {number} maxToi\n     * @param {boolean} stop_at_penetration\n     * @param {number} filter_flags\n     * @param {number | null | undefined} filter_groups\n     * @param {number | null | undefined} filter_exclude_collider\n     * @param {number | null | undefined} filter_exclude_rigid_body\n     * @param {Function} filter_predicate\n     * @returns {RawColliderShapeCastHit | undefined}\n     */\n    castShape(narrow_phase, bodies, colliders, shapePos, shapeRot, shapeVel, shape, target_distance, maxToi, stop_at_penetration, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(narrow_phase, RawNarrowPhase);\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(shapePos, RawVector);\n            _assertClass(shapeRot, RawRotation);\n            _assertClass(shapeVel, RawVector);\n            _assertClass(shape, RawShape);\n            const ret = wasm.rawbroadphase_castShape(this.__wbg_ptr, narrow_phase.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, shapeVel.__wbg_ptr, shape.__wbg_ptr, target_distance, maxToi, stop_at_penetration, filter_flags, isLikeNone(filter_groups) ? 0x100000001 : (filter_groups) >>> 0, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawColliderShapeCastHit.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @param {RawNarrowPhase} narrow_phase\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawVector} shapePos\n     * @param {RawRotation} shapeRot\n     * @param {RawShape} shape\n     * @param {Function} callback\n     * @param {number} filter_flags\n     * @param {number | null | undefined} filter_groups\n     * @param {number | null | undefined} filter_exclude_collider\n     * @param {number | null | undefined} filter_exclude_rigid_body\n     * @param {Function} filter_predicate\n     */\n    intersectionsWithShape(narrow_phase, bodies, colliders, shapePos, shapeRot, shape, callback, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(narrow_phase, RawNarrowPhase);\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(shapePos, RawVector);\n            _assertClass(shapeRot, RawRotation);\n            _assertClass(shape, RawShape);\n            wasm.rawbroadphase_intersectionsWithShape(this.__wbg_ptr, narrow_phase.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, shape.__wbg_ptr, addBorrowedObject(callback), filter_flags, isLikeNone(filter_groups) ? 0x100000001 : (filter_groups) >>> 0, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @param {RawNarrowPhase} narrow_phase\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawVector} aabbCenter\n     * @param {RawVector} aabbHalfExtents\n     * @param {Function} callback\n     */\n    collidersWithAabbIntersectingAabb(narrow_phase, bodies, colliders, aabbCenter, aabbHalfExtents, callback) {\n        try {\n            _assertClass(narrow_phase, RawNarrowPhase);\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(aabbCenter, RawVector);\n            _assertClass(aabbHalfExtents, RawVector);\n            wasm.rawbroadphase_collidersWithAabbIntersectingAabb(this.__wbg_ptr, narrow_phase.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, aabbCenter.__wbg_ptr, aabbHalfExtents.__wbg_ptr, addBorrowedObject(callback));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n\nconst RawCCDSolverFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawccdsolver_free(ptr >>> 0, 1));\n\nexport class RawCCDSolver {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawCCDSolverFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawccdsolver_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.rawccdsolver_new();\n        this.__wbg_ptr = ret >>> 0;\n        RawCCDSolverFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n}\n\nconst RawCharacterCollisionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawcharactercollision_free(ptr >>> 0, 1));\n\nexport class RawCharacterCollision {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawCharacterCollisionFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcharactercollision_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.rawcharactercollision_new();\n        this.__wbg_ptr = ret >>> 0;\n        RawCharacterCollisionFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {number}\n     */\n    handle() {\n        const ret = wasm.rawcharactercollision_handle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {RawVector}\n     */\n    translationDeltaApplied() {\n        const ret = wasm.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    translationDeltaRemaining() {\n        const ret = wasm.rawcharactercollision_translationDeltaRemaining(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    toi() {\n        const ret = wasm.rawcharactercollision_toi(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {RawVector}\n     */\n    worldWitness1() {\n        const ret = wasm.rawcharactercollision_worldWitness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    worldWitness2() {\n        const ret = wasm.rawcharactercollision_worldWitness2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    worldNormal1() {\n        const ret = wasm.rawcharactercollision_worldNormal1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    worldNormal2() {\n        const ret = wasm.rawcharactercollision_worldNormal2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n\nconst RawColliderSetFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawcolliderset_free(ptr >>> 0, 1));\n\nexport class RawColliderSet {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawColliderSet.prototype);\n        obj.__wbg_ptr = ptr;\n        RawColliderSetFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawColliderSetFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcolliderset_free(ptr, 0);\n    }\n    /**\n     * The world-space translation of this collider.\n     * @param {number} handle\n     * @returns {RawVector}\n     */\n    coTranslation(handle) {\n        const ret = wasm.rawcolliderset_coTranslation(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * The world-space orientation of this collider.\n     * @param {number} handle\n     * @returns {RawRotation}\n     */\n    coRotation(handle) {\n        const ret = wasm.rawcolliderset_coRotation(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n     * The translation of this collider relative to its parent rigid-body.\n     *\n     * Returns the `None` if it doesn’t have a parent.\n     * @param {number} handle\n     * @returns {RawVector | undefined}\n     */\n    coTranslationWrtParent(handle) {\n        const ret = wasm.rawcolliderset_coTranslationWrtParent(this.__wbg_ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n     * The orientation of this collider relative to its parent rigid-body.\n     *\n     * Returns the `None` if it doesn’t have a parent.\n     * @param {number} handle\n     * @returns {RawRotation | undefined}\n     */\n    coRotationWrtParent(handle) {\n        const ret = wasm.rawcolliderset_coRotationWrtParent(this.__wbg_ptr, handle);\n        return ret === 0 ? undefined : RawRotation.__wrap(ret);\n    }\n    /**\n     * Sets the translation of this collider.\n     *\n     * # Parameters\n     * - `x`: the world-space position of the collider along the `x` axis.\n     * - `y`: the world-space position of the collider along the `y` axis.\n     * - `wakeUp`: forces the collider to wake-up so it is properly affected by forces if it\n     * wasn't moving before modifying its position.\n     * @param {number} handle\n     * @param {number} x\n     * @param {number} y\n     */\n    coSetTranslation(handle, x, y) {\n        wasm.rawcolliderset_coSetTranslation(this.__wbg_ptr, handle, x, y);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} x\n     * @param {number} y\n     */\n    coSetTranslationWrtParent(handle, x, y) {\n        wasm.rawcolliderset_coSetTranslationWrtParent(this.__wbg_ptr, handle, x, y);\n    }\n    /**\n     * Sets the rotation angle of this collider.\n     *\n     * # Parameters\n     * - `angle`: the rotation angle, in radians.\n     * - `wakeUp`: forces the collider to wake-up so it is properly affected by forces if it\n     * wasn't moving before modifying its position.\n     * @param {number} handle\n     * @param {number} angle\n     */\n    coSetRotation(handle, angle) {\n        wasm.rawcolliderset_coSetRotation(this.__wbg_ptr, handle, angle);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} angle\n     */\n    coSetRotationWrtParent(handle, angle) {\n        wasm.rawcolliderset_coSetRotationWrtParent(this.__wbg_ptr, handle, angle);\n    }\n    /**\n     * Is this collider a sensor?\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    coIsSensor(handle) {\n        const ret = wasm.rawcolliderset_coIsSensor(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * The type of the shape of this collider.\n     * @param {number} handle\n     * @returns {RawShapeType}\n     */\n    coShapeType(handle) {\n        const ret = wasm.rawcolliderset_coShapeType(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * @param {number} handle\n     * @returns {RawVector | undefined}\n     */\n    coHalfspaceNormal(handle) {\n        const ret = wasm.rawcolliderset_coHalfspaceNormal(this.__wbg_ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n     * The half-extents of this collider if it is has a cuboid shape.\n     * @param {number} handle\n     * @returns {RawVector | undefined}\n     */\n    coHalfExtents(handle) {\n        const ret = wasm.rawcolliderset_coHalfExtents(this.__wbg_ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n     * Set the half-extents of this collider if it has a cuboid shape.\n     * @param {number} handle\n     * @param {RawVector} newHalfExtents\n     */\n    coSetHalfExtents(handle, newHalfExtents) {\n        _assertClass(newHalfExtents, RawVector);\n        wasm.rawcolliderset_coSetHalfExtents(this.__wbg_ptr, handle, newHalfExtents.__wbg_ptr);\n    }\n    /**\n     * The radius of this collider if it is a ball, capsule, cylinder, or cone shape.\n     * @param {number} handle\n     * @returns {number | undefined}\n     */\n    coRadius(handle) {\n        const ret = wasm.rawcolliderset_coRadius(this.__wbg_ptr, handle);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * Set the radius of this collider if it is a ball, capsule, cylinder, or cone shape.\n     * @param {number} handle\n     * @param {number} newRadius\n     */\n    coSetRadius(handle, newRadius) {\n        wasm.rawcolliderset_coSetRadius(this.__wbg_ptr, handle, newRadius);\n    }\n    /**\n     * The half height of this collider if it is a capsule, cylinder, or cone shape.\n     * @param {number} handle\n     * @returns {number | undefined}\n     */\n    coHalfHeight(handle) {\n        const ret = wasm.rawcolliderset_coHalfHeight(this.__wbg_ptr, handle);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * Set the half height of this collider if it is a capsule, cylinder, or cone shape.\n     * @param {number} handle\n     * @param {number} newHalfheight\n     */\n    coSetHalfHeight(handle, newHalfheight) {\n        wasm.rawcolliderset_coSetHalfHeight(this.__wbg_ptr, handle, newHalfheight);\n    }\n    /**\n     * The radius of the round edges of this collider.\n     * @param {number} handle\n     * @returns {number | undefined}\n     */\n    coRoundRadius(handle) {\n        const ret = wasm.rawcolliderset_coRoundRadius(this.__wbg_ptr, handle);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * Set the radius of the round edges of this collider.\n     * @param {number} handle\n     * @param {number} newBorderRadius\n     */\n    coSetRoundRadius(handle, newBorderRadius) {\n        wasm.rawcolliderset_coSetRoundRadius(this.__wbg_ptr, handle, newBorderRadius);\n    }\n    /**\n     * @param {number} handle\n     * @returns {Int32Array | undefined}\n     */\n    coVoxelData(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coVoxelData(retptr, this.__wbg_ptr, handle);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayI32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_export_1(r0, r1 * 4, 4);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} handle\n     * @returns {RawVector | undefined}\n     */\n    coVoxelSize(handle) {\n        const ret = wasm.rawcolliderset_coVoxelSize(this.__wbg_ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} ix\n     * @param {number} iy\n     * @param {boolean} filled\n     */\n    coSetVoxel(handle, ix, iy, filled) {\n        wasm.rawcolliderset_coSetVoxel(this.__wbg_ptr, handle, ix, iy, filled);\n    }\n    /**\n     * @param {number} handle1\n     * @param {number} handle2\n     * @param {number} ix\n     * @param {number} iy\n     * @param {number} shift_x\n     * @param {number} shift_y\n     */\n    coPropagateVoxelChange(handle1, handle2, ix, iy, shift_x, shift_y) {\n        wasm.rawcolliderset_coPropagateVoxelChange(this.__wbg_ptr, handle1, handle2, ix, iy, shift_x, shift_y);\n    }\n    /**\n     * @param {number} handle1\n     * @param {number} handle2\n     * @param {number} shift_x\n     * @param {number} shift_y\n     */\n    coCombineVoxelStates(handle1, handle2, shift_x, shift_y) {\n        wasm.rawcolliderset_coCombineVoxelStates(this.__wbg_ptr, handle1, handle2, shift_x, shift_y);\n    }\n    /**\n     * The vertices of this triangle mesh, polyline, convex polyhedron, segment, triangle or convex polyhedron, if it is one.\n     * @param {number} handle\n     * @returns {Float32Array | undefined}\n     */\n    coVertices(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coVertices(retptr, this.__wbg_ptr, handle);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayF32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_export_1(r0, r1 * 4, 4);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * The indices of this triangle mesh, polyline, or convex polyhedron, if it is one.\n     * @param {number} handle\n     * @returns {Uint32Array | undefined}\n     */\n    coIndices(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coIndices(retptr, this.__wbg_ptr, handle);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayU32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_export_1(r0, r1 * 4, 4);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} handle\n     * @returns {number | undefined}\n     */\n    coTriMeshFlags(handle) {\n        const ret = wasm.rawcolliderset_coTriMeshFlags(this.__wbg_ptr, handle);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * The height of this heightfield if it is one.\n     * @param {number} handle\n     * @returns {Float32Array | undefined}\n     */\n    coHeightfieldHeights(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHeightfieldHeights(retptr, this.__wbg_ptr, handle);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayF32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_export_1(r0, r1 * 4, 4);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * The scaling factor applied of this heightfield if it is one.\n     * @param {number} handle\n     * @returns {RawVector | undefined}\n     */\n    coHeightfieldScale(handle) {\n        const ret = wasm.rawcolliderset_coHeightfieldScale(this.__wbg_ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n     * The unique integer identifier of the collider this collider is attached to.\n     * @param {number} handle\n     * @returns {number | undefined}\n     */\n    coParent(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coParent(retptr, this.__wbg_ptr, handle);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r2 = getDataViewMemory0().getFloat64(retptr + 8 * 1, true);\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} handle\n     * @param {boolean} enabled\n     */\n    coSetEnabled(handle, enabled) {\n        wasm.rawcolliderset_coSetEnabled(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    coIsEnabled(handle) {\n        const ret = wasm.rawcolliderset_coIsEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * @param {number} handle\n     * @param {number} contact_skin\n     */\n    coSetContactSkin(handle, contact_skin) {\n        wasm.rawcolliderset_coSetContactSkin(this.__wbg_ptr, handle, contact_skin);\n    }\n    /**\n     * @param {number} handle\n     * @returns {number}\n     */\n    coContactSkin(handle) {\n        const ret = wasm.rawcolliderset_coContactSkin(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The friction coefficient of this collider.\n     * @param {number} handle\n     * @returns {number}\n     */\n    coFriction(handle) {\n        const ret = wasm.rawcolliderset_coFriction(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The restitution coefficient of this collider.\n     * @param {number} handle\n     * @returns {number}\n     */\n    coRestitution(handle) {\n        const ret = wasm.rawcolliderset_coRestitution(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The density of this collider.\n     * @param {number} handle\n     * @returns {number}\n     */\n    coDensity(handle) {\n        const ret = wasm.rawcolliderset_coDensity(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The mass of this collider.\n     * @param {number} handle\n     * @returns {number}\n     */\n    coMass(handle) {\n        const ret = wasm.rawcolliderset_coMass(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The volume of this collider.\n     * @param {number} handle\n     * @returns {number}\n     */\n    coVolume(handle) {\n        const ret = wasm.rawcolliderset_coVolume(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The collision groups of this collider.\n     * @param {number} handle\n     * @returns {number}\n     */\n    coCollisionGroups(handle) {\n        const ret = wasm.rawcolliderset_coCollisionGroups(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n     * The solver groups of this collider.\n     * @param {number} handle\n     * @returns {number}\n     */\n    coSolverGroups(handle) {\n        const ret = wasm.rawcolliderset_coSolverGroups(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n     * The physics hooks enabled for this collider.\n     * @param {number} handle\n     * @returns {number}\n     */\n    coActiveHooks(handle) {\n        const ret = wasm.rawcolliderset_coActiveHooks(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n     * The collision types enabled for this collider.\n     * @param {number} handle\n     * @returns {number}\n     */\n    coActiveCollisionTypes(handle) {\n        const ret = wasm.rawcolliderset_coActiveCollisionTypes(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The events enabled for this collider.\n     * @param {number} handle\n     * @returns {number}\n     */\n    coActiveEvents(handle) {\n        const ret = wasm.rawcolliderset_coActiveEvents(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n     * The total force magnitude beyond which a contact force event can be emitted.\n     * @param {number} handle\n     * @returns {number}\n     */\n    coContactForceEventThreshold(handle) {\n        const ret = wasm.rawcolliderset_coContactForceEventThreshold(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * @param {number} handle\n     * @param {RawVector} point\n     * @returns {boolean}\n     */\n    coContainsPoint(handle, point) {\n        _assertClass(point, RawVector);\n        const ret = wasm.rawcolliderset_coContainsPoint(this.__wbg_ptr, handle, point.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @param {number} handle\n     * @param {RawVector} colliderVel\n     * @param {RawShape} shape2\n     * @param {RawVector} shape2Pos\n     * @param {RawRotation} shape2Rot\n     * @param {RawVector} shape2Vel\n     * @param {number} target_distance\n     * @param {number} maxToi\n     * @param {boolean} stop_at_penetration\n     * @returns {RawShapeCastHit | undefined}\n     */\n    coCastShape(handle, colliderVel, shape2, shape2Pos, shape2Rot, shape2Vel, target_distance, maxToi, stop_at_penetration) {\n        _assertClass(colliderVel, RawVector);\n        _assertClass(shape2, RawShape);\n        _assertClass(shape2Pos, RawVector);\n        _assertClass(shape2Rot, RawRotation);\n        _assertClass(shape2Vel, RawVector);\n        const ret = wasm.rawcolliderset_coCastShape(this.__wbg_ptr, handle, colliderVel.__wbg_ptr, shape2.__wbg_ptr, shape2Pos.__wbg_ptr, shape2Rot.__wbg_ptr, shape2Vel.__wbg_ptr, target_distance, maxToi, stop_at_penetration);\n        return ret === 0 ? undefined : RawShapeCastHit.__wrap(ret);\n    }\n    /**\n     * @param {number} handle\n     * @param {RawVector} collider1Vel\n     * @param {number} collider2handle\n     * @param {RawVector} collider2Vel\n     * @param {number} target_distance\n     * @param {number} max_toi\n     * @param {boolean} stop_at_penetration\n     * @returns {RawColliderShapeCastHit | undefined}\n     */\n    coCastCollider(handle, collider1Vel, collider2handle, collider2Vel, target_distance, max_toi, stop_at_penetration) {\n        _assertClass(collider1Vel, RawVector);\n        _assertClass(collider2Vel, RawVector);\n        const ret = wasm.rawcolliderset_coCastCollider(this.__wbg_ptr, handle, collider1Vel.__wbg_ptr, collider2handle, collider2Vel.__wbg_ptr, target_distance, max_toi, stop_at_penetration);\n        return ret === 0 ? undefined : RawColliderShapeCastHit.__wrap(ret);\n    }\n    /**\n     * @param {number} handle\n     * @param {RawShape} shape2\n     * @param {RawVector} shapePos2\n     * @param {RawRotation} shapeRot2\n     * @returns {boolean}\n     */\n    coIntersectsShape(handle, shape2, shapePos2, shapeRot2) {\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawcolliderset_coIntersectsShape(this.__wbg_ptr, handle, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @param {number} handle\n     * @param {RawShape} shape2\n     * @param {RawVector} shapePos2\n     * @param {RawRotation} shapeRot2\n     * @param {number} prediction\n     * @returns {RawShapeContact | undefined}\n     */\n    coContactShape(handle, shape2, shapePos2, shapeRot2, prediction) {\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawcolliderset_coContactShape(this.__wbg_ptr, handle, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr, prediction);\n        return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} collider2handle\n     * @param {number} prediction\n     * @returns {RawShapeContact | undefined}\n     */\n    coContactCollider(handle, collider2handle, prediction) {\n        const ret = wasm.rawcolliderset_coContactCollider(this.__wbg_ptr, handle, collider2handle, prediction);\n        return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n     * @param {number} handle\n     * @param {RawVector} point\n     * @param {boolean} solid\n     * @returns {RawPointProjection}\n     */\n    coProjectPoint(handle, point, solid) {\n        _assertClass(point, RawVector);\n        const ret = wasm.rawcolliderset_coProjectPoint(this.__wbg_ptr, handle, point.__wbg_ptr, solid);\n        return RawPointProjection.__wrap(ret);\n    }\n    /**\n     * @param {number} handle\n     * @param {RawVector} rayOrig\n     * @param {RawVector} rayDir\n     * @param {number} maxToi\n     * @returns {boolean}\n     */\n    coIntersectsRay(handle, rayOrig, rayDir, maxToi) {\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawcolliderset_coIntersectsRay(this.__wbg_ptr, handle, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi);\n        return ret !== 0;\n    }\n    /**\n     * @param {number} handle\n     * @param {RawVector} rayOrig\n     * @param {RawVector} rayDir\n     * @param {number} maxToi\n     * @param {boolean} solid\n     * @returns {number}\n     */\n    coCastRay(handle, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawcolliderset_coCastRay(this.__wbg_ptr, handle, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid);\n        return ret;\n    }\n    /**\n     * @param {number} handle\n     * @param {RawVector} rayOrig\n     * @param {RawVector} rayDir\n     * @param {number} maxToi\n     * @param {boolean} solid\n     * @returns {RawRayIntersection | undefined}\n     */\n    coCastRayAndGetNormal(handle, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawcolliderset_coCastRayAndGetNormal(this.__wbg_ptr, handle, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid);\n        return ret === 0 ? undefined : RawRayIntersection.__wrap(ret);\n    }\n    /**\n     * @param {number} handle\n     * @param {boolean} is_sensor\n     */\n    coSetSensor(handle, is_sensor) {\n        wasm.rawcolliderset_coSetSensor(this.__wbg_ptr, handle, is_sensor);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} restitution\n     */\n    coSetRestitution(handle, restitution) {\n        wasm.rawcolliderset_coSetRestitution(this.__wbg_ptr, handle, restitution);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} friction\n     */\n    coSetFriction(handle, friction) {\n        wasm.rawcolliderset_coSetFriction(this.__wbg_ptr, handle, friction);\n    }\n    /**\n     * @param {number} handle\n     * @returns {number}\n     */\n    coFrictionCombineRule(handle) {\n        const ret = wasm.rawcolliderset_coFrictionCombineRule(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} handle\n     * @param {number} rule\n     */\n    coSetFrictionCombineRule(handle, rule) {\n        wasm.rawcolliderset_coSetFrictionCombineRule(this.__wbg_ptr, handle, rule);\n    }\n    /**\n     * @param {number} handle\n     * @returns {number}\n     */\n    coRestitutionCombineRule(handle) {\n        const ret = wasm.rawcolliderset_coRestitutionCombineRule(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} handle\n     * @param {number} rule\n     */\n    coSetRestitutionCombineRule(handle, rule) {\n        wasm.rawcolliderset_coSetRestitutionCombineRule(this.__wbg_ptr, handle, rule);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} groups\n     */\n    coSetCollisionGroups(handle, groups) {\n        wasm.rawcolliderset_coSetCollisionGroups(this.__wbg_ptr, handle, groups);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} groups\n     */\n    coSetSolverGroups(handle, groups) {\n        wasm.rawcolliderset_coSetSolverGroups(this.__wbg_ptr, handle, groups);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} hooks\n     */\n    coSetActiveHooks(handle, hooks) {\n        wasm.rawcolliderset_coSetActiveHooks(this.__wbg_ptr, handle, hooks);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} events\n     */\n    coSetActiveEvents(handle, events) {\n        wasm.rawcolliderset_coSetActiveEvents(this.__wbg_ptr, handle, events);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} types\n     */\n    coSetActiveCollisionTypes(handle, types) {\n        wasm.rawcolliderset_coSetActiveCollisionTypes(this.__wbg_ptr, handle, types);\n    }\n    /**\n     * @param {number} handle\n     * @param {RawShape} shape\n     */\n    coSetShape(handle, shape) {\n        _assertClass(shape, RawShape);\n        wasm.rawcolliderset_coSetShape(this.__wbg_ptr, handle, shape.__wbg_ptr);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} threshold\n     */\n    coSetContactForceEventThreshold(handle, threshold) {\n        wasm.rawcolliderset_coSetContactForceEventThreshold(this.__wbg_ptr, handle, threshold);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} density\n     */\n    coSetDensity(handle, density) {\n        wasm.rawcolliderset_coSetDensity(this.__wbg_ptr, handle, density);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} mass\n     */\n    coSetMass(handle, mass) {\n        wasm.rawcolliderset_coSetMass(this.__wbg_ptr, handle, mass);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} mass\n     * @param {RawVector} centerOfMass\n     * @param {number} principalAngularInertia\n     */\n    coSetMassProperties(handle, mass, centerOfMass, principalAngularInertia) {\n        _assertClass(centerOfMass, RawVector);\n        wasm.rawcolliderset_coSetMassProperties(this.__wbg_ptr, handle, mass, centerOfMass.__wbg_ptr, principalAngularInertia);\n    }\n    constructor() {\n        const ret = wasm.rawcolliderset_new();\n        this.__wbg_ptr = ret >>> 0;\n        RawColliderSetFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {number}\n     */\n    len() {\n        const ret = wasm.rawcolliderset_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    contains(handle) {\n        const ret = wasm.rawcolliderset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * @param {boolean} enabled\n     * @param {RawShape} shape\n     * @param {RawVector} translation\n     * @param {RawRotation} rotation\n     * @param {number} massPropsMode\n     * @param {number} mass\n     * @param {RawVector} centerOfMass\n     * @param {number} principalAngularInertia\n     * @param {number} density\n     * @param {number} friction\n     * @param {number} restitution\n     * @param {number} frictionCombineRule\n     * @param {number} restitutionCombineRule\n     * @param {boolean} isSensor\n     * @param {number} collisionGroups\n     * @param {number} solverGroups\n     * @param {number} activeCollisionTypes\n     * @param {number} activeHooks\n     * @param {number} activeEvents\n     * @param {number} contactForceEventThreshold\n     * @param {number} contactSkin\n     * @param {boolean} hasParent\n     * @param {number} parent\n     * @param {RawRigidBodySet} bodies\n     * @returns {number | undefined}\n     */\n    createCollider(enabled, shape, translation, rotation, massPropsMode, mass, centerOfMass, principalAngularInertia, density, friction, restitution, frictionCombineRule, restitutionCombineRule, isSensor, collisionGroups, solverGroups, activeCollisionTypes, activeHooks, activeEvents, contactForceEventThreshold, contactSkin, hasParent, parent, bodies) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(shape, RawShape);\n            _assertClass(translation, RawVector);\n            _assertClass(rotation, RawRotation);\n            _assertClass(centerOfMass, RawVector);\n            _assertClass(bodies, RawRigidBodySet);\n            wasm.rawcolliderset_createCollider(retptr, this.__wbg_ptr, enabled, shape.__wbg_ptr, translation.__wbg_ptr, rotation.__wbg_ptr, massPropsMode, mass, centerOfMass.__wbg_ptr, principalAngularInertia, density, friction, restitution, frictionCombineRule, restitutionCombineRule, isSensor, collisionGroups, solverGroups, activeCollisionTypes, activeHooks, activeEvents, contactForceEventThreshold, contactSkin, hasParent, parent, bodies.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r2 = getDataViewMemory0().getFloat64(retptr + 8 * 1, true);\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Removes a collider from this set and wake-up the rigid-body it is attached to.\n     * @param {number} handle\n     * @param {RawIslandManager} islands\n     * @param {RawRigidBodySet} bodies\n     * @param {boolean} wakeUp\n     */\n    remove(handle, islands, bodies, wakeUp) {\n        _assertClass(islands, RawIslandManager);\n        _assertClass(bodies, RawRigidBodySet);\n        wasm.rawcolliderset_remove(this.__wbg_ptr, handle, islands.__wbg_ptr, bodies.__wbg_ptr, wakeUp);\n    }\n    /**\n     * Checks if a collider with the given integer handle exists.\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    isHandleValid(handle) {\n        const ret = wasm.rawcolliderset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * Applies the given JavaScript function to the integer handle of each collider managed by this collider set.\n     *\n     * # Parameters\n     * - `f(handle)`: the function to apply to the integer handle of each collider managed by this collider set. Called as `f(handle)`.\n     * @param {Function} f\n     */\n    forEachColliderHandle(f) {\n        try {\n            wasm.rawcolliderset_forEachColliderHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n\nconst RawColliderShapeCastHitFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawcollidershapecasthit_free(ptr >>> 0, 1));\n\nexport class RawColliderShapeCastHit {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawColliderShapeCastHit.prototype);\n        obj.__wbg_ptr = ptr;\n        RawColliderShapeCastHitFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawColliderShapeCastHitFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcollidershapecasthit_free(ptr, 0);\n    }\n    /**\n     * @returns {number}\n     */\n    colliderHandle() {\n        const ret = wasm.rawcollidershapecasthit_colliderHandle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    time_of_impact() {\n        const ret = wasm.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {RawVector}\n     */\n    witness1() {\n        const ret = wasm.rawcollidershapecasthit_witness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    witness2() {\n        const ret = wasm.rawcollidershapecasthit_witness2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    normal1() {\n        const ret = wasm.rawcollidershapecasthit_normal1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    normal2() {\n        const ret = wasm.rawcollidershapecasthit_normal2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n\nconst RawContactForceEventFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawcontactforceevent_free(ptr >>> 0, 1));\n\nexport class RawContactForceEvent {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawContactForceEvent.prototype);\n        obj.__wbg_ptr = ptr;\n        RawContactForceEventFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawContactForceEventFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcontactforceevent_free(ptr, 0);\n    }\n    /**\n     * The first collider involved in the contact.\n     * @returns {number}\n     */\n    collider1() {\n        const ret = wasm.rawcollidershapecasthit_colliderHandle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The second collider involved in the contact.\n     * @returns {number}\n     */\n    collider2() {\n        const ret = wasm.rawcontactforceevent_collider2(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The sum of all the forces between the two colliders.\n     * @returns {RawVector}\n     */\n    total_force() {\n        const ret = wasm.rawcontactforceevent_total_force(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * The sum of the magnitudes of each force between the two colliders.\n     *\n     * Note that this is **not** the same as the magnitude of `self.total_force`.\n     * Here we are summing the magnitude of all the forces, instead of taking\n     * the magnitude of their sum.\n     * @returns {number}\n     */\n    total_force_magnitude() {\n        const ret = wasm.rawcontactforceevent_total_force_magnitude(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The world-space (unit) direction of the force with strongest magnitude.\n     * @returns {RawVector}\n     */\n    max_force_direction() {\n        const ret = wasm.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * The magnitude of the largest force at a contact point of this contact pair.\n     * @returns {number}\n     */\n    max_force_magnitude() {\n        const ret = wasm.rawcontactforceevent_max_force_magnitude(this.__wbg_ptr);\n        return ret;\n    }\n}\n\nconst RawContactManifoldFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawcontactmanifold_free(ptr >>> 0, 1));\n\nexport class RawContactManifold {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawContactManifold.prototype);\n        obj.__wbg_ptr = ptr;\n        RawContactManifoldFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawContactManifoldFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcontactmanifold_free(ptr, 0);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    normal() {\n        const ret = wasm.rawcontactmanifold_normal(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    local_n1() {\n        const ret = wasm.rawcontactmanifold_local_n1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    local_n2() {\n        const ret = wasm.rawcontactmanifold_local_n2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    subshape1() {\n        const ret = wasm.rawcontactmanifold_subshape1(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    subshape2() {\n        const ret = wasm.rawcontactmanifold_subshape2(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    num_contacts() {\n        const ret = wasm.rawcontactmanifold_num_contacts(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} i\n     * @returns {RawVector | undefined}\n     */\n    contact_local_p1(i) {\n        const ret = wasm.rawcontactmanifold_contact_local_p1(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n     * @param {number} i\n     * @returns {RawVector | undefined}\n     */\n    contact_local_p2(i) {\n        const ret = wasm.rawcontactmanifold_contact_local_p2(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n     * @param {number} i\n     * @returns {number}\n     */\n    contact_dist(i) {\n        const ret = wasm.rawcontactmanifold_contact_dist(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n     * @param {number} i\n     * @returns {number}\n     */\n    contact_fid1(i) {\n        const ret = wasm.rawcontactmanifold_contact_fid1(this.__wbg_ptr, i);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} i\n     * @returns {number}\n     */\n    contact_fid2(i) {\n        const ret = wasm.rawcontactmanifold_contact_fid2(this.__wbg_ptr, i);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} i\n     * @returns {number}\n     */\n    contact_impulse(i) {\n        const ret = wasm.rawcontactmanifold_contact_impulse(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n     * @param {number} i\n     * @returns {number}\n     */\n    contact_tangent_impulse(i) {\n        const ret = wasm.rawcontactmanifold_contact_tangent_impulse(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    num_solver_contacts() {\n        const ret = wasm.rawcontactmanifold_num_solver_contacts(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} i\n     * @returns {RawVector | undefined}\n     */\n    solver_contact_point(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_point(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n     * @param {number} i\n     * @returns {number}\n     */\n    solver_contact_dist(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_dist(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n     * @param {number} i\n     * @returns {number}\n     */\n    solver_contact_friction(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_friction(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n     * @param {number} i\n     * @returns {number}\n     */\n    solver_contact_restitution(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_restitution(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n     * @param {number} i\n     * @returns {RawVector}\n     */\n    solver_contact_tangent_velocity(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_tangent_velocity(this.__wbg_ptr, i);\n        return RawVector.__wrap(ret);\n    }\n}\n\nconst RawContactPairFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawcontactpair_free(ptr >>> 0, 1));\n\nexport class RawContactPair {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawContactPair.prototype);\n        obj.__wbg_ptr = ptr;\n        RawContactPairFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawContactPairFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcontactpair_free(ptr, 0);\n    }\n    /**\n     * @returns {number}\n     */\n    collider1() {\n        const ret = wasm.rawcontactpair_collider1(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    collider2() {\n        const ret = wasm.rawcontactpair_collider2(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    numContactManifolds() {\n        const ret = wasm.rawcontactpair_numContactManifolds(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} i\n     * @returns {RawContactManifold | undefined}\n     */\n    contactManifold(i) {\n        const ret = wasm.rawcontactpair_contactManifold(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawContactManifold.__wrap(ret);\n    }\n}\n\nconst RawDebugRenderPipelineFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawdebugrenderpipeline_free(ptr >>> 0, 1));\n\nexport class RawDebugRenderPipeline {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawDebugRenderPipelineFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawdebugrenderpipeline_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.rawdebugrenderpipeline_new();\n        this.__wbg_ptr = ret >>> 0;\n        RawDebugRenderPipelineFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {Float32Array}\n     */\n    vertices() {\n        const ret = wasm.rawdebugrenderpipeline_vertices(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @returns {Float32Array}\n     */\n    colors() {\n        const ret = wasm.rawdebugrenderpipeline_colors(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawImpulseJointSet} impulse_joints\n     * @param {RawMultibodyJointSet} multibody_joints\n     * @param {RawNarrowPhase} narrow_phase\n     * @param {number} filter_flags\n     * @param {Function} filter_predicate\n     */\n    render(bodies, colliders, impulse_joints, multibody_joints, narrow_phase, filter_flags, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(impulse_joints, RawImpulseJointSet);\n            _assertClass(multibody_joints, RawMultibodyJointSet);\n            _assertClass(narrow_phase, RawNarrowPhase);\n            wasm.rawdebugrenderpipeline_render(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, impulse_joints.__wbg_ptr, multibody_joints.__wbg_ptr, narrow_phase.__wbg_ptr, filter_flags, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n\nconst RawDeserializedWorldFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawdeserializedworld_free(ptr >>> 0, 1));\n\nexport class RawDeserializedWorld {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawDeserializedWorld.prototype);\n        obj.__wbg_ptr = ptr;\n        RawDeserializedWorldFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawDeserializedWorldFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawdeserializedworld_free(ptr, 0);\n    }\n    /**\n     * @returns {RawVector | undefined}\n     */\n    takeGravity() {\n        const ret = wasm.rawdeserializedworld_takeGravity(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawIntegrationParameters | undefined}\n     */\n    takeIntegrationParameters() {\n        const ret = wasm.rawdeserializedworld_takeIntegrationParameters(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawIntegrationParameters.__wrap(ret);\n    }\n    /**\n     * @returns {RawIslandManager | undefined}\n     */\n    takeIslandManager() {\n        const ret = wasm.rawdeserializedworld_takeIslandManager(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawIslandManager.__wrap(ret);\n    }\n    /**\n     * @returns {RawBroadPhase | undefined}\n     */\n    takeBroadPhase() {\n        const ret = wasm.rawdeserializedworld_takeBroadPhase(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawBroadPhase.__wrap(ret);\n    }\n    /**\n     * @returns {RawNarrowPhase | undefined}\n     */\n    takeNarrowPhase() {\n        const ret = wasm.rawdeserializedworld_takeNarrowPhase(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawNarrowPhase.__wrap(ret);\n    }\n    /**\n     * @returns {RawRigidBodySet | undefined}\n     */\n    takeBodies() {\n        const ret = wasm.rawdeserializedworld_takeBodies(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawRigidBodySet.__wrap(ret);\n    }\n    /**\n     * @returns {RawColliderSet | undefined}\n     */\n    takeColliders() {\n        const ret = wasm.rawdeserializedworld_takeColliders(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawColliderSet.__wrap(ret);\n    }\n    /**\n     * @returns {RawImpulseJointSet | undefined}\n     */\n    takeImpulseJoints() {\n        const ret = wasm.rawdeserializedworld_takeImpulseJoints(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawImpulseJointSet.__wrap(ret);\n    }\n    /**\n     * @returns {RawMultibodyJointSet | undefined}\n     */\n    takeMultibodyJoints() {\n        const ret = wasm.rawdeserializedworld_takeMultibodyJoints(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawMultibodyJointSet.__wrap(ret);\n    }\n}\n\nconst RawEventQueueFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_raweventqueue_free(ptr >>> 0, 1));\n/**\n * A structure responsible for collecting events generated\n * by the physics engine.\n */\nexport class RawEventQueue {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawEventQueueFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_raweventqueue_free(ptr, 0);\n    }\n    /**\n     * Creates a new event collector.\n     *\n     * # Parameters\n     * - `autoDrain`: setting this to `true` is strongly recommended. If true, the collector will\n     * be automatically drained before each `world.step(collector)`. If false, the collector will\n     * keep all events in memory unless it is manually drained/cleared; this may lead to unbounded use of\n     * RAM if no drain is performed.\n     * @param {boolean} autoDrain\n     */\n    constructor(autoDrain) {\n        const ret = wasm.raweventqueue_new(autoDrain);\n        this.__wbg_ptr = ret >>> 0;\n        RawEventQueueFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Applies the given javascript closure on each collision event of this collector, then clear\n     * the internal collision event buffer.\n     *\n     * # Parameters\n     * - `f(handle1, handle2, started)`:  JavaScript closure applied to each collision event. The\n     * closure should take three arguments: two integers representing the handles of the colliders\n     * involved in the collision, and a boolean indicating if the collision started (true) or stopped\n     * (false).\n     * @param {Function} f\n     */\n    drainCollisionEvents(f) {\n        try {\n            wasm.raweventqueue_drainCollisionEvents(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @param {Function} f\n     */\n    drainContactForceEvents(f) {\n        try {\n            wasm.raweventqueue_drainContactForceEvents(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * Removes all events contained by this collector.\n     */\n    clear() {\n        wasm.raweventqueue_clear(this.__wbg_ptr);\n    }\n}\n\nconst RawGenericJointFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawgenericjoint_free(ptr >>> 0, 1));\n\nexport class RawGenericJoint {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawGenericJoint.prototype);\n        obj.__wbg_ptr = ptr;\n        RawGenericJointFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawGenericJointFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawgenericjoint_free(ptr, 0);\n    }\n    /**\n     * @param {number} rest_length\n     * @param {number} stiffness\n     * @param {number} damping\n     * @param {RawVector} anchor1\n     * @param {RawVector} anchor2\n     * @returns {RawGenericJoint}\n     */\n    static spring(rest_length, stiffness, damping, anchor1, anchor2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        const ret = wasm.rawgenericjoint_spring(rest_length, stiffness, damping, anchor1.__wbg_ptr, anchor2.__wbg_ptr);\n        return RawGenericJoint.__wrap(ret);\n    }\n    /**\n     * @param {number} length\n     * @param {RawVector} anchor1\n     * @param {RawVector} anchor2\n     * @returns {RawGenericJoint}\n     */\n    static rope(length, anchor1, anchor2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        const ret = wasm.rawgenericjoint_rope(length, anchor1.__wbg_ptr, anchor2.__wbg_ptr);\n        return RawGenericJoint.__wrap(ret);\n    }\n    /**\n     * Creates a new joint descriptor that builds a Prismatic joint.\n     *\n     * A prismatic joint removes all the degrees of freedom between the\n     * affected bodies, except for the translation along one axis.\n     *\n     * Returns `None` if any of the provided axes cannot be normalized.\n     * @param {RawVector} anchor1\n     * @param {RawVector} anchor2\n     * @param {RawVector} axis\n     * @param {boolean} limitsEnabled\n     * @param {number} limitsMin\n     * @param {number} limitsMax\n     * @returns {RawGenericJoint | undefined}\n     */\n    static prismatic(anchor1, anchor2, axis, limitsEnabled, limitsMin, limitsMax) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        _assertClass(axis, RawVector);\n        const ret = wasm.rawgenericjoint_prismatic(anchor1.__wbg_ptr, anchor2.__wbg_ptr, axis.__wbg_ptr, limitsEnabled, limitsMin, limitsMax);\n        return ret === 0 ? undefined : RawGenericJoint.__wrap(ret);\n    }\n    /**\n     * Creates a new joint descriptor that builds a Fixed joint.\n     *\n     * A fixed joint removes all the degrees of freedom between the affected bodies.\n     * @param {RawVector} anchor1\n     * @param {RawRotation} axes1\n     * @param {RawVector} anchor2\n     * @param {RawRotation} axes2\n     * @returns {RawGenericJoint}\n     */\n    static fixed(anchor1, axes1, anchor2, axes2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(axes1, RawRotation);\n        _assertClass(anchor2, RawVector);\n        _assertClass(axes2, RawRotation);\n        const ret = wasm.rawgenericjoint_fixed(anchor1.__wbg_ptr, axes1.__wbg_ptr, anchor2.__wbg_ptr, axes2.__wbg_ptr);\n        return RawGenericJoint.__wrap(ret);\n    }\n    /**\n     * Create a new joint descriptor that builds Revolute joints.\n     *\n     * A revolute joint removes all degrees of freedom between the affected\n     * bodies except for the rotation.\n     * @param {RawVector} anchor1\n     * @param {RawVector} anchor2\n     * @returns {RawGenericJoint | undefined}\n     */\n    static revolute(anchor1, anchor2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        const ret = wasm.rawgenericjoint_revolute(anchor1.__wbg_ptr, anchor2.__wbg_ptr);\n        return ret === 0 ? undefined : RawGenericJoint.__wrap(ret);\n    }\n}\n\nconst RawImpulseJointSetFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawimpulsejointset_free(ptr >>> 0, 1));\n\nexport class RawImpulseJointSet {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawImpulseJointSet.prototype);\n        obj.__wbg_ptr = ptr;\n        RawImpulseJointSetFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawImpulseJointSetFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawimpulsejointset_free(ptr, 0);\n    }\n    /**\n     * The type of this joint.\n     * @param {number} handle\n     * @returns {RawJointType}\n     */\n    jointType(handle) {\n        const ret = wasm.rawimpulsejointset_jointType(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The unique integer identifier of the first rigid-body this joint it attached to.\n     * @param {number} handle\n     * @returns {number}\n     */\n    jointBodyHandle1(handle) {\n        const ret = wasm.rawimpulsejointset_jointBodyHandle1(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The unique integer identifier of the second rigid-body this joint is attached to.\n     * @param {number} handle\n     * @returns {number}\n     */\n    jointBodyHandle2(handle) {\n        const ret = wasm.rawimpulsejointset_jointBodyHandle2(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The angular part of the joint’s local frame relative to the first rigid-body it is attached to.\n     * @param {number} handle\n     * @returns {RawRotation}\n     */\n    jointFrameX1(handle) {\n        const ret = wasm.rawimpulsejointset_jointFrameX1(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n     * The angular part of the joint’s local frame relative to the second rigid-body it is attached to.\n     * @param {number} handle\n     * @returns {RawRotation}\n     */\n    jointFrameX2(handle) {\n        const ret = wasm.rawimpulsejointset_jointFrameX2(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n     * The position of the first anchor of this joint.\n     *\n     * The first anchor gives the position of the points application point on the\n     * local frame of the first rigid-body it is attached to.\n     * @param {number} handle\n     * @returns {RawVector}\n     */\n    jointAnchor1(handle) {\n        const ret = wasm.rawimpulsejointset_jointAnchor1(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * The position of the second anchor of this joint.\n     *\n     * The second anchor gives the position of the points application point on the\n     * local frame of the second rigid-body it is attached to.\n     * @param {number} handle\n     * @returns {RawVector}\n     */\n    jointAnchor2(handle) {\n        const ret = wasm.rawimpulsejointset_jointAnchor2(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * Sets the position of the first local anchor\n     * @param {number} handle\n     * @param {RawVector} newPos\n     */\n    jointSetAnchor1(handle, newPos) {\n        _assertClass(newPos, RawVector);\n        wasm.rawimpulsejointset_jointSetAnchor1(this.__wbg_ptr, handle, newPos.__wbg_ptr);\n    }\n    /**\n     * Sets the position of the second local anchor\n     * @param {number} handle\n     * @param {RawVector} newPos\n     */\n    jointSetAnchor2(handle, newPos) {\n        _assertClass(newPos, RawVector);\n        wasm.rawimpulsejointset_jointSetAnchor2(this.__wbg_ptr, handle, newPos.__wbg_ptr);\n    }\n    /**\n     * Are contacts between the rigid-bodies attached by this joint enabled?\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    jointContactsEnabled(handle) {\n        const ret = wasm.rawimpulsejointset_jointContactsEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * Sets whether contacts are enabled between the rigid-bodies attached by this joint.\n     * @param {number} handle\n     * @param {boolean} enabled\n     */\n    jointSetContactsEnabled(handle, enabled) {\n        wasm.rawimpulsejointset_jointSetContactsEnabled(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n     * Are the limits for this joint enabled?\n     * @param {number} handle\n     * @param {RawJointAxis} axis\n     * @returns {boolean}\n     */\n    jointLimitsEnabled(handle, axis) {\n        const ret = wasm.rawimpulsejointset_jointLimitsEnabled(this.__wbg_ptr, handle, axis);\n        return ret !== 0;\n    }\n    /**\n     * Return the lower limit along the given joint axis.\n     * @param {number} handle\n     * @param {RawJointAxis} axis\n     * @returns {number}\n     */\n    jointLimitsMin(handle, axis) {\n        const ret = wasm.rawimpulsejointset_jointLimitsMin(this.__wbg_ptr, handle, axis);\n        return ret;\n    }\n    /**\n     * If this is a prismatic joint, returns its upper limit.\n     * @param {number} handle\n     * @param {RawJointAxis} axis\n     * @returns {number}\n     */\n    jointLimitsMax(handle, axis) {\n        const ret = wasm.rawimpulsejointset_jointLimitsMax(this.__wbg_ptr, handle, axis);\n        return ret;\n    }\n    /**\n     * Enables and sets the joint limits\n     * @param {number} handle\n     * @param {RawJointAxis} axis\n     * @param {number} min\n     * @param {number} max\n     */\n    jointSetLimits(handle, axis, min, max) {\n        wasm.rawimpulsejointset_jointSetLimits(this.__wbg_ptr, handle, axis, min, max);\n    }\n    /**\n     * @param {number} handle\n     * @param {RawJointAxis} axis\n     * @param {RawMotorModel} model\n     */\n    jointConfigureMotorModel(handle, axis, model) {\n        wasm.rawimpulsejointset_jointConfigureMotorModel(this.__wbg_ptr, handle, axis, model);\n    }\n    /**\n     * @param {number} handle\n     * @param {RawJointAxis} axis\n     * @param {number} targetVel\n     * @param {number} factor\n     */\n    jointConfigureMotorVelocity(handle, axis, targetVel, factor) {\n        wasm.rawimpulsejointset_jointConfigureMotorVelocity(this.__wbg_ptr, handle, axis, targetVel, factor);\n    }\n    /**\n     * @param {number} handle\n     * @param {RawJointAxis} axis\n     * @param {number} targetPos\n     * @param {number} stiffness\n     * @param {number} damping\n     */\n    jointConfigureMotorPosition(handle, axis, targetPos, stiffness, damping) {\n        wasm.rawimpulsejointset_jointConfigureMotorPosition(this.__wbg_ptr, handle, axis, targetPos, stiffness, damping);\n    }\n    /**\n     * @param {number} handle\n     * @param {RawJointAxis} axis\n     * @param {number} targetPos\n     * @param {number} targetVel\n     * @param {number} stiffness\n     * @param {number} damping\n     */\n    jointConfigureMotor(handle, axis, targetPos, targetVel, stiffness, damping) {\n        wasm.rawimpulsejointset_jointConfigureMotor(this.__wbg_ptr, handle, axis, targetPos, targetVel, stiffness, damping);\n    }\n    constructor() {\n        const ret = wasm.rawimpulsejointset_new();\n        this.__wbg_ptr = ret >>> 0;\n        RawImpulseJointSetFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {RawGenericJoint} params\n     * @param {number} parent1\n     * @param {number} parent2\n     * @param {boolean} wake_up\n     * @returns {number}\n     */\n    createJoint(params, parent1, parent2, wake_up) {\n        _assertClass(params, RawGenericJoint);\n        const ret = wasm.rawimpulsejointset_createJoint(this.__wbg_ptr, params.__wbg_ptr, parent1, parent2, wake_up);\n        return ret;\n    }\n    /**\n     * @param {number} handle\n     * @param {boolean} wakeUp\n     */\n    remove(handle, wakeUp) {\n        wasm.rawimpulsejointset_remove(this.__wbg_ptr, handle, wakeUp);\n    }\n    /**\n     * @returns {number}\n     */\n    len() {\n        const ret = wasm.rawimpulsejointset_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    contains(handle) {\n        const ret = wasm.rawimpulsejointset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * Applies the given JavaScript function to the integer handle of each joint managed by this physics world.\n     *\n     * # Parameters\n     * - `f(handle)`: the function to apply to the integer handle of each joint managed by this set. Called as `f(collider)`.\n     * @param {Function} f\n     */\n    forEachJointHandle(f) {\n        try {\n            wasm.rawimpulsejointset_forEachJointHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * Applies the given JavaScript function to the integer handle of each joint attached to the given rigid-body.\n     *\n     * # Parameters\n     * - `f(handle)`: the function to apply to the integer handle of each joint attached to the rigid-body. Called as `f(collider)`.\n     * @param {number} body\n     * @param {Function} f\n     */\n    forEachJointAttachedToRigidBody(body, f) {\n        try {\n            wasm.rawimpulsejointset_forEachJointAttachedToRigidBody(this.__wbg_ptr, body, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n\nconst RawIntegrationParametersFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawintegrationparameters_free(ptr >>> 0, 1));\n\nexport class RawIntegrationParameters {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawIntegrationParameters.prototype);\n        obj.__wbg_ptr = ptr;\n        RawIntegrationParametersFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawIntegrationParametersFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawintegrationparameters_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.rawintegrationparameters_new();\n        this.__wbg_ptr = ret >>> 0;\n        RawIntegrationParametersFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {number}\n     */\n    get dt() {\n        const ret = wasm.rawintegrationparameters_dt(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    get contact_erp() {\n        const ret = wasm.rawintegrationparameters_contact_erp(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    get normalizedAllowedLinearError() {\n        const ret = wasm.rawcontactforceevent_max_force_magnitude(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    get normalizedPredictionDistance() {\n        const ret = wasm.rawintegrationparameters_normalizedPredictionDistance(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    get numSolverIterations() {\n        const ret = wasm.rawintegrationparameters_numSolverIterations(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    get numAdditionalFrictionIterations() {\n        const ret = wasm.rawintegrationparameters_numAdditionalFrictionIterations(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    get numInternalPgsIterations() {\n        const ret = wasm.rawintegrationparameters_numInternalPgsIterations(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    get minIslandSize() {\n        const ret = wasm.rawintegrationparameters_minIslandSize(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    get maxCcdSubsteps() {\n        const ret = wasm.rawintegrationparameters_maxCcdSubsteps(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    get lengthUnit() {\n        const ret = wasm.rawcontactforceevent_total_force_magnitude(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @param {number} value\n     */\n    set dt(value) {\n        wasm.rawintegrationparameters_set_dt(this.__wbg_ptr, value);\n    }\n    /**\n     * @param {number} value\n     */\n    set contact_natural_frequency(value) {\n        wasm.rawintegrationparameters_set_contact_natural_frequency(this.__wbg_ptr, value);\n    }\n    /**\n     * @param {number} value\n     */\n    set normalizedAllowedLinearError(value) {\n        wasm.rawintegrationparameters_set_normalizedAllowedLinearError(this.__wbg_ptr, value);\n    }\n    /**\n     * @param {number} value\n     */\n    set normalizedPredictionDistance(value) {\n        wasm.rawintegrationparameters_set_normalizedPredictionDistance(this.__wbg_ptr, value);\n    }\n    /**\n     * @param {number} value\n     */\n    set numSolverIterations(value) {\n        wasm.rawintegrationparameters_set_numSolverIterations(this.__wbg_ptr, value);\n    }\n    /**\n     * @param {number} value\n     */\n    set numAdditionalFrictionIterations(value) {\n        wasm.rawintegrationparameters_set_numAdditionalFrictionIterations(this.__wbg_ptr, value);\n    }\n    /**\n     * @param {number} value\n     */\n    set numInternalPgsIterations(value) {\n        wasm.rawintegrationparameters_set_numInternalPgsIterations(this.__wbg_ptr, value);\n    }\n    /**\n     * @param {number} value\n     */\n    set minIslandSize(value) {\n        wasm.rawintegrationparameters_set_minIslandSize(this.__wbg_ptr, value);\n    }\n    /**\n     * @param {number} value\n     */\n    set maxCcdSubsteps(value) {\n        wasm.rawintegrationparameters_set_maxCcdSubsteps(this.__wbg_ptr, value);\n    }\n    /**\n     * @param {number} value\n     */\n    set lengthUnit(value) {\n        wasm.rawintegrationparameters_set_lengthUnit(this.__wbg_ptr, value);\n    }\n    switchToStandardPgsSolver() {\n        wasm.rawintegrationparameters_switchToStandardPgsSolver(this.__wbg_ptr);\n    }\n    switchToSmallStepsPgsSolver() {\n        wasm.rawintegrationparameters_switchToSmallStepsPgsSolver(this.__wbg_ptr);\n    }\n    switchToSmallStepsPgsSolverWithoutWarmstart() {\n        wasm.rawintegrationparameters_switchToSmallStepsPgsSolverWithoutWarmstart(this.__wbg_ptr);\n    }\n}\n\nconst RawIslandManagerFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawislandmanager_free(ptr >>> 0, 1));\n\nexport class RawIslandManager {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawIslandManager.prototype);\n        obj.__wbg_ptr = ptr;\n        RawIslandManagerFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawIslandManagerFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawislandmanager_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.rawislandmanager_new();\n        this.__wbg_ptr = ret >>> 0;\n        RawIslandManagerFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Applies the given JavaScript function to the integer handle of each active rigid-body\n     * managed by this island manager.\n     *\n     * After a short time of inactivity, a rigid-body is automatically deactivated (\"asleep\") by\n     * the physics engine in order to save computational power. A sleeping rigid-body never moves\n     * unless it is moved manually by the user.\n     *\n     * # Parameters\n     * - `f(handle)`: the function to apply to the integer handle of each active rigid-body managed by this\n     *   set. Called as `f(collider)`.\n     * @param {Function} f\n     */\n    forEachActiveRigidBodyHandle(f) {\n        try {\n            wasm.rawislandmanager_forEachActiveRigidBodyHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n\nconst RawKinematicCharacterControllerFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawkinematiccharactercontroller_free(ptr >>> 0, 1));\n\nexport class RawKinematicCharacterController {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawKinematicCharacterControllerFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawkinematiccharactercontroller_free(ptr, 0);\n    }\n    /**\n     * @param {number} offset\n     */\n    constructor(offset) {\n        const ret = wasm.rawkinematiccharactercontroller_new(offset);\n        this.__wbg_ptr = ret >>> 0;\n        RawKinematicCharacterControllerFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {RawVector}\n     */\n    up() {\n        const ret = wasm.rawcollidershapecasthit_normal2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @param {RawVector} vector\n     */\n    setUp(vector) {\n        _assertClass(vector, RawVector);\n        wasm.rawkinematiccharactercontroller_setUp(this.__wbg_ptr, vector.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    normalNudgeFactor() {\n        const ret = wasm.rawkinematiccharactercontroller_normalNudgeFactor(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @param {number} value\n     */\n    setNormalNudgeFactor(value) {\n        wasm.rawkinematiccharactercontroller_setNormalNudgeFactor(this.__wbg_ptr, value);\n    }\n    /**\n     * @returns {number}\n     */\n    offset() {\n        const ret = wasm.rawintegrationparameters_dt(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @param {number} value\n     */\n    setOffset(value) {\n        wasm.rawkinematiccharactercontroller_setOffset(this.__wbg_ptr, value);\n    }\n    /**\n     * @returns {boolean}\n     */\n    slideEnabled() {\n        const ret = wasm.rawkinematiccharactercontroller_slideEnabled(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @param {boolean} enabled\n     */\n    setSlideEnabled(enabled) {\n        wasm.rawkinematiccharactercontroller_setSlideEnabled(this.__wbg_ptr, enabled);\n    }\n    /**\n     * @returns {number | undefined}\n     */\n    autostepMaxHeight() {\n        const ret = wasm.rawkinematiccharactercontroller_autostepMaxHeight(this.__wbg_ptr);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * @returns {number | undefined}\n     */\n    autostepMinWidth() {\n        const ret = wasm.rawkinematiccharactercontroller_autostepMinWidth(this.__wbg_ptr);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * @returns {boolean | undefined}\n     */\n    autostepIncludesDynamicBodies() {\n        const ret = wasm.rawkinematiccharactercontroller_autostepIncludesDynamicBodies(this.__wbg_ptr);\n        return ret === 0xFFFFFF ? undefined : ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    autostepEnabled() {\n        const ret = wasm.rawkinematiccharactercontroller_autostepEnabled(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @param {number} maxHeight\n     * @param {number} minWidth\n     * @param {boolean} includeDynamicBodies\n     */\n    enableAutostep(maxHeight, minWidth, includeDynamicBodies) {\n        wasm.rawkinematiccharactercontroller_enableAutostep(this.__wbg_ptr, maxHeight, minWidth, includeDynamicBodies);\n    }\n    disableAutostep() {\n        wasm.rawkinematiccharactercontroller_disableAutostep(this.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    maxSlopeClimbAngle() {\n        const ret = wasm.rawintegrationparameters_normalizedPredictionDistance(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @param {number} angle\n     */\n    setMaxSlopeClimbAngle(angle) {\n        wasm.rawintegrationparameters_set_normalizedPredictionDistance(this.__wbg_ptr, angle);\n    }\n    /**\n     * @returns {number}\n     */\n    minSlopeSlideAngle() {\n        const ret = wasm.rawkinematiccharactercontroller_minSlopeSlideAngle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @param {number} angle\n     */\n    setMinSlopeSlideAngle(angle) {\n        wasm.rawkinematiccharactercontroller_setMinSlopeSlideAngle(this.__wbg_ptr, angle);\n    }\n    /**\n     * @returns {number | undefined}\n     */\n    snapToGroundDistance() {\n        const ret = wasm.rawkinematiccharactercontroller_snapToGroundDistance(this.__wbg_ptr);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * @param {number} distance\n     */\n    enableSnapToGround(distance) {\n        wasm.rawkinematiccharactercontroller_enableSnapToGround(this.__wbg_ptr, distance);\n    }\n    disableSnapToGround() {\n        wasm.rawkinematiccharactercontroller_disableSnapToGround(this.__wbg_ptr);\n    }\n    /**\n     * @returns {boolean}\n     */\n    snapToGroundEnabled() {\n        const ret = wasm.rawkinematiccharactercontroller_snapToGroundEnabled(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @param {number} dt\n     * @param {RawBroadPhase} broad_phase\n     * @param {RawNarrowPhase} narrow_phase\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {number} collider_handle\n     * @param {RawVector} desired_translation_delta\n     * @param {boolean} apply_impulses_to_dynamic_bodies\n     * @param {number | null | undefined} character_mass\n     * @param {number} filter_flags\n     * @param {number | null | undefined} filter_groups\n     * @param {Function} filter_predicate\n     */\n    computeColliderMovement(dt, broad_phase, narrow_phase, bodies, colliders, collider_handle, desired_translation_delta, apply_impulses_to_dynamic_bodies, character_mass, filter_flags, filter_groups, filter_predicate) {\n        try {\n            _assertClass(broad_phase, RawBroadPhase);\n            _assertClass(narrow_phase, RawNarrowPhase);\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(desired_translation_delta, RawVector);\n            wasm.rawkinematiccharactercontroller_computeColliderMovement(this.__wbg_ptr, dt, broad_phase.__wbg_ptr, narrow_phase.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, collider_handle, desired_translation_delta.__wbg_ptr, apply_impulses_to_dynamic_bodies, isLikeNone(character_mass) ? 0x100000001 : Math.fround(character_mass), filter_flags, isLikeNone(filter_groups) ? 0x100000001 : (filter_groups) >>> 0, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @returns {RawVector}\n     */\n    computedMovement() {\n        const ret = wasm.rawkinematiccharactercontroller_computedMovement(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {boolean}\n     */\n    computedGrounded() {\n        const ret = wasm.rawkinematiccharactercontroller_computedGrounded(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {number}\n     */\n    numComputedCollisions() {\n        const ret = wasm.rawkinematiccharactercontroller_numComputedCollisions(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} i\n     * @param {RawCharacterCollision} collision\n     * @returns {boolean}\n     */\n    computedCollision(i, collision) {\n        _assertClass(collision, RawCharacterCollision);\n        const ret = wasm.rawkinematiccharactercontroller_computedCollision(this.__wbg_ptr, i, collision.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n\nconst RawMultibodyJointSetFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawmultibodyjointset_free(ptr >>> 0, 1));\n\nexport class RawMultibodyJointSet {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawMultibodyJointSet.prototype);\n        obj.__wbg_ptr = ptr;\n        RawMultibodyJointSetFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawMultibodyJointSetFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawmultibodyjointset_free(ptr, 0);\n    }\n    /**\n     * The type of this joint.\n     * @param {number} handle\n     * @returns {RawJointType}\n     */\n    jointType(handle) {\n        const ret = wasm.rawmultibodyjointset_jointType(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The angular part of the joint’s local frame relative to the first rigid-body it is attached to.\n     * @param {number} handle\n     * @returns {RawRotation}\n     */\n    jointFrameX1(handle) {\n        const ret = wasm.rawmultibodyjointset_jointFrameX1(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n     * The angular part of the joint’s local frame relative to the second rigid-body it is attached to.\n     * @param {number} handle\n     * @returns {RawRotation}\n     */\n    jointFrameX2(handle) {\n        const ret = wasm.rawmultibodyjointset_jointFrameX2(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n     * The position of the first anchor of this joint.\n     *\n     * The first anchor gives the position of the points application point on the\n     * local frame of the first rigid-body it is attached to.\n     * @param {number} handle\n     * @returns {RawVector}\n     */\n    jointAnchor1(handle) {\n        const ret = wasm.rawmultibodyjointset_jointAnchor1(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * The position of the second anchor of this joint.\n     *\n     * The second anchor gives the position of the points application point on the\n     * local frame of the second rigid-body it is attached to.\n     * @param {number} handle\n     * @returns {RawVector}\n     */\n    jointAnchor2(handle) {\n        const ret = wasm.rawmultibodyjointset_jointAnchor2(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * Are contacts between the rigid-bodies attached by this joint enabled?\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    jointContactsEnabled(handle) {\n        const ret = wasm.rawmultibodyjointset_jointContactsEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * Sets whether contacts are enabled between the rigid-bodies attached by this joint.\n     * @param {number} handle\n     * @param {boolean} enabled\n     */\n    jointSetContactsEnabled(handle, enabled) {\n        wasm.rawmultibodyjointset_jointSetContactsEnabled(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n     * Are the limits for this joint enabled?\n     * @param {number} handle\n     * @param {RawJointAxis} axis\n     * @returns {boolean}\n     */\n    jointLimitsEnabled(handle, axis) {\n        const ret = wasm.rawmultibodyjointset_jointLimitsEnabled(this.__wbg_ptr, handle, axis);\n        return ret !== 0;\n    }\n    /**\n     * Return the lower limit along the given joint axis.\n     * @param {number} handle\n     * @param {RawJointAxis} axis\n     * @returns {number}\n     */\n    jointLimitsMin(handle, axis) {\n        const ret = wasm.rawmultibodyjointset_jointLimitsMin(this.__wbg_ptr, handle, axis);\n        return ret;\n    }\n    /**\n     * If this is a prismatic joint, returns its upper limit.\n     * @param {number} handle\n     * @param {RawJointAxis} axis\n     * @returns {number}\n     */\n    jointLimitsMax(handle, axis) {\n        const ret = wasm.rawmultibodyjointset_jointLimitsMax(this.__wbg_ptr, handle, axis);\n        return ret;\n    }\n    constructor() {\n        const ret = wasm.rawmultibodyjointset_new();\n        this.__wbg_ptr = ret >>> 0;\n        RawMultibodyJointSetFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {RawGenericJoint} params\n     * @param {number} parent1\n     * @param {number} parent2\n     * @param {boolean} wakeUp\n     * @returns {number}\n     */\n    createJoint(params, parent1, parent2, wakeUp) {\n        _assertClass(params, RawGenericJoint);\n        const ret = wasm.rawmultibodyjointset_createJoint(this.__wbg_ptr, params.__wbg_ptr, parent1, parent2, wakeUp);\n        return ret;\n    }\n    /**\n     * @param {number} handle\n     * @param {boolean} wakeUp\n     */\n    remove(handle, wakeUp) {\n        wasm.rawmultibodyjointset_remove(this.__wbg_ptr, handle, wakeUp);\n    }\n    /**\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    contains(handle) {\n        const ret = wasm.rawmultibodyjointset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * Applies the given JavaScript function to the integer handle of each joint managed by this physics world.\n     *\n     * # Parameters\n     * - `f(handle)`: the function to apply to the integer handle of each joint managed by this set. Called as `f(collider)`.\n     * @param {Function} f\n     */\n    forEachJointHandle(f) {\n        try {\n            wasm.rawmultibodyjointset_forEachJointHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * Applies the given JavaScript function to the integer handle of each joint attached to the given rigid-body.\n     *\n     * # Parameters\n     * - `f(handle)`: the function to apply to the integer handle of each joint attached to the rigid-body. Called as `f(collider)`.\n     * @param {number} body\n     * @param {Function} f\n     */\n    forEachJointAttachedToRigidBody(body, f) {\n        try {\n            wasm.rawmultibodyjointset_forEachJointAttachedToRigidBody(this.__wbg_ptr, body, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n\nconst RawNarrowPhaseFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawnarrowphase_free(ptr >>> 0, 1));\n\nexport class RawNarrowPhase {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawNarrowPhase.prototype);\n        obj.__wbg_ptr = ptr;\n        RawNarrowPhaseFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawNarrowPhaseFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawnarrowphase_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.rawnarrowphase_new();\n        this.__wbg_ptr = ret >>> 0;\n        RawNarrowPhaseFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {number} handle1\n     * @param {Function} f\n     */\n    contact_pairs_with(handle1, f) {\n        wasm.rawnarrowphase_contact_pairs_with(this.__wbg_ptr, handle1, addHeapObject(f));\n    }\n    /**\n     * @param {number} handle1\n     * @param {number} handle2\n     * @returns {RawContactPair | undefined}\n     */\n    contact_pair(handle1, handle2) {\n        const ret = wasm.rawnarrowphase_contact_pair(this.__wbg_ptr, handle1, handle2);\n        return ret === 0 ? undefined : RawContactPair.__wrap(ret);\n    }\n    /**\n     * @param {number} handle1\n     * @param {Function} f\n     */\n    intersection_pairs_with(handle1, f) {\n        wasm.rawnarrowphase_intersection_pairs_with(this.__wbg_ptr, handle1, addHeapObject(f));\n    }\n    /**\n     * @param {number} handle1\n     * @param {number} handle2\n     * @returns {boolean}\n     */\n    intersection_pair(handle1, handle2) {\n        const ret = wasm.rawnarrowphase_intersection_pair(this.__wbg_ptr, handle1, handle2);\n        return ret !== 0;\n    }\n}\n\nconst RawPhysicsPipelineFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawphysicspipeline_free(ptr >>> 0, 1));\n\nexport class RawPhysicsPipeline {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawPhysicsPipelineFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawphysicspipeline_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.rawphysicspipeline_new();\n        this.__wbg_ptr = ret >>> 0;\n        RawPhysicsPipelineFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {boolean} enabled\n     */\n    set_profiler_enabled(enabled) {\n        wasm.rawphysicspipeline_set_profiler_enabled(this.__wbg_ptr, enabled);\n    }\n    /**\n     * @returns {boolean}\n     */\n    is_profiler_enabled() {\n        const ret = wasm.rawphysicspipeline_is_profiler_enabled(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {number}\n     */\n    timing_step() {\n        const ret = wasm.rawphysicspipeline_timing_step(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    timing_collision_detection() {\n        const ret = wasm.rawphysicspipeline_timing_collision_detection(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    timing_broad_phase() {\n        const ret = wasm.rawphysicspipeline_timing_broad_phase(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    timing_narrow_phase() {\n        const ret = wasm.rawphysicspipeline_timing_narrow_phase(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    timing_solver() {\n        const ret = wasm.rawphysicspipeline_timing_solver(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    timing_velocity_assembly() {\n        const ret = wasm.rawphysicspipeline_timing_velocity_assembly(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    timing_velocity_resolution() {\n        const ret = wasm.rawphysicspipeline_timing_velocity_resolution(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    timing_velocity_update() {\n        const ret = wasm.rawphysicspipeline_timing_velocity_update(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    timing_velocity_writeback() {\n        const ret = wasm.rawphysicspipeline_timing_velocity_writeback(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    timing_ccd() {\n        const ret = wasm.rawphysicspipeline_timing_ccd(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    timing_ccd_toi_computation() {\n        const ret = wasm.rawphysicspipeline_timing_ccd_toi_computation(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    timing_ccd_broad_phase() {\n        const ret = wasm.rawphysicspipeline_timing_ccd_broad_phase(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    timing_ccd_narrow_phase() {\n        const ret = wasm.rawphysicspipeline_timing_ccd_narrow_phase(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    timing_ccd_solver() {\n        const ret = wasm.rawphysicspipeline_timing_ccd_solver(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    timing_island_construction() {\n        const ret = wasm.rawphysicspipeline_timing_island_construction(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    timing_user_changes() {\n        const ret = wasm.rawphysicspipeline_timing_user_changes(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @param {RawVector} gravity\n     * @param {RawIntegrationParameters} integrationParameters\n     * @param {RawIslandManager} islands\n     * @param {RawBroadPhase} broadPhase\n     * @param {RawNarrowPhase} narrowPhase\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawImpulseJointSet} joints\n     * @param {RawMultibodyJointSet} articulations\n     * @param {RawCCDSolver} ccd_solver\n     */\n    step(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, joints, articulations, ccd_solver) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawImpulseJointSet);\n        _assertClass(articulations, RawMultibodyJointSet);\n        _assertClass(ccd_solver, RawCCDSolver);\n        wasm.rawphysicspipeline_step(this.__wbg_ptr, gravity.__wbg_ptr, integrationParameters.__wbg_ptr, islands.__wbg_ptr, broadPhase.__wbg_ptr, narrowPhase.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, joints.__wbg_ptr, articulations.__wbg_ptr, ccd_solver.__wbg_ptr);\n    }\n    /**\n     * @param {RawVector} gravity\n     * @param {RawIntegrationParameters} integrationParameters\n     * @param {RawIslandManager} islands\n     * @param {RawBroadPhase} broadPhase\n     * @param {RawNarrowPhase} narrowPhase\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawImpulseJointSet} joints\n     * @param {RawMultibodyJointSet} articulations\n     * @param {RawCCDSolver} ccd_solver\n     * @param {RawEventQueue} eventQueue\n     * @param {object} hookObject\n     * @param {Function} hookFilterContactPair\n     * @param {Function} hookFilterIntersectionPair\n     */\n    stepWithEvents(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, joints, articulations, ccd_solver, eventQueue, hookObject, hookFilterContactPair, hookFilterIntersectionPair) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawImpulseJointSet);\n        _assertClass(articulations, RawMultibodyJointSet);\n        _assertClass(ccd_solver, RawCCDSolver);\n        _assertClass(eventQueue, RawEventQueue);\n        wasm.rawphysicspipeline_stepWithEvents(this.__wbg_ptr, gravity.__wbg_ptr, integrationParameters.__wbg_ptr, islands.__wbg_ptr, broadPhase.__wbg_ptr, narrowPhase.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, joints.__wbg_ptr, articulations.__wbg_ptr, ccd_solver.__wbg_ptr, eventQueue.__wbg_ptr, addHeapObject(hookObject), addHeapObject(hookFilterContactPair), addHeapObject(hookFilterIntersectionPair));\n    }\n}\n\nconst RawPidControllerFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawpidcontroller_free(ptr >>> 0, 1));\n\nexport class RawPidController {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawPidControllerFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawpidcontroller_free(ptr, 0);\n    }\n    /**\n     * @param {number} kp\n     * @param {number} ki\n     * @param {number} kd\n     * @param {number} axes_mask\n     */\n    constructor(kp, ki, kd, axes_mask) {\n        const ret = wasm.rawpidcontroller_new(kp, ki, kd, axes_mask);\n        this.__wbg_ptr = ret >>> 0;\n        RawPidControllerFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {number} kp\n     * @param {number} axes\n     */\n    set_kp(kp, axes) {\n        wasm.rawpidcontroller_set_kp(this.__wbg_ptr, kp, axes);\n    }\n    /**\n     * @param {number} ki\n     * @param {number} axes\n     */\n    set_ki(ki, axes) {\n        wasm.rawpidcontroller_set_ki(this.__wbg_ptr, ki, axes);\n    }\n    /**\n     * @param {number} kd\n     * @param {number} axes\n     */\n    set_kd(kd, axes) {\n        wasm.rawpidcontroller_set_kd(this.__wbg_ptr, kd, axes);\n    }\n    /**\n     * @param {number} axes_mask\n     */\n    set_axes_mask(axes_mask) {\n        wasm.rawpidcontroller_set_axes_mask(this.__wbg_ptr, axes_mask);\n    }\n    reset_integrals() {\n        wasm.rawpidcontroller_reset_integrals(this.__wbg_ptr);\n    }\n    /**\n     * @param {number} dt\n     * @param {RawRigidBodySet} bodies\n     * @param {number} rb_handle\n     * @param {RawVector} target_translation\n     * @param {RawVector} target_linvel\n     */\n    apply_linear_correction(dt, bodies, rb_handle, target_translation, target_linvel) {\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(target_translation, RawVector);\n        _assertClass(target_linvel, RawVector);\n        wasm.rawpidcontroller_apply_linear_correction(this.__wbg_ptr, dt, bodies.__wbg_ptr, rb_handle, target_translation.__wbg_ptr, target_linvel.__wbg_ptr);\n    }\n    /**\n     * @param {number} dt\n     * @param {RawRigidBodySet} bodies\n     * @param {number} rb_handle\n     * @param {number} target_rotation\n     * @param {number} target_angvel\n     */\n    apply_angular_correction(dt, bodies, rb_handle, target_rotation, target_angvel) {\n        _assertClass(bodies, RawRigidBodySet);\n        wasm.rawpidcontroller_apply_angular_correction(this.__wbg_ptr, dt, bodies.__wbg_ptr, rb_handle, target_rotation, target_angvel);\n    }\n    /**\n     * @param {number} dt\n     * @param {RawRigidBodySet} bodies\n     * @param {number} rb_handle\n     * @param {RawVector} target_translation\n     * @param {RawVector} target_linvel\n     * @returns {RawVector}\n     */\n    linear_correction(dt, bodies, rb_handle, target_translation, target_linvel) {\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(target_translation, RawVector);\n        _assertClass(target_linvel, RawVector);\n        const ret = wasm.rawpidcontroller_linear_correction(this.__wbg_ptr, dt, bodies.__wbg_ptr, rb_handle, target_translation.__wbg_ptr, target_linvel.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @param {number} dt\n     * @param {RawRigidBodySet} bodies\n     * @param {number} rb_handle\n     * @param {number} target_rotation\n     * @param {number} target_angvel\n     * @returns {number}\n     */\n    angular_correction(dt, bodies, rb_handle, target_rotation, target_angvel) {\n        _assertClass(bodies, RawRigidBodySet);\n        const ret = wasm.rawpidcontroller_angular_correction(this.__wbg_ptr, dt, bodies.__wbg_ptr, rb_handle, target_rotation, target_angvel);\n        return ret;\n    }\n}\n\nconst RawPointColliderProjectionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawpointcolliderprojection_free(ptr >>> 0, 1));\n\nexport class RawPointColliderProjection {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawPointColliderProjection.prototype);\n        obj.__wbg_ptr = ptr;\n        RawPointColliderProjectionFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawPointColliderProjectionFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawpointcolliderprojection_free(ptr, 0);\n    }\n    /**\n     * @returns {number}\n     */\n    colliderHandle() {\n        const ret = wasm.rawpointcolliderprojection_colliderHandle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {RawVector}\n     */\n    point() {\n        const ret = wasm.rawpointcolliderprojection_point(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {boolean}\n     */\n    isInside() {\n        const ret = wasm.rawpointcolliderprojection_isInside(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {RawFeatureType}\n     */\n    featureType() {\n        const ret = wasm.rawpointcolliderprojection_featureType(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number | undefined}\n     */\n    featureId() {\n        const ret = wasm.rawpointcolliderprojection_featureId(this.__wbg_ptr);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n}\n\nconst RawPointProjectionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawpointprojection_free(ptr >>> 0, 1));\n\nexport class RawPointProjection {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawPointProjection.prototype);\n        obj.__wbg_ptr = ptr;\n        RawPointProjectionFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawPointProjectionFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawpointprojection_free(ptr, 0);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    point() {\n        const ret = wasm.rawpointprojection_point(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {boolean}\n     */\n    isInside() {\n        const ret = wasm.rawpointprojection_isInside(this.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n\nconst RawRayColliderHitFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawraycolliderhit_free(ptr >>> 0, 1));\n\nexport class RawRayColliderHit {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRayColliderHit.prototype);\n        obj.__wbg_ptr = ptr;\n        RawRayColliderHitFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawRayColliderHitFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawraycolliderhit_free(ptr, 0);\n    }\n    /**\n     * @returns {number}\n     */\n    colliderHandle() {\n        const ret = wasm.rawcollidershapecasthit_colliderHandle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    timeOfImpact() {\n        const ret = wasm.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);\n        return ret;\n    }\n}\n\nconst RawRayColliderIntersectionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawraycolliderintersection_free(ptr >>> 0, 1));\n\nexport class RawRayColliderIntersection {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRayColliderIntersection.prototype);\n        obj.__wbg_ptr = ptr;\n        RawRayColliderIntersectionFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawRayColliderIntersectionFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawraycolliderintersection_free(ptr, 0);\n    }\n    /**\n     * @returns {number}\n     */\n    colliderHandle() {\n        const ret = wasm.rawpointcolliderprojection_colliderHandle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {RawVector}\n     */\n    normal() {\n        const ret = wasm.rawcollidershapecasthit_witness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    time_of_impact() {\n        const ret = wasm.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {RawFeatureType}\n     */\n    featureType() {\n        const ret = wasm.rawpointcolliderprojection_featureType(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number | undefined}\n     */\n    featureId() {\n        const ret = wasm.rawpointcolliderprojection_featureId(this.__wbg_ptr);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n}\n\nconst RawRayIntersectionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawrayintersection_free(ptr >>> 0, 1));\n\nexport class RawRayIntersection {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRayIntersection.prototype);\n        obj.__wbg_ptr = ptr;\n        RawRayIntersectionFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawRayIntersectionFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawrayintersection_free(ptr, 0);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    normal() {\n        const ret = wasm.rawcollidershapecasthit_witness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    time_of_impact() {\n        const ret = wasm.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {RawFeatureType}\n     */\n    featureType() {\n        const ret = wasm.rawpointcolliderprojection_featureType(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number | undefined}\n     */\n    featureId() {\n        const ret = wasm.rawpointcolliderprojection_featureId(this.__wbg_ptr);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n}\n\nconst RawRigidBodySetFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawrigidbodyset_free(ptr >>> 0, 1));\n\nexport class RawRigidBodySet {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRigidBodySet.prototype);\n        obj.__wbg_ptr = ptr;\n        RawRigidBodySetFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawRigidBodySetFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawrigidbodyset_free(ptr, 0);\n    }\n    /**\n     * The world-space translation of this rigid-body.\n     * @param {number} handle\n     * @returns {RawVector}\n     */\n    rbTranslation(handle) {\n        const ret = wasm.rawrigidbodyset_rbTranslation(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * The world-space orientation of this rigid-body.\n     * @param {number} handle\n     * @returns {RawRotation}\n     */\n    rbRotation(handle) {\n        const ret = wasm.rawrigidbodyset_rbRotation(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n     * Put the given rigid-body to sleep.\n     * @param {number} handle\n     */\n    rbSleep(handle) {\n        wasm.rawrigidbodyset_rbSleep(this.__wbg_ptr, handle);\n    }\n    /**\n     * Is this rigid-body sleeping?\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    rbIsSleeping(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsSleeping(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * Is the velocity of this rigid-body not zero?\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    rbIsMoving(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsMoving(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * The world-space predicted translation of this rigid-body.\n     *\n     * If this rigid-body is kinematic this value is set by the `setNextKinematicTranslation`\n     * method and is used for estimating the kinematic body velocity at the next timestep.\n     * For non-kinematic bodies, this value is currently unspecified.\n     * @param {number} handle\n     * @returns {RawVector}\n     */\n    rbNextTranslation(handle) {\n        const ret = wasm.rawrigidbodyset_rbNextTranslation(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * The world-space predicted orientation of this rigid-body.\n     *\n     * If this rigid-body is kinematic this value is set by the `setNextKinematicRotation`\n     * method and is used for estimating the kinematic body velocity at the next timestep.\n     * For non-kinematic bodies, this value is currently unspecified.\n     * @param {number} handle\n     * @returns {RawRotation}\n     */\n    rbNextRotation(handle) {\n        const ret = wasm.rawrigidbodyset_rbNextRotation(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n     * Sets the translation of this rigid-body.\n     *\n     * # Parameters\n     * - `x`: the world-space position of the rigid-body along the `x` axis.\n     * - `y`: the world-space position of the rigid-body along the `y` axis.\n     * - `wakeUp`: forces the rigid-body to wake-up so it is properly affected by forces if it\n     * wasn't moving before modifying its position.\n     * @param {number} handle\n     * @param {number} x\n     * @param {number} y\n     * @param {boolean} wakeUp\n     */\n    rbSetTranslation(handle, x, y, wakeUp) {\n        wasm.rawrigidbodyset_rbSetTranslation(this.__wbg_ptr, handle, x, y, wakeUp);\n    }\n    /**\n     * Sets the rotation angle of this rigid-body.\n     *\n     * # Parameters\n     * - `angle`: the rotation angle, in radians.\n     * - `wakeUp`: forces the rigid-body to wake-up so it is properly affected by forces if it\n     * wasn't moving before modifying its position.\n     * @param {number} handle\n     * @param {number} angle\n     * @param {boolean} wakeUp\n     */\n    rbSetRotation(handle, angle, wakeUp) {\n        wasm.rawrigidbodyset_rbSetRotation(this.__wbg_ptr, handle, angle, wakeUp);\n    }\n    /**\n     * Sets the linear velocity of this rigid-body.\n     * @param {number} handle\n     * @param {RawVector} linvel\n     * @param {boolean} wakeUp\n     */\n    rbSetLinvel(handle, linvel, wakeUp) {\n        _assertClass(linvel, RawVector);\n        wasm.rawrigidbodyset_rbSetLinvel(this.__wbg_ptr, handle, linvel.__wbg_ptr, wakeUp);\n    }\n    /**\n     * Sets the angular velocity of this rigid-body.\n     * @param {number} handle\n     * @param {number} angvel\n     * @param {boolean} wakeUp\n     */\n    rbSetAngvel(handle, angvel, wakeUp) {\n        wasm.rawrigidbodyset_rbSetAngvel(this.__wbg_ptr, handle, angvel, wakeUp);\n    }\n    /**\n     * If this rigid body is kinematic, sets its future translation after the next timestep integration.\n     *\n     * This should be used instead of `rigidBody.setTranslation` to make the dynamic object\n     * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n     * an artificial velocity for this rigid-body from its current position and its next kinematic\n     * position. This velocity will be used to compute forces on dynamic bodies interacting with\n     * this body.\n     *\n     * # Parameters\n     * - `x`: the world-space position of the rigid-body along the `x` axis.\n     * - `y`: the world-space position of the rigid-body along the `y` axis.\n     * @param {number} handle\n     * @param {number} x\n     * @param {number} y\n     */\n    rbSetNextKinematicTranslation(handle, x, y) {\n        wasm.rawrigidbodyset_rbSetNextKinematicTranslation(this.__wbg_ptr, handle, x, y);\n    }\n    /**\n     * If this rigid body is kinematic, sets its future rotation after the next timestep integration.\n     *\n     * This should be used instead of `rigidBody.setRotation` to make the dynamic object\n     * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n     * an artificial velocity for this rigid-body from its current position and its next kinematic\n     * position. This velocity will be used to compute forces on dynamic bodies interacting with\n     * this body.\n     *\n     * # Parameters\n     * - `angle`: the rotation angle, in radians.\n     * @param {number} handle\n     * @param {number} angle\n     */\n    rbSetNextKinematicRotation(handle, angle) {\n        wasm.rawrigidbodyset_rbSetNextKinematicRotation(this.__wbg_ptr, handle, angle);\n    }\n    /**\n     * @param {number} handle\n     * @param {RawColliderSet} colliders\n     */\n    rbRecomputeMassPropertiesFromColliders(handle, colliders) {\n        _assertClass(colliders, RawColliderSet);\n        wasm.rawrigidbodyset_rbRecomputeMassPropertiesFromColliders(this.__wbg_ptr, handle, colliders.__wbg_ptr);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} mass\n     * @param {boolean} wake_up\n     */\n    rbSetAdditionalMass(handle, mass, wake_up) {\n        wasm.rawrigidbodyset_rbSetAdditionalMass(this.__wbg_ptr, handle, mass, wake_up);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} mass\n     * @param {RawVector} centerOfMass\n     * @param {number} principalAngularInertia\n     * @param {boolean} wake_up\n     */\n    rbSetAdditionalMassProperties(handle, mass, centerOfMass, principalAngularInertia, wake_up) {\n        _assertClass(centerOfMass, RawVector);\n        wasm.rawrigidbodyset_rbSetAdditionalMassProperties(this.__wbg_ptr, handle, mass, centerOfMass.__wbg_ptr, principalAngularInertia, wake_up);\n    }\n    /**\n     * The linear velocity of this rigid-body.\n     * @param {number} handle\n     * @returns {RawVector}\n     */\n    rbLinvel(handle) {\n        const ret = wasm.rawrigidbodyset_rbLinvel(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * The angular velocity of this rigid-body.\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbAngvel(handle) {\n        const ret = wasm.rawrigidbodyset_rbAngvel(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The velocity of the given world-space point on this rigid-body.\n     * @param {number} handle\n     * @param {RawVector} point\n     * @returns {RawVector}\n     */\n    rbVelocityAtPoint(handle, point) {\n        _assertClass(point, RawVector);\n        const ret = wasm.rawrigidbodyset_rbVelocityAtPoint(this.__wbg_ptr, handle, point.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @param {number} handle\n     * @param {boolean} locked\n     * @param {boolean} wake_up\n     */\n    rbLockTranslations(handle, locked, wake_up) {\n        wasm.rawrigidbodyset_rbLockTranslations(this.__wbg_ptr, handle, locked, wake_up);\n    }\n    /**\n     * @param {number} handle\n     * @param {boolean} allow_x\n     * @param {boolean} allow_y\n     * @param {boolean} wake_up\n     */\n    rbSetEnabledTranslations(handle, allow_x, allow_y, wake_up) {\n        wasm.rawrigidbodyset_rbSetEnabledTranslations(this.__wbg_ptr, handle, allow_x, allow_y, wake_up);\n    }\n    /**\n     * @param {number} handle\n     * @param {boolean} locked\n     * @param {boolean} wake_up\n     */\n    rbLockRotations(handle, locked, wake_up) {\n        wasm.rawrigidbodyset_rbLockRotations(this.__wbg_ptr, handle, locked, wake_up);\n    }\n    /**\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbDominanceGroup(handle) {\n        const ret = wasm.rawrigidbodyset_rbDominanceGroup(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * @param {number} handle\n     * @param {number} group\n     */\n    rbSetDominanceGroup(handle, group) {\n        wasm.rawrigidbodyset_rbSetDominanceGroup(this.__wbg_ptr, handle, group);\n    }\n    /**\n     * @param {number} handle\n     * @param {boolean} enabled\n     */\n    rbEnableCcd(handle, enabled) {\n        wasm.rawrigidbodyset_rbEnableCcd(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} prediction\n     */\n    rbSetSoftCcdPrediction(handle, prediction) {\n        wasm.rawrigidbodyset_rbSetSoftCcdPrediction(this.__wbg_ptr, handle, prediction);\n    }\n    /**\n     * The mass of this rigid-body.\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbMass(handle) {\n        const ret = wasm.rawrigidbodyset_rbMass(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The inverse of the mass of a rigid-body.\n     *\n     * If this is zero, the rigid-body is assumed to have infinite mass.\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbInvMass(handle) {\n        const ret = wasm.rawrigidbodyset_rbInvMass(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The inverse mass taking into account translation locking.\n     * @param {number} handle\n     * @returns {RawVector}\n     */\n    rbEffectiveInvMass(handle) {\n        const ret = wasm.rawrigidbodyset_rbEffectiveInvMass(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * The center of mass of a rigid-body expressed in its local-space.\n     * @param {number} handle\n     * @returns {RawVector}\n     */\n    rbLocalCom(handle) {\n        const ret = wasm.rawrigidbodyset_rbLocalCom(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * The world-space center of mass of the rigid-body.\n     * @param {number} handle\n     * @returns {RawVector}\n     */\n    rbWorldCom(handle) {\n        const ret = wasm.rawrigidbodyset_rbWorldCom(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * The inverse of the principal angular inertia of the rigid-body.\n     *\n     * Components set to zero are assumed to be infinite along the corresponding principal axis.\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbInvPrincipalInertiaSqrt(handle) {\n        const ret = wasm.rawrigidbodyset_rbInvPrincipalInertiaSqrt(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The angular inertia along the principal inertia axes of the rigid-body.\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbPrincipalInertia(handle) {\n        const ret = wasm.rawrigidbodyset_rbPrincipalInertia(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The square-root of the world-space inverse angular inertia tensor of the rigid-body,\n     * taking into account rotation locking.\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbEffectiveWorldInvInertiaSqrt(handle) {\n        const ret = wasm.rawrigidbodyset_rbEffectiveWorldInvInertiaSqrt(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The effective world-space angular inertia (that takes the potential rotation locking into account) of\n     * this rigid-body.\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbEffectiveAngularInertia(handle) {\n        const ret = wasm.rawrigidbodyset_rbEffectiveAngularInertia(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * Wakes this rigid-body up.\n     *\n     * A dynamic rigid-body that does not move during several consecutive frames will\n     * be put to sleep by the physics engine, i.e., it will stop being simulated in order\n     * to avoid useless computations.\n     * This method forces a sleeping rigid-body to wake-up. This is useful, e.g., before modifying\n     * the position of a dynamic body so that it is properly simulated afterwards.\n     * @param {number} handle\n     */\n    rbWakeUp(handle) {\n        wasm.rawrigidbodyset_rbWakeUp(this.__wbg_ptr, handle);\n    }\n    /**\n     * Is Continuous Collision Detection enabled for this rigid-body?\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    rbIsCcdEnabled(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsCcdEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbSoftCcdPrediction(handle) {\n        const ret = wasm.rawrigidbodyset_rbSoftCcdPrediction(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The number of colliders attached to this rigid-body.\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbNumColliders(handle) {\n        const ret = wasm.rawrigidbodyset_rbNumColliders(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n     * Retrieves the `i-th` collider attached to this rigid-body.\n     *\n     * # Parameters\n     * - `at`: The index of the collider to retrieve. Must be a number in `[0, this.numColliders()[`.\n     *         This index is **not** the same as the unique identifier of the collider.\n     * @param {number} handle\n     * @param {number} at\n     * @returns {number}\n     */\n    rbCollider(handle, at) {\n        const ret = wasm.rawrigidbodyset_rbCollider(this.__wbg_ptr, handle, at);\n        return ret;\n    }\n    /**\n     * The status of this rigid-body: fixed, dynamic, or kinematic.\n     * @param {number} handle\n     * @returns {RawRigidBodyType}\n     */\n    rbBodyType(handle) {\n        const ret = wasm.rawrigidbodyset_rbBodyType(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * Set a new status for this rigid-body: fixed, dynamic, or kinematic.\n     * @param {number} handle\n     * @param {RawRigidBodyType} status\n     * @param {boolean} wake_up\n     */\n    rbSetBodyType(handle, status, wake_up) {\n        wasm.rawrigidbodyset_rbSetBodyType(this.__wbg_ptr, handle, status, wake_up);\n    }\n    /**\n     * Is this rigid-body fixed?\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    rbIsFixed(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsFixed(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * Is this rigid-body kinematic?\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    rbIsKinematic(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsKinematic(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * Is this rigid-body dynamic?\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    rbIsDynamic(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsDynamic(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * The linear damping coefficient of this rigid-body.\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbLinearDamping(handle) {\n        const ret = wasm.rawrigidbodyset_rbLinearDamping(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The angular damping coefficient of this rigid-body.\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbAngularDamping(handle) {\n        const ret = wasm.rawrigidbodyset_rbAngularDamping(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * @param {number} handle\n     * @param {number} factor\n     */\n    rbSetLinearDamping(handle, factor) {\n        wasm.rawrigidbodyset_rbSetLinearDamping(this.__wbg_ptr, handle, factor);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} factor\n     */\n    rbSetAngularDamping(handle, factor) {\n        wasm.rawrigidbodyset_rbSetAngularDamping(this.__wbg_ptr, handle, factor);\n    }\n    /**\n     * @param {number} handle\n     * @param {boolean} enabled\n     */\n    rbSetEnabled(handle, enabled) {\n        wasm.rawrigidbodyset_rbSetEnabled(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    rbIsEnabled(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbGravityScale(handle) {\n        const ret = wasm.rawrigidbodyset_rbGravityScale(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * @param {number} handle\n     * @param {number} factor\n     * @param {boolean} wakeUp\n     */\n    rbSetGravityScale(handle, factor, wakeUp) {\n        wasm.rawrigidbodyset_rbSetGravityScale(this.__wbg_ptr, handle, factor, wakeUp);\n    }\n    /**\n     * Resets to zero all user-added forces added to this rigid-body.\n     * @param {number} handle\n     * @param {boolean} wakeUp\n     */\n    rbResetForces(handle, wakeUp) {\n        wasm.rawrigidbodyset_rbResetForces(this.__wbg_ptr, handle, wakeUp);\n    }\n    /**\n     * Resets to zero all user-added torques added to this rigid-body.\n     * @param {number} handle\n     * @param {boolean} wakeUp\n     */\n    rbResetTorques(handle, wakeUp) {\n        wasm.rawrigidbodyset_rbResetTorques(this.__wbg_ptr, handle, wakeUp);\n    }\n    /**\n     * Adds a force at the center-of-mass of this rigid-body.\n     *\n     * # Parameters\n     * - `force`: the world-space force to apply on the rigid-body.\n     * - `wakeUp`: should the rigid-body be automatically woken-up?\n     * @param {number} handle\n     * @param {RawVector} force\n     * @param {boolean} wakeUp\n     */\n    rbAddForce(handle, force, wakeUp) {\n        _assertClass(force, RawVector);\n        wasm.rawrigidbodyset_rbAddForce(this.__wbg_ptr, handle, force.__wbg_ptr, wakeUp);\n    }\n    /**\n     * Applies an impulse at the center-of-mass of this rigid-body.\n     *\n     * # Parameters\n     * - `impulse`: the world-space impulse to apply on the rigid-body.\n     * - `wakeUp`: should the rigid-body be automatically woken-up?\n     * @param {number} handle\n     * @param {RawVector} impulse\n     * @param {boolean} wakeUp\n     */\n    rbApplyImpulse(handle, impulse, wakeUp) {\n        _assertClass(impulse, RawVector);\n        wasm.rawrigidbodyset_rbApplyImpulse(this.__wbg_ptr, handle, impulse.__wbg_ptr, wakeUp);\n    }\n    /**\n     * Adds a torque at the center-of-mass of this rigid-body.\n     *\n     * # Parameters\n     * - `torque`: the torque to apply on the rigid-body.\n     * - `wakeUp`: should the rigid-body be automatically woken-up?\n     * @param {number} handle\n     * @param {number} torque\n     * @param {boolean} wakeUp\n     */\n    rbAddTorque(handle, torque, wakeUp) {\n        wasm.rawrigidbodyset_rbAddTorque(this.__wbg_ptr, handle, torque, wakeUp);\n    }\n    /**\n     * Applies an impulsive torque at the center-of-mass of this rigid-body.\n     *\n     * # Parameters\n     * - `torque impulse`: the torque impulse to apply on the rigid-body.\n     * - `wakeUp`: should the rigid-body be automatically woken-up?\n     * @param {number} handle\n     * @param {number} torque_impulse\n     * @param {boolean} wakeUp\n     */\n    rbApplyTorqueImpulse(handle, torque_impulse, wakeUp) {\n        wasm.rawrigidbodyset_rbApplyTorqueImpulse(this.__wbg_ptr, handle, torque_impulse, wakeUp);\n    }\n    /**\n     * Adds a force at the given world-space point of this rigid-body.\n     *\n     * # Parameters\n     * - `force`: the world-space force to apply on the rigid-body.\n     * - `point`: the world-space point where the impulse is to be applied on the rigid-body.\n     * - `wakeUp`: should the rigid-body be automatically woken-up?\n     * @param {number} handle\n     * @param {RawVector} force\n     * @param {RawVector} point\n     * @param {boolean} wakeUp\n     */\n    rbAddForceAtPoint(handle, force, point, wakeUp) {\n        _assertClass(force, RawVector);\n        _assertClass(point, RawVector);\n        wasm.rawrigidbodyset_rbAddForceAtPoint(this.__wbg_ptr, handle, force.__wbg_ptr, point.__wbg_ptr, wakeUp);\n    }\n    /**\n     * Applies an impulse at the given world-space point of this rigid-body.\n     *\n     * # Parameters\n     * - `impulse`: the world-space impulse to apply on the rigid-body.\n     * - `point`: the world-space point where the impulse is to be applied on the rigid-body.\n     * - `wakeUp`: should the rigid-body be automatically woken-up?\n     * @param {number} handle\n     * @param {RawVector} impulse\n     * @param {RawVector} point\n     * @param {boolean} wakeUp\n     */\n    rbApplyImpulseAtPoint(handle, impulse, point, wakeUp) {\n        _assertClass(impulse, RawVector);\n        _assertClass(point, RawVector);\n        wasm.rawrigidbodyset_rbApplyImpulseAtPoint(this.__wbg_ptr, handle, impulse.__wbg_ptr, point.__wbg_ptr, wakeUp);\n    }\n    /**\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbAdditionalSolverIterations(handle) {\n        const ret = wasm.rawrigidbodyset_rbAdditionalSolverIterations(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} handle\n     * @param {number} iters\n     */\n    rbSetAdditionalSolverIterations(handle, iters) {\n        wasm.rawrigidbodyset_rbSetAdditionalSolverIterations(this.__wbg_ptr, handle, iters);\n    }\n    /**\n     * An arbitrary user-defined 32-bit integer\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbUserData(handle) {\n        const ret = wasm.rawrigidbodyset_rbUserData(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n     * Sets the user-defined 32-bit integer of this rigid-body.\n     *\n     * # Parameters\n     * - `data`: an arbitrary user-defined 32-bit integer.\n     * @param {number} handle\n     * @param {number} data\n     */\n    rbSetUserData(handle, data) {\n        wasm.rawrigidbodyset_rbSetUserData(this.__wbg_ptr, handle, data);\n    }\n    /**\n     * Retrieves the constant force(s) the user added to this rigid-body.\n     * Returns zero if the rigid-body is not dynamic.\n     * @param {number} handle\n     * @returns {RawVector}\n     */\n    rbUserForce(handle) {\n        const ret = wasm.rawrigidbodyset_rbUserForce(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * Retrieves the constant torque(s) the user added to this rigid-body.\n     * Returns zero if the rigid-body is not dynamic.\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbUserTorque(handle) {\n        const ret = wasm.rawrigidbodyset_rbUserTorque(this.__wbg_ptr, handle);\n        return ret;\n    }\n    constructor() {\n        const ret = wasm.rawrigidbodyset_new();\n        this.__wbg_ptr = ret >>> 0;\n        RawRigidBodySetFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {boolean} enabled\n     * @param {RawVector} translation\n     * @param {RawRotation} rotation\n     * @param {number} gravityScale\n     * @param {number} mass\n     * @param {boolean} massOnly\n     * @param {RawVector} centerOfMass\n     * @param {RawVector} linvel\n     * @param {number} angvel\n     * @param {number} principalAngularInertia\n     * @param {boolean} translationEnabledX\n     * @param {boolean} translationEnabledY\n     * @param {boolean} rotationsEnabled\n     * @param {number} linearDamping\n     * @param {number} angularDamping\n     * @param {RawRigidBodyType} rb_type\n     * @param {boolean} canSleep\n     * @param {boolean} sleeping\n     * @param {number} softCcdPrediciton\n     * @param {boolean} ccdEnabled\n     * @param {number} dominanceGroup\n     * @param {number} additional_solver_iterations\n     * @returns {number}\n     */\n    createRigidBody(enabled, translation, rotation, gravityScale, mass, massOnly, centerOfMass, linvel, angvel, principalAngularInertia, translationEnabledX, translationEnabledY, rotationsEnabled, linearDamping, angularDamping, rb_type, canSleep, sleeping, softCcdPrediciton, ccdEnabled, dominanceGroup, additional_solver_iterations) {\n        _assertClass(translation, RawVector);\n        _assertClass(rotation, RawRotation);\n        _assertClass(centerOfMass, RawVector);\n        _assertClass(linvel, RawVector);\n        const ret = wasm.rawrigidbodyset_createRigidBody(this.__wbg_ptr, enabled, translation.__wbg_ptr, rotation.__wbg_ptr, gravityScale, mass, massOnly, centerOfMass.__wbg_ptr, linvel.__wbg_ptr, angvel, principalAngularInertia, translationEnabledX, translationEnabledY, rotationsEnabled, linearDamping, angularDamping, rb_type, canSleep, sleeping, softCcdPrediciton, ccdEnabled, dominanceGroup, additional_solver_iterations);\n        return ret;\n    }\n    /**\n     * @param {number} handle\n     * @param {RawIslandManager} islands\n     * @param {RawColliderSet} colliders\n     * @param {RawImpulseJointSet} joints\n     * @param {RawMultibodyJointSet} articulations\n     */\n    remove(handle, islands, colliders, joints, articulations) {\n        _assertClass(islands, RawIslandManager);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawImpulseJointSet);\n        _assertClass(articulations, RawMultibodyJointSet);\n        wasm.rawrigidbodyset_remove(this.__wbg_ptr, handle, islands.__wbg_ptr, colliders.__wbg_ptr, joints.__wbg_ptr, articulations.__wbg_ptr);\n    }\n    /**\n     * The number of rigid-bodies on this set.\n     * @returns {number}\n     */\n    len() {\n        const ret = wasm.rawcolliderset_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * Checks if a rigid-body with the given integer handle exists.\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    contains(handle) {\n        const ret = wasm.rawrigidbodyset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * Applies the given JavaScript function to the integer handle of each rigid-body managed by this set.\n     *\n     * # Parameters\n     * - `f(handle)`: the function to apply to the integer handle of each rigid-body managed by this set. Called as `f(collider)`.\n     * @param {Function} f\n     */\n    forEachRigidBodyHandle(f) {\n        try {\n            wasm.rawrigidbodyset_forEachRigidBodyHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @param {RawColliderSet} colliders\n     */\n    propagateModifiedBodyPositionsToColliders(colliders) {\n        _assertClass(colliders, RawColliderSet);\n        wasm.rawrigidbodyset_propagateModifiedBodyPositionsToColliders(this.__wbg_ptr, colliders.__wbg_ptr);\n    }\n}\n\nconst RawRotationFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawrotation_free(ptr >>> 0, 1));\n/**\n * A rotation quaternion.\n */\nexport class RawRotation {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRotation.prototype);\n        obj.__wbg_ptr = ptr;\n        RawRotationFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawRotationFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawrotation_free(ptr, 0);\n    }\n    /**\n     * The identity rotation.\n     * @returns {RawRotation}\n     */\n    static identity() {\n        const ret = wasm.rawrotation_identity();\n        return RawRotation.__wrap(ret);\n    }\n    /**\n     * The rotation with thegiven angle.\n     * @param {number} angle\n     * @returns {RawRotation}\n     */\n    static fromAngle(angle) {\n        const ret = wasm.rawrotation_fromAngle(angle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n     * The imaginary part of this complex number.\n     * @returns {number}\n     */\n    get im() {\n        const ret = wasm.rawintegrationparameters_dt(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The real part of this complex number.\n     * @returns {number}\n     */\n    get re() {\n        const ret = wasm.rawrotation_re(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The rotation angle in radians.\n     * @returns {number}\n     */\n    get angle() {\n        const ret = wasm.rawrotation_angle(this.__wbg_ptr);\n        return ret;\n    }\n}\n\nconst RawSerializationPipelineFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawserializationpipeline_free(ptr >>> 0, 1));\n\nexport class RawSerializationPipeline {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawSerializationPipelineFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawserializationpipeline_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.rawccdsolver_new();\n        this.__wbg_ptr = ret >>> 0;\n        RawSerializationPipelineFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {RawVector} gravity\n     * @param {RawIntegrationParameters} integrationParameters\n     * @param {RawIslandManager} islands\n     * @param {RawBroadPhase} broadPhase\n     * @param {RawNarrowPhase} narrowPhase\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawImpulseJointSet} impulse_joints\n     * @param {RawMultibodyJointSet} multibody_joints\n     * @returns {Uint8Array | undefined}\n     */\n    serializeAll(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, impulse_joints, multibody_joints) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(impulse_joints, RawImpulseJointSet);\n        _assertClass(multibody_joints, RawMultibodyJointSet);\n        const ret = wasm.rawserializationpipeline_serializeAll(this.__wbg_ptr, gravity.__wbg_ptr, integrationParameters.__wbg_ptr, islands.__wbg_ptr, broadPhase.__wbg_ptr, narrowPhase.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, impulse_joints.__wbg_ptr, multibody_joints.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} data\n     * @returns {RawDeserializedWorld | undefined}\n     */\n    deserializeAll(data) {\n        const ret = wasm.rawserializationpipeline_deserializeAll(this.__wbg_ptr, addHeapObject(data));\n        return ret === 0 ? undefined : RawDeserializedWorld.__wrap(ret);\n    }\n}\n\nconst RawShapeFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawshape_free(ptr >>> 0, 1));\n\nexport class RawShape {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawShape.prototype);\n        obj.__wbg_ptr = ptr;\n        RawShapeFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawShapeFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshape_free(ptr, 0);\n    }\n    /**\n     * @param {number} hx\n     * @param {number} hy\n     * @returns {RawShape}\n     */\n    static cuboid(hx, hy) {\n        const ret = wasm.rawshape_cuboid(hx, hy);\n        return RawShape.__wrap(ret);\n    }\n    /**\n     * @param {number} hx\n     * @param {number} hy\n     * @param {number} borderRadius\n     * @returns {RawShape}\n     */\n    static roundCuboid(hx, hy, borderRadius) {\n        const ret = wasm.rawshape_roundCuboid(hx, hy, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n     * @param {number} radius\n     * @returns {RawShape}\n     */\n    static ball(radius) {\n        const ret = wasm.rawshape_ball(radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n     * @param {RawVector} normal\n     * @returns {RawShape}\n     */\n    static halfspace(normal) {\n        _assertClass(normal, RawVector);\n        const ret = wasm.rawshape_halfspace(normal.__wbg_ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n     * @param {number} halfHeight\n     * @param {number} radius\n     * @returns {RawShape}\n     */\n    static capsule(halfHeight, radius) {\n        const ret = wasm.rawshape_capsule(halfHeight, radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n     * @param {RawVector} voxel_size\n     * @param {Int32Array} grid_coords\n     * @returns {RawShape}\n     */\n    static voxels(voxel_size, grid_coords) {\n        _assertClass(voxel_size, RawVector);\n        const ptr0 = passArray32ToWasm0(grid_coords, wasm.__wbindgen_export_2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_voxels(voxel_size.__wbg_ptr, ptr0, len0);\n        return RawShape.__wrap(ret);\n    }\n    /**\n     * @param {RawVector} voxel_size\n     * @param {Float32Array} points\n     * @returns {RawShape}\n     */\n    static voxelsFromPoints(voxel_size, points) {\n        _assertClass(voxel_size, RawVector);\n        const ptr0 = passArrayF32ToWasm0(points, wasm.__wbindgen_export_2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_voxelsFromPoints(voxel_size.__wbg_ptr, ptr0, len0);\n        return RawShape.__wrap(ret);\n    }\n    /**\n     * @param {Float32Array} vertices\n     * @param {Uint32Array} indices\n     * @returns {RawShape}\n     */\n    static polyline(vertices, indices) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_export_2);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_export_2);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_polyline(ptr0, len0, ptr1, len1);\n        return RawShape.__wrap(ret);\n    }\n    /**\n     * @param {Float32Array} vertices\n     * @param {Uint32Array} indices\n     * @param {number} flags\n     * @returns {RawShape | undefined}\n     */\n    static trimesh(vertices, indices, flags) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_export_2);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_export_2);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_trimesh(ptr0, len0, ptr1, len1, flags);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n     * @param {Float32Array} heights\n     * @param {RawVector} scale\n     * @returns {RawShape}\n     */\n    static heightfield(heights, scale) {\n        const ptr0 = passArrayF32ToWasm0(heights, wasm.__wbindgen_export_2);\n        const len0 = WASM_VECTOR_LEN;\n        _assertClass(scale, RawVector);\n        const ret = wasm.rawshape_heightfield(ptr0, len0, scale.__wbg_ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n     * @param {RawVector} p1\n     * @param {RawVector} p2\n     * @returns {RawShape}\n     */\n    static segment(p1, p2) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        const ret = wasm.rawshape_segment(p1.__wbg_ptr, p2.__wbg_ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n     * @param {RawVector} p1\n     * @param {RawVector} p2\n     * @param {RawVector} p3\n     * @returns {RawShape}\n     */\n    static triangle(p1, p2, p3) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        _assertClass(p3, RawVector);\n        const ret = wasm.rawshape_triangle(p1.__wbg_ptr, p2.__wbg_ptr, p3.__wbg_ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n     * @param {RawVector} p1\n     * @param {RawVector} p2\n     * @param {RawVector} p3\n     * @param {number} borderRadius\n     * @returns {RawShape}\n     */\n    static roundTriangle(p1, p2, p3, borderRadius) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        _assertClass(p3, RawVector);\n        const ret = wasm.rawshape_roundTriangle(p1.__wbg_ptr, p2.__wbg_ptr, p3.__wbg_ptr, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n     * @param {Float32Array} points\n     * @returns {RawShape | undefined}\n     */\n    static convexHull(points) {\n        const ptr0 = passArrayF32ToWasm0(points, wasm.__wbindgen_export_2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_convexHull(ptr0, len0);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n     * @param {Float32Array} points\n     * @param {number} borderRadius\n     * @returns {RawShape | undefined}\n     */\n    static roundConvexHull(points, borderRadius) {\n        const ptr0 = passArrayF32ToWasm0(points, wasm.__wbindgen_export_2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_roundConvexHull(ptr0, len0, borderRadius);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n     * @param {Float32Array} vertices\n     * @returns {RawShape | undefined}\n     */\n    static convexPolyline(vertices) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_export_2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_convexPolyline(ptr0, len0);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n     * @param {Float32Array} vertices\n     * @param {number} borderRadius\n     * @returns {RawShape | undefined}\n     */\n    static roundConvexPolyline(vertices, borderRadius) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_export_2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_roundConvexPolyline(ptr0, len0, borderRadius);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n     * @param {RawVector} shapePos1\n     * @param {RawRotation} shapeRot1\n     * @param {RawVector} shapeVel1\n     * @param {RawShape} shape2\n     * @param {RawVector} shapePos2\n     * @param {RawRotation} shapeRot2\n     * @param {RawVector} shapeVel2\n     * @param {number} target_distance\n     * @param {number} maxToi\n     * @param {boolean} stop_at_penetration\n     * @returns {RawShapeCastHit | undefined}\n     */\n    castShape(shapePos1, shapeRot1, shapeVel1, shape2, shapePos2, shapeRot2, shapeVel2, target_distance, maxToi, stop_at_penetration) {\n        _assertClass(shapePos1, RawVector);\n        _assertClass(shapeRot1, RawRotation);\n        _assertClass(shapeVel1, RawVector);\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        _assertClass(shapeVel2, RawVector);\n        const ret = wasm.rawshape_castShape(this.__wbg_ptr, shapePos1.__wbg_ptr, shapeRot1.__wbg_ptr, shapeVel1.__wbg_ptr, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr, shapeVel2.__wbg_ptr, target_distance, maxToi, stop_at_penetration);\n        return ret === 0 ? undefined : RawShapeCastHit.__wrap(ret);\n    }\n    /**\n     * @param {RawVector} shapePos1\n     * @param {RawRotation} shapeRot1\n     * @param {RawShape} shape2\n     * @param {RawVector} shapePos2\n     * @param {RawRotation} shapeRot2\n     * @returns {boolean}\n     */\n    intersectsShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2) {\n        _assertClass(shapePos1, RawVector);\n        _assertClass(shapeRot1, RawRotation);\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawshape_intersectsShape(this.__wbg_ptr, shapePos1.__wbg_ptr, shapeRot1.__wbg_ptr, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @param {RawVector} shapePos1\n     * @param {RawRotation} shapeRot1\n     * @param {RawShape} shape2\n     * @param {RawVector} shapePos2\n     * @param {RawRotation} shapeRot2\n     * @param {number} prediction\n     * @returns {RawShapeContact | undefined}\n     */\n    contactShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2, prediction) {\n        _assertClass(shapePos1, RawVector);\n        _assertClass(shapeRot1, RawRotation);\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawshape_contactShape(this.__wbg_ptr, shapePos1.__wbg_ptr, shapeRot1.__wbg_ptr, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr, prediction);\n        return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n     * @param {RawVector} shapePos\n     * @param {RawRotation} shapeRot\n     * @param {RawVector} point\n     * @returns {boolean}\n     */\n    containsPoint(shapePos, shapeRot, point) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(point, RawVector);\n        const ret = wasm.rawshape_containsPoint(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, point.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @param {RawVector} shapePos\n     * @param {RawRotation} shapeRot\n     * @param {RawVector} point\n     * @param {boolean} solid\n     * @returns {RawPointProjection}\n     */\n    projectPoint(shapePos, shapeRot, point, solid) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(point, RawVector);\n        const ret = wasm.rawshape_projectPoint(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, point.__wbg_ptr, solid);\n        return RawPointProjection.__wrap(ret);\n    }\n    /**\n     * @param {RawVector} shapePos\n     * @param {RawRotation} shapeRot\n     * @param {RawVector} rayOrig\n     * @param {RawVector} rayDir\n     * @param {number} maxToi\n     * @returns {boolean}\n     */\n    intersectsRay(shapePos, shapeRot, rayOrig, rayDir, maxToi) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawshape_intersectsRay(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi);\n        return ret !== 0;\n    }\n    /**\n     * @param {RawVector} shapePos\n     * @param {RawRotation} shapeRot\n     * @param {RawVector} rayOrig\n     * @param {RawVector} rayDir\n     * @param {number} maxToi\n     * @param {boolean} solid\n     * @returns {number}\n     */\n    castRay(shapePos, shapeRot, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawshape_castRay(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid);\n        return ret;\n    }\n    /**\n     * @param {RawVector} shapePos\n     * @param {RawRotation} shapeRot\n     * @param {RawVector} rayOrig\n     * @param {RawVector} rayDir\n     * @param {number} maxToi\n     * @param {boolean} solid\n     * @returns {RawRayIntersection | undefined}\n     */\n    castRayAndGetNormal(shapePos, shapeRot, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawshape_castRayAndGetNormal(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid);\n        return ret === 0 ? undefined : RawRayIntersection.__wrap(ret);\n    }\n}\n\nconst RawShapeCastHitFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawshapecasthit_free(ptr >>> 0, 1));\n\nexport class RawShapeCastHit {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawShapeCastHit.prototype);\n        obj.__wbg_ptr = ptr;\n        RawShapeCastHitFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawShapeCastHitFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshapecasthit_free(ptr, 0);\n    }\n    /**\n     * @returns {number}\n     */\n    time_of_impact() {\n        const ret = wasm.rawrotation_re(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {RawVector}\n     */\n    witness1() {\n        const ret = wasm.rawshapecasthit_witness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    witness2() {\n        const ret = wasm.rawcollidershapecasthit_witness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    normal1() {\n        const ret = wasm.rawcollidershapecasthit_witness2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    normal2() {\n        const ret = wasm.rawcollidershapecasthit_normal1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n\nconst RawShapeContactFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawshapecontact_free(ptr >>> 0, 1));\n\nexport class RawShapeContact {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawShapeContact.prototype);\n        obj.__wbg_ptr = ptr;\n        RawShapeContactFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawShapeContactFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshapecontact_free(ptr, 0);\n    }\n    /**\n     * @returns {number}\n     */\n    distance() {\n        const ret = wasm.rawcontactforceevent_total_force_magnitude(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {RawVector}\n     */\n    point1() {\n        const ret = wasm.rawpointprojection_point(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    point2() {\n        const ret = wasm.rawpointcolliderprojection_point(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    normal1() {\n        const ret = wasm.rawcontactforceevent_total_force(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    normal2() {\n        const ret = wasm.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n\nconst RawVectorFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawvector_free(ptr >>> 0, 1));\n/**\n * A vector.\n */\nexport class RawVector {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawVector.prototype);\n        obj.__wbg_ptr = ptr;\n        RawVectorFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawVectorFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawvector_free(ptr, 0);\n    }\n    /**\n     * Creates a new vector filled with zeros.\n     * @returns {RawVector}\n     */\n    static zero() {\n        const ret = wasm.rawvector_zero();\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * Creates a new 2D vector from its two components.\n     *\n     * # Parameters\n     * - `x`: the `x` component of this 2D vector.\n     * - `y`: the `y` component of this 2D vector.\n     * @param {number} x\n     * @param {number} y\n     */\n    constructor(x, y) {\n        const ret = wasm.rawvector_new(x, y);\n        this.__wbg_ptr = ret >>> 0;\n        RawVectorFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * The `x` component of this vector.\n     * @returns {number}\n     */\n    get x() {\n        const ret = wasm.rawrotation_re(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Sets the `x` component of this vector.\n     * @param {number} x\n     */\n    set x(x) {\n        wasm.rawvector_set_x(this.__wbg_ptr, x);\n    }\n    /**\n     * The `y` component of this vector.\n     * @returns {number}\n     */\n    get y() {\n        const ret = wasm.rawintegrationparameters_dt(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Sets the `y` component of this vector.\n     * @param {number} y\n     */\n    set y(y) {\n        wasm.rawintegrationparameters_set_dt(this.__wbg_ptr, y);\n    }\n    /**\n     * Create a new 2D vector from this vector with its components rearranged as `{x, y}`.\n     * @returns {RawVector}\n     */\n    xy() {\n        const ret = wasm.rawvector_xy(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * Create a new 2D vector from this vector with its components rearranged as `{y, x}`.\n     * @returns {RawVector}\n     */\n    yx() {\n        const ret = wasm.rawvector_yx(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n\nasync function __wbg_load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get('Content-Type') != 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbg_bind_c8359b1cba058168 = function(arg0, arg1, arg2, arg3) {\n        const ret = getObject(arg0).bind(getObject(arg1), getObject(arg2), getObject(arg3));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_buffer_609cc3eee51ed158 = function(arg0) {\n        const ret = getObject(arg0).buffer;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_call_672a4d21634d4a24 = function() { return handleError(function (arg0, arg1) {\n        const ret = getObject(arg0).call(getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_call_7cccdd69e0791ae2 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_call_833bed5770ea2041 = function() { return handleError(function (arg0, arg1, arg2, arg3) {\n        const ret = getObject(arg0).call(getObject(arg1), getObject(arg2), getObject(arg3));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_call_b8adc8b1d0a0d8eb = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n        const ret = getObject(arg0).call(getObject(arg1), getObject(arg2), getObject(arg3), getObject(arg4));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_length_3b4f022188ae8db6 = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbg_length_a446193dc22c12f8 = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbg_new_a12002a7f91c75be = function(arg0) {\n        const ret = new Uint8Array(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newnoargs_105ed471475aaf50 = function(arg0, arg1) {\n        const ret = new Function(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_d97e637ebe145a9a = function(arg0, arg1, arg2) {\n        const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354 = function(arg0, arg1, arg2) {\n        const ret = new Float32Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newwithlength_5a5efe313cfd59f1 = function(arg0) {\n        const ret = new Float32Array(arg0 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_now_2c95c9de01293173 = function(arg0) {\n        const ret = getObject(arg0).now();\n        return ret;\n    };\n    imports.wbg.__wbg_performance_7a3ffd0b17f663ad = function(arg0) {\n        const ret = getObject(arg0).performance;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_rawcontactforceevent_new = function(arg0) {\n        const ret = RawContactForceEvent.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_rawraycolliderintersection_new = function(arg0) {\n        const ret = RawRayColliderIntersection.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_10bad9bee0e9c58b = function(arg0, arg1, arg2) {\n        getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n    };\n    imports.wbg.__wbg_set_65595bdd868b3009 = function(arg0, arg1, arg2) {\n        getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n    };\n    imports.wbg.__wbg_static_accessor_GLOBAL_88a902d13a557d07 = function() {\n        const ret = typeof global === 'undefined' ? null : global;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    };\n    imports.wbg.__wbg_static_accessor_GLOBAL_THIS_56578be7e9f832b0 = function() {\n        const ret = typeof globalThis === 'undefined' ? null : globalThis;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    };\n    imports.wbg.__wbg_static_accessor_SELF_37c5d418e4bf5819 = function() {\n        const ret = typeof self === 'undefined' ? null : self;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    };\n    imports.wbg.__wbg_static_accessor_WINDOW_5de37043a91a9c40 = function() {\n        const ret = typeof window === 'undefined' ? null : window;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_boolean_get = function(arg0) {\n        const v = getObject(arg0);\n        const ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2;\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_function = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'function';\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_undefined = function(arg0) {\n        const ret = getObject(arg0) === undefined;\n        return ret;\n    };\n    imports.wbg.__wbindgen_memory = function() {\n        const ret = wasm.memory;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_number_get = function(arg0, arg1) {\n        const obj = getObject(arg1);\n        const ret = typeof(obj) === 'number' ? obj : undefined;\n        getDataViewMemory0().setFloat64(arg0 + 8 * 1, isLikeNone(ret) ? 0 : ret, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, !isLikeNone(ret), true);\n    };\n    imports.wbg.__wbindgen_number_new = function(arg0) {\n        const ret = arg0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_object_clone_ref = function(arg0) {\n        const ret = getObject(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_object_drop_ref = function(arg0) {\n        takeObject(arg0);\n    };\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n        throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n\n    return imports;\n}\n\nfunction __wbg_init_memory(imports, memory) {\n\n}\n\nfunction __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n    cachedDataViewMemory0 = null;\n    cachedFloat32ArrayMemory0 = null;\n    cachedInt32ArrayMemory0 = null;\n    cachedUint32ArrayMemory0 = null;\n    cachedUint8ArrayMemory0 = null;\n\n\n\n    return wasm;\n}\n\nfunction initSync(module) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module !== 'undefined') {\n        if (Object.getPrototypeOf(module) === Object.prototype) {\n            ({module} = module)\n        } else {\n            console.warn('using deprecated parameters for `initSync()`; pass a single object instead')\n        }\n    }\n\n    const imports = __wbg_get_imports();\n\n    __wbg_init_memory(imports);\n\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n\n    const instance = new WebAssembly.Instance(module, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nasync function __wbg_init(module_or_path) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module_or_path !== 'undefined') {\n        if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\n            ({module_or_path} = module_or_path)\n        } else {\n            console.warn('using deprecated parameters for the initialization function; pass a single object instead')\n        }\n    }\n\n    if (typeof module_or_path === 'undefined') {\n        module_or_path = new URL('rapier_wasm2d_bg.wasm', \"<deleted>\");\n    }\n    const imports = __wbg_get_imports();\n\n    if (typeof module_or_path === 'string' || (typeof Request === 'function' && module_or_path instanceof Request) || (typeof URL === 'function' && module_or_path instanceof URL)) {\n        module_or_path = fetch(module_or_path);\n    }\n\n    __wbg_init_memory(imports);\n\n    const { instance, module } = await __wbg_load(await module_or_path, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nexport { initSync };\nexport default __wbg_init;\n","import {RawVector, RawRotation} from \"./raw\";\n\n// #if DIM2\nexport interface Vector {\n    x: number;\n    y: number;\n}\n\n/**\n * A 2D vector.\n */\nexport class Vector2 implements Vector {\n    x: number;\n    y: number;\n\n    constructor(x: number, y: number) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\nexport class VectorOps {\n    public static new(x: number, y: number): Vector {\n        return new Vector2(x, y);\n    }\n\n    public static zeros(): Vector {\n        return VectorOps.new(0.0, 0.0);\n    }\n\n    // FIXME: type ram: RawVector?\n    public static fromRaw(raw: RawVector): Vector {\n        if (!raw) return null;\n\n        let res = VectorOps.new(raw.x, raw.y);\n        raw.free();\n        return res;\n    }\n\n    public static intoRaw(v: Vector): RawVector {\n        return new RawVector(v.x, v.y);\n    }\n\n    public static copy(out: Vector, input: Vector) {\n        out.x = input.x;\n        out.y = input.y;\n    }\n}\n\n/**\n * A rotation angle in radians.\n */\nexport type Rotation = number;\n\nexport class RotationOps {\n    public static identity(): number {\n        return 0.0;\n    }\n\n    public static fromRaw(raw: RawRotation): Rotation {\n        if (!raw) return null;\n\n        let res = raw.angle;\n        raw.free();\n        return res;\n    }\n\n    public static intoRaw(angle: Rotation): RawRotation {\n        return RawRotation.fromAngle(angle);\n    }\n}\n\n// #endif\n\n","import {RawRigidBodySet, RawRigidBodyType} from \"../raw\";\nimport {Rotation, RotationOps, Vector, VectorOps} from \"../math\";\nimport {Collider, ColliderSet} from \"../geometry\";\n\n/**\n * The integer identifier of a collider added to a `ColliderSet`.\n */\nexport type RigidBodyHandle = number;\n\n/**\n * The simulation status of a rigid-body.\n */\n// TODO: rename this to RigidBodyType\nexport enum RigidBodyType {\n    /**\n     * A `RigidBodyType::Dynamic` body can be affected by all external forces.\n     */\n    Dynamic = 0,\n    /**\n     * A `RigidBodyType::Fixed` body cannot be affected by external forces.\n     */\n    Fixed,\n    /**\n     * A `RigidBodyType::KinematicPositionBased` body cannot be affected by any external forces but can be controlled\n     * by the user at the position level while keeping realistic one-way interaction with dynamic bodies.\n     *\n     * One-way interaction means that a kinematic body can push a dynamic body, but a kinematic body\n     * cannot be pushed by anything. In other words, the trajectory of a kinematic body can only be\n     * modified by the user and is independent from any contact or joint it is involved in.\n     */\n    KinematicPositionBased,\n    /**\n     * A `RigidBodyType::KinematicVelocityBased` body cannot be affected by any external forces but can be controlled\n     * by the user at the velocity level while keeping realistic one-way interaction with dynamic bodies.\n     *\n     * One-way interaction means that a kinematic body can push a dynamic body, but a kinematic body\n     * cannot be pushed by anything. In other words, the trajectory of a kinematic body can only be\n     * modified by the user and is independent from any contact or joint it is involved in.\n     */\n    KinematicVelocityBased,\n}\n\n/**\n * A rigid-body.\n */\nexport class RigidBody {\n    private rawSet: RawRigidBodySet; // The RigidBody won't need to free this.\n    private colliderSet: ColliderSet;\n    readonly handle: RigidBodyHandle;\n\n    /**\n     * An arbitrary user-defined object associated with this rigid-body.\n     */\n    public userData?: unknown;\n\n    constructor(\n        rawSet: RawRigidBodySet,\n        colliderSet: ColliderSet,\n        handle: RigidBodyHandle,\n    ) {\n        this.rawSet = rawSet;\n        this.colliderSet = colliderSet;\n        this.handle = handle;\n    }\n\n    /** @internal */\n    public finalizeDeserialization(colliderSet: ColliderSet) {\n        this.colliderSet = colliderSet;\n    }\n\n    /**\n     * Checks if this rigid-body is still valid (i.e. that it has\n     * not been deleted from the rigid-body set yet.\n     */\n    public isValid(): boolean {\n        return this.rawSet.contains(this.handle);\n    }\n\n    /**\n     * Locks or unlocks the ability of this rigid-body to translate.\n     *\n     * @param locked - If `true`, this rigid-body will no longer translate due to forces and impulses.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    public lockTranslations(locked: boolean, wakeUp: boolean) {\n        return this.rawSet.rbLockTranslations(this.handle, locked, wakeUp);\n    }\n\n    /**\n     * Locks or unlocks the ability of this rigid-body to rotate.\n     *\n     * @param locked - If `true`, this rigid-body will no longer rotate due to torques and impulses.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    public lockRotations(locked: boolean, wakeUp: boolean) {\n        return this.rawSet.rbLockRotations(this.handle, locked, wakeUp);\n    }\n\n    // #if DIM2\n    /**\n     * Locks or unlocks the ability of this rigid-body to translation along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Y coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    public setEnabledTranslations(\n        enableX: boolean,\n        enableY: boolean,\n        wakeUp: boolean,\n    ) {\n        return this.rawSet.rbSetEnabledTranslations(\n            this.handle,\n            enableX,\n            enableY,\n            wakeUp,\n        );\n    }\n\n    /**\n     * Locks or unlocks the ability of this rigid-body to translation along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Y coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     * @deprecated use `this.setEnabledTranslations` with the same arguments instead.\n     */\n    public restrictTranslations(\n        enableX: boolean,\n        enableY: boolean,\n        wakeUp: boolean,\n    ) {\n        this.setEnabledTranslations(enableX, enableX, wakeUp);\n    }\n\n    // #endif\n\n    /**\n     * The dominance group, in [-127, +127] this rigid-body is part of.\n     */\n    public dominanceGroup(): number {\n        return this.rawSet.rbDominanceGroup(this.handle);\n    }\n\n    /**\n     * Sets the dominance group of this rigid-body.\n     *\n     * @param group - The dominance group of this rigid-body. Must be a signed integer in the range [-127, +127].\n     */\n    public setDominanceGroup(group: number) {\n        this.rawSet.rbSetDominanceGroup(this.handle, group);\n    }\n\n    /**\n     * The number of additional solver iterations that will be run for this\n     * rigid-body and everything that interacts with it directly or indirectly\n     * through contacts or joints.\n     */\n    public additionalSolverIterations(): number {\n        return this.rawSet.rbAdditionalSolverIterations(this.handle);\n    }\n\n    /**\n     * Sets the number of additional solver iterations that will be run for this\n     * rigid-body and everything that interacts with it directly or indirectly\n     * through contacts or joints.\n     *\n     * Compared to increasing the global `World.numSolverIteration`, setting this\n     * value lets you increase accuracy on only a subset of the scene, resulting in reduced\n     * performance loss.\n     *\n     * @param iters - The new number of additional solver iterations (default: 0).\n     */\n    public setAdditionalSolverIterations(iters: number) {\n        this.rawSet.rbSetAdditionalSolverIterations(this.handle, iters);\n    }\n\n    /**\n     * Enable or disable CCD (Continuous Collision Detection) for this rigid-body.\n     *\n     * @param enabled - If `true`, CCD will be enabled for this rigid-body.\n     */\n    public enableCcd(enabled: boolean) {\n        this.rawSet.rbEnableCcd(this.handle, enabled);\n    }\n\n    /**\n     * Sets the soft-CCD prediction distance for this rigid-body.\n     *\n     * See the documentation of `RigidBodyDesc.setSoftCcdPrediction` for\n     * additional details.\n     */\n    public setSoftCcdPrediction(distance: number) {\n        this.rawSet.rbSetSoftCcdPrediction(this.handle, distance);\n    }\n\n    /**\n     * Gets the soft-CCD prediction distance for this rigid-body.\n     *\n     * See the documentation of `RigidBodyDesc.setSoftCcdPrediction` for\n     * additional details.\n     */\n    public softCcdPrediction(): number {\n        return this.rawSet.rbSoftCcdPrediction(this.handle);\n    }\n\n    /**\n     * The world-space translation of this rigid-body.\n     */\n    public translation(): Vector {\n        let res = this.rawSet.rbTranslation(this.handle);\n        return VectorOps.fromRaw(res);\n    }\n\n    /**\n     * The world-space orientation of this rigid-body.\n     */\n    public rotation(): Rotation {\n        let res = this.rawSet.rbRotation(this.handle);\n        return RotationOps.fromRaw(res);\n    }\n\n    /**\n     * The world-space next translation of this rigid-body.\n     *\n     * If this rigid-body is kinematic this value is set by the `setNextKinematicTranslation`\n     * method and is used for estimating the kinematic body velocity at the next timestep.\n     * For non-kinematic bodies, this value is currently unspecified.\n     */\n    public nextTranslation(): Vector {\n        let res = this.rawSet.rbNextTranslation(this.handle);\n        return VectorOps.fromRaw(res);\n    }\n\n    /**\n     * The world-space next orientation of this rigid-body.\n     *\n     * If this rigid-body is kinematic this value is set by the `setNextKinematicRotation`\n     * method and is used for estimating the kinematic body velocity at the next timestep.\n     * For non-kinematic bodies, this value is currently unspecified.\n     */\n    public nextRotation(): Rotation {\n        let res = this.rawSet.rbNextRotation(this.handle);\n        return RotationOps.fromRaw(res);\n    }\n\n    /**\n     * Sets the translation of this rigid-body.\n     *\n     * @param tra - The world-space position of the rigid-body.\n     * @param wakeUp - Forces the rigid-body to wake-up so it is properly affected by forces if it\n     *                 wasn't moving before modifying its position.\n     */\n    public setTranslation(tra: Vector, wakeUp: boolean) {\n        // #if DIM2\n        this.rawSet.rbSetTranslation(this.handle, tra.x, tra.y, wakeUp);\n        // #endif\n    }\n\n    /**\n     * Sets the linear velocity of this rigid-body.\n     *\n     * @param vel - The linear velocity to set.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    public setLinvel(vel: Vector, wakeUp: boolean) {\n        let rawVel = VectorOps.intoRaw(vel);\n        this.rawSet.rbSetLinvel(this.handle, rawVel, wakeUp);\n        rawVel.free();\n    }\n\n    /**\n     * The scale factor applied to the gravity affecting\n     * this rigid-body.\n     */\n    public gravityScale(): number {\n        return this.rawSet.rbGravityScale(this.handle);\n    }\n\n    /**\n     * Sets the scale factor applied to the gravity affecting\n     * this rigid-body.\n     *\n     * @param factor - The scale factor to set. A value of 0.0 means\n     *   that this rigid-body will on longer be affected by gravity.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    public setGravityScale(factor: number, wakeUp: boolean) {\n        this.rawSet.rbSetGravityScale(this.handle, factor, wakeUp);\n    }\n\n\n    // #if DIM2\n    /**\n     * Sets the rotation angle of this rigid-body.\n     *\n     * @param angle - The rotation angle, in radians.\n     * @param wakeUp - Forces the rigid-body to wake-up so it is properly affected by forces if it\n     * wasn't moving before modifying its position.\n     */\n    public setRotation(angle: number, wakeUp: boolean) {\n        this.rawSet.rbSetRotation(this.handle, angle, wakeUp);\n    }\n\n    /**\n     * Sets the angular velocity fo this rigid-body.\n     *\n     * @param vel - The angular velocity to set.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    public setAngvel(vel: number, wakeUp: boolean) {\n        this.rawSet.rbSetAngvel(this.handle, vel, wakeUp);\n    }\n\n    // #endif\n\n    /**\n     * If this rigid body is kinematic, sets its future translation after the next timestep integration.\n     *\n     * This should be used instead of `rigidBody.setTranslation` to make the dynamic object\n     * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n     * an artificial velocity for this rigid-body from its current position and its next kinematic\n     * position. This velocity will be used to compute forces on dynamic bodies interacting with\n     * this body.\n     *\n     * @param t - The kinematic translation to set.\n     */\n    public setNextKinematicTranslation(t: Vector) {\n        // #if DIM2\n        this.rawSet.rbSetNextKinematicTranslation(this.handle, t.x, t.y);\n        // #endif\n    }\n\n\n    // #if DIM2\n    /**\n     * If this rigid body is kinematic, sets its future rotation after the next timestep integration.\n     *\n     * This should be used instead of `rigidBody.setRotation` to make the dynamic object\n     * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n     * an artificial velocity for this rigid-body from its current position and its next kinematic\n     * position. This velocity will be used to compute forces on dynamic bodies interacting with\n     * this body.\n     *\n     * @param angle - The kinematic rotation angle, in radians.\n     */\n    public setNextKinematicRotation(angle: number) {\n        this.rawSet.rbSetNextKinematicRotation(this.handle, angle);\n    }\n\n    // #endif\n\n    /**\n     * The linear velocity of this rigid-body.\n     */\n    public linvel(): Vector {\n        return VectorOps.fromRaw(this.rawSet.rbLinvel(this.handle));\n    }\n\n    /**\n     * The velocity of the given world-space point on this rigid-body.\n     */\n    public velocityAtPoint(point: Vector): Vector {\n        const rawPoint = VectorOps.intoRaw(point);\n        let result = VectorOps.fromRaw(\n            this.rawSet.rbVelocityAtPoint(this.handle, rawPoint),\n        );\n        rawPoint.free();\n        return result;\n    }\n\n\n    // #if DIM2\n    /**\n     * The angular velocity of this rigid-body.\n     */\n    public angvel(): number {\n        return this.rawSet.rbAngvel(this.handle);\n    }\n\n    // #endif\n\n    /**\n     * The mass of this rigid-body.\n     */\n    public mass(): number {\n        return this.rawSet.rbMass(this.handle);\n    }\n\n    /**\n     * The inverse mass taking into account translation locking.\n     */\n    public effectiveInvMass(): Vector {\n        return VectorOps.fromRaw(this.rawSet.rbEffectiveInvMass(this.handle));\n    }\n\n    /**\n     * The inverse of the mass of a rigid-body.\n     *\n     * If this is zero, the rigid-body is assumed to have infinite mass.\n     */\n    public invMass(): number {\n        return this.rawSet.rbInvMass(this.handle);\n    }\n\n    /**\n     * The center of mass of a rigid-body expressed in its local-space.\n     */\n    public localCom(): Vector {\n        return VectorOps.fromRaw(this.rawSet.rbLocalCom(this.handle));\n    }\n\n    /**\n     * The world-space center of mass of the rigid-body.\n     */\n    public worldCom(): Vector {\n        return VectorOps.fromRaw(this.rawSet.rbWorldCom(this.handle));\n    }\n\n    // #if DIM2\n    /**\n     * The inverse of the principal angular inertia of the rigid-body.\n     *\n     * Components set to zero are assumed to be infinite along the corresponding principal axis.\n     */\n    public invPrincipalInertiaSqrt(): number {\n        return this.rawSet.rbInvPrincipalInertiaSqrt(this.handle);\n    }\n\n    // #endif\n\n\n    // #if DIM2\n    /**\n     * The angular inertia along the principal inertia axes of the rigid-body.\n     */\n    public principalInertia(): number {\n        return this.rawSet.rbPrincipalInertia(this.handle);\n    }\n\n    // #endif\n\n\n\n    // #if DIM2\n    /**\n     * The square-root of the world-space inverse angular inertia tensor of the rigid-body,\n     * taking into account rotation locking.\n     */\n    public effectiveWorldInvInertiaSqrt(): number {\n        return this.rawSet.rbEffectiveWorldInvInertiaSqrt(this.handle);\n    }\n\n    // #endif\n\n\n    // #if DIM2\n    /**\n     * The effective world-space angular inertia (that takes the potential rotation locking into account) of\n     * this rigid-body.\n     */\n    public effectiveAngularInertia(): number {\n        return this.rawSet.rbEffectiveAngularInertia(this.handle);\n    }\n\n    // #endif\n\n\n    /**\n     * Put this rigid body to sleep.\n     *\n     * A sleeping body no longer moves and is no longer simulated by the physics engine unless\n     * it is waken up. It can be woken manually with `this.wakeUp()` or automatically due to\n     * external forces like contacts.\n     */\n    public sleep() {\n        this.rawSet.rbSleep(this.handle);\n    }\n\n    /**\n     * Wakes this rigid-body up.\n     *\n     * A dynamic rigid-body that does not move during several consecutive frames will\n     * be put to sleep by the physics engine, i.e., it will stop being simulated in order\n     * to avoid useless computations.\n     * This methods forces a sleeping rigid-body to wake-up. This is useful, e.g., before modifying\n     * the position of a dynamic body so that it is properly simulated afterwards.\n     */\n    public wakeUp() {\n        this.rawSet.rbWakeUp(this.handle);\n    }\n\n    /**\n     * Is CCD enabled for this rigid-body?\n     */\n    public isCcdEnabled(): boolean {\n        return this.rawSet.rbIsCcdEnabled(this.handle);\n    }\n\n    /**\n     * The number of colliders attached to this rigid-body.\n     */\n    public numColliders(): number {\n        return this.rawSet.rbNumColliders(this.handle);\n    }\n\n    /**\n     * Retrieves the `i-th` collider attached to this rigid-body.\n     *\n     * @param i - The index of the collider to retrieve. Must be a number in `[0, this.numColliders()[`.\n     *         This index is **not** the same as the unique identifier of the collider.\n     */\n    public collider(i: number): Collider {\n        return this.colliderSet.get(this.rawSet.rbCollider(this.handle, i));\n    }\n\n    /**\n     * Sets whether this rigid-body is enabled or not.\n     *\n     * @param enabled - Set to `false` to disable this rigid-body and all its attached colliders.\n     */\n    public setEnabled(enabled: boolean) {\n        this.rawSet.rbSetEnabled(this.handle, enabled);\n    }\n\n    /**\n     * Is this rigid-body enabled?\n     */\n    public isEnabled(): boolean {\n        return this.rawSet.rbIsEnabled(this.handle);\n    }\n\n    /**\n     * The status of this rigid-body: static, dynamic, or kinematic.\n     */\n    public bodyType(): RigidBodyType {\n        return this.rawSet.rbBodyType(this.handle) as number as RigidBodyType;\n    }\n\n    /**\n     * Set a new status for this rigid-body: static, dynamic, or kinematic.\n     */\n    public setBodyType(type: RigidBodyType, wakeUp: boolean) {\n        return this.rawSet.rbSetBodyType(\n            this.handle,\n            type as number as RawRigidBodyType,\n            wakeUp,\n        );\n    }\n\n    /**\n     * Is this rigid-body sleeping?\n     */\n    public isSleeping(): boolean {\n        return this.rawSet.rbIsSleeping(this.handle);\n    }\n\n    /**\n     * Is the velocity of this rigid-body not zero?\n     */\n    public isMoving(): boolean {\n        return this.rawSet.rbIsMoving(this.handle);\n    }\n\n    /**\n     * Is this rigid-body static?\n     */\n    public isFixed(): boolean {\n        return this.rawSet.rbIsFixed(this.handle);\n    }\n\n    /**\n     * Is this rigid-body kinematic?\n     */\n    public isKinematic(): boolean {\n        return this.rawSet.rbIsKinematic(this.handle);\n    }\n\n    /**\n     * Is this rigid-body dynamic?\n     */\n    public isDynamic(): boolean {\n        return this.rawSet.rbIsDynamic(this.handle);\n    }\n\n    /**\n     * The linear damping coefficient of this rigid-body.\n     */\n    public linearDamping(): number {\n        return this.rawSet.rbLinearDamping(this.handle);\n    }\n\n    /**\n     * The angular damping coefficient of this rigid-body.\n     */\n    public angularDamping(): number {\n        return this.rawSet.rbAngularDamping(this.handle);\n    }\n\n    /**\n     * Sets the linear damping factor applied to this rigid-body.\n     *\n     * @param factor - The damping factor to set.\n     */\n    public setLinearDamping(factor: number) {\n        this.rawSet.rbSetLinearDamping(this.handle, factor);\n    }\n\n    /**\n     * Recompute the mass-properties of this rigid-bodies based on its currently attached colliders.\n     */\n    public recomputeMassPropertiesFromColliders() {\n        this.rawSet.rbRecomputeMassPropertiesFromColliders(\n            this.handle,\n            this.colliderSet.raw,\n        );\n    }\n\n    /**\n     * Sets the rigid-body's additional mass.\n     *\n     * The total angular inertia of the rigid-body will be scaled automatically based on this additional mass. If this\n     * scaling effect isn’t desired, use Self::additional_mass_properties instead of this method.\n     *\n     * This is only the \"additional\" mass because the total mass of the rigid-body is equal to the sum of this\n     * additional mass and the mass computed from the colliders (with non-zero densities) attached to this rigid-body.\n     *\n     * That total mass (which includes the attached colliders’ contributions) will be updated at the name physics step,\n     * or can be updated manually with `this.recomputeMassPropertiesFromColliders`.\n     *\n     * This will override any previous additional mass-properties set by `this.setAdditionalMass`,\n     * `this.setAdditionalMassProperties`, `RigidBodyDesc::setAdditionalMass`, or\n     * `RigidBodyDesc.setAdditionalMassfProperties` for this rigid-body.\n     *\n     * @param mass - The additional mass to set.\n     * @param wakeUp - If `true` then the rigid-body will be woken up if it was put to sleep because it did not move for a while.\n     */\n    public setAdditionalMass(mass: number, wakeUp: boolean) {\n        this.rawSet.rbSetAdditionalMass(this.handle, mass, wakeUp);\n    }\n\n\n    // #if DIM2\n    /**\n     * Sets the rigid-body's additional mass-properties.\n     *\n     * This is only the \"additional\" mass-properties because the total mass-properties of the rigid-body is equal to the\n     * sum of this additional mass-properties and the mass computed from the colliders (with non-zero densities) attached\n     * to this rigid-body.\n     *\n     * That total mass-properties (which include the attached colliders’ contributions) will be updated at the name\n     * physics step, or can be updated manually with `this.recomputeMassPropertiesFromColliders`.\n     *\n     * This will override any previous mass-properties set by `this.setAdditionalMass`,\n     * `this.setAdditionalMassProperties`, `RigidBodyDesc.setAdditionalMass`, or `RigidBodyDesc.setAdditionalMassProperties`\n     * for this rigid-body.\n     *\n     * If `wake_up` is true then the rigid-body will be woken up if it was put to sleep because it did not move for a while.\n     */\n    public setAdditionalMassProperties(\n        mass: number,\n        centerOfMass: Vector,\n        principalAngularInertia: number,\n        wakeUp: boolean,\n    ) {\n        let rawCom = VectorOps.intoRaw(centerOfMass);\n        this.rawSet.rbSetAdditionalMassProperties(\n            this.handle,\n            mass,\n            rawCom,\n            principalAngularInertia,\n            wakeUp,\n        );\n        rawCom.free();\n    }\n\n    // #endif\n\n    /**\n     * Sets the linear damping factor applied to this rigid-body.\n     *\n     * @param factor - The damping factor to set.\n     */\n    public setAngularDamping(factor: number) {\n        this.rawSet.rbSetAngularDamping(this.handle, factor);\n    }\n\n    /**\n     * Resets to zero the user forces (but not torques) applied to this rigid-body.\n     *\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public resetForces(wakeUp: boolean) {\n        this.rawSet.rbResetForces(this.handle, wakeUp);\n    }\n\n    /**\n     * Resets to zero the user torques applied to this rigid-body.\n     *\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public resetTorques(wakeUp: boolean) {\n        this.rawSet.rbResetTorques(this.handle, wakeUp);\n    }\n\n    /**\n     * Adds a force at the center-of-mass of this rigid-body.\n     *\n     * @param force - the world-space force to add to the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public addForce(force: Vector, wakeUp: boolean) {\n        const rawForce = VectorOps.intoRaw(force);\n        this.rawSet.rbAddForce(this.handle, rawForce, wakeUp);\n        rawForce.free();\n    }\n\n    /**\n     * Applies an impulse at the center-of-mass of this rigid-body.\n     *\n     * @param impulse - the world-space impulse to apply on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public applyImpulse(impulse: Vector, wakeUp: boolean) {\n        const rawImpulse = VectorOps.intoRaw(impulse);\n        this.rawSet.rbApplyImpulse(this.handle, rawImpulse, wakeUp);\n        rawImpulse.free();\n    }\n\n    // #if DIM2\n    /**\n     * Adds a torque at the center-of-mass of this rigid-body.\n     *\n     * @param torque - the torque to add to the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public addTorque(torque: number, wakeUp: boolean) {\n        this.rawSet.rbAddTorque(this.handle, torque, wakeUp);\n    }\n\n    // #endif\n\n\n    // #if DIM2\n    /**\n     * Applies an impulsive torque at the center-of-mass of this rigid-body.\n     *\n     * @param torqueImpulse - the torque impulse to apply on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public applyTorqueImpulse(torqueImpulse: number, wakeUp: boolean) {\n        this.rawSet.rbApplyTorqueImpulse(this.handle, torqueImpulse, wakeUp);\n    }\n\n    // #endif\n\n\n    /**\n     * Adds a force at the given world-space point of this rigid-body.\n     *\n     * @param force - the world-space force to add to the rigid-body.\n     * @param point - the world-space point where the impulse is to be applied on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public addForceAtPoint(force: Vector, point: Vector, wakeUp: boolean) {\n        const rawForce = VectorOps.intoRaw(force);\n        const rawPoint = VectorOps.intoRaw(point);\n        this.rawSet.rbAddForceAtPoint(this.handle, rawForce, rawPoint, wakeUp);\n        rawForce.free();\n        rawPoint.free();\n    }\n\n    /**\n     * Applies an impulse at the given world-space point of this rigid-body.\n     *\n     * @param impulse - the world-space impulse to apply on the rigid-body.\n     * @param point - the world-space point where the impulse is to be applied on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public applyImpulseAtPoint(\n        impulse: Vector,\n        point: Vector,\n        wakeUp: boolean,\n    ) {\n        const rawImpulse = VectorOps.intoRaw(impulse);\n        const rawPoint = VectorOps.intoRaw(point);\n        this.rawSet.rbApplyImpulseAtPoint(\n            this.handle,\n            rawImpulse,\n            rawPoint,\n            wakeUp,\n        );\n        rawImpulse.free();\n        rawPoint.free();\n    }\n\n    /**\n     * Retrieves the constant force(s) the user added to this rigid-body\n     * Returns zero if the rigid-body is not dynamic.\n     */\n    public userForce(): Vector {\n        return VectorOps.fromRaw(this.rawSet.rbUserForce(this.handle));\n    }\n\n    // #if DIM2\n    /**\n     * Retrieves the constant torque(s) the user added to this rigid-body\n     * Returns zero if the rigid-body is not dynamic.\n     */\n    public userTorque(): number {\n        return this.rawSet.rbUserTorque(this.handle);\n    }\n    // #endif\n\n}\n\nexport class RigidBodyDesc {\n    enabled: boolean;\n    translation: Vector;\n    rotation: Rotation;\n    gravityScale: number;\n    mass: number;\n    massOnly: boolean;\n    centerOfMass: Vector;\n    translationsEnabledX: boolean;\n    translationsEnabledY: boolean;\n    linvel: Vector;\n    // #if DIM2\n    angvel: number;\n    principalAngularInertia: number;\n    rotationsEnabled: boolean;\n    // #endif\n    linearDamping: number;\n    angularDamping: number;\n    status: RigidBodyType;\n    canSleep: boolean;\n    sleeping: boolean;\n    ccdEnabled: boolean;\n    softCcdPrediction: number;\n    dominanceGroup: number;\n    additionalSolverIterations: number;\n    userData?: unknown;\n\n    constructor(status: RigidBodyType) {\n        this.enabled = true;\n        this.status = status;\n        this.translation = VectorOps.zeros();\n        this.rotation = RotationOps.identity();\n        this.gravityScale = 1.0;\n        this.linvel = VectorOps.zeros();\n        this.mass = 0.0;\n        this.massOnly = false;\n        this.centerOfMass = VectorOps.zeros();\n        this.translationsEnabledX = true;\n        this.translationsEnabledY = true;\n        // #if DIM2\n        this.angvel = 0.0;\n        this.principalAngularInertia = 0.0;\n        this.rotationsEnabled = true;\n        // #endif\n        this.linearDamping = 0.0;\n        this.angularDamping = 0.0;\n        this.canSleep = true;\n        this.sleeping = false;\n        this.ccdEnabled = false;\n        this.softCcdPrediction = 0.0;\n        this.dominanceGroup = 0;\n        this.additionalSolverIterations = 0;\n    }\n\n    /**\n     * A rigid-body descriptor used to build a dynamic rigid-body.\n     */\n    public static dynamic(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.Dynamic);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a position-based kinematic rigid-body.\n     */\n    public static kinematicPositionBased(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.KinematicPositionBased);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a velocity-based kinematic rigid-body.\n     */\n    public static kinematicVelocityBased(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.KinematicVelocityBased);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a fixed rigid-body.\n     */\n    public static fixed(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.Fixed);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a dynamic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.dynamic()`.\n     */\n    public static newDynamic(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.Dynamic);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a position-based kinematic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.kinematicPositionBased()`.\n     */\n    public static newKinematicPositionBased(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.KinematicPositionBased);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a velocity-based kinematic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.kinematicVelocityBased()`.\n     */\n    public static newKinematicVelocityBased(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.KinematicVelocityBased);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a fixed rigid-body.\n     *\n     * @deprecated The method has been renamed to `.fixed()`.\n     */\n    public static newStatic(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.Fixed);\n    }\n\n    public setDominanceGroup(group: number): RigidBodyDesc {\n        this.dominanceGroup = group;\n        return this;\n    }\n\n    /**\n     * Sets the number of additional solver iterations that will be run for this\n     * rigid-body and everything that interacts with it directly or indirectly\n     * through contacts or joints.\n     *\n     * Compared to increasing the global `World.numSolverIteration`, setting this\n     * value lets you increase accuracy on only a subset of the scene, resulting in reduced\n     * performance loss.\n     *\n     * @param iters - The new number of additional solver iterations (default: 0).\n     */\n    public setAdditionalSolverIterations(iters: number): RigidBodyDesc {\n        this.additionalSolverIterations = iters;\n        return this;\n    }\n\n    /**\n     * Sets whether the created rigid-body will be enabled or disabled.\n     * @param enabled − If set to `false` the rigid-body will be disabled at creation.\n     */\n    public setEnabled(enabled: boolean): RigidBodyDesc {\n        this.enabled = enabled;\n        return this;\n    }\n\n    // #if DIM2\n    /**\n     * Sets the initial translation of the rigid-body to create.\n     */\n    public setTranslation(x: number, y: number): RigidBodyDesc {\n        if (typeof x != \"number\" || typeof y != \"number\")\n            throw TypeError(\"The translation components must be numbers.\");\n\n        this.translation = {x: x, y: y};\n        return this;\n    }\n\n    // #endif\n\n\n    /**\n     * Sets the initial rotation of the rigid-body to create.\n     *\n     * @param rot - The rotation to set.\n     */\n    public setRotation(rot: Rotation): RigidBodyDesc {\n        // #if DIM2\n        this.rotation = rot;\n        // #endif\n        return this;\n    }\n\n    /**\n     * Sets the scale factor applied to the gravity affecting\n     * the rigid-body being built.\n     *\n     * @param scale - The scale factor. Set this to `0.0` if the rigid-body\n     *   needs to ignore gravity.\n     */\n    public setGravityScale(scale: number): RigidBodyDesc {\n        this.gravityScale = scale;\n        return this;\n    }\n\n    /**\n     * Sets the initial mass of the rigid-body being built, before adding colliders' contributions.\n     *\n     * @param mass − The initial mass of the rigid-body to create.\n     */\n    public setAdditionalMass(mass: number): RigidBodyDesc {\n        this.mass = mass;\n        this.massOnly = true;\n        return this;\n    }\n\n    // #if DIM2\n    /**\n     * Sets the initial linear velocity of the rigid-body to create.\n     *\n     * @param x - The linear velocity to set along the `x` axis.\n     * @param y - The linear velocity to set along the `y` axis.\n     */\n    public setLinvel(x: number, y: number): RigidBodyDesc {\n        if (typeof x != \"number\" || typeof y != \"number\")\n            throw TypeError(\"The linvel components must be numbers.\");\n\n        this.linvel = {x: x, y: y};\n        return this;\n    }\n\n    /**\n     * Sets the initial angular velocity of the rigid-body to create.\n     *\n     * @param vel - The angular velocity to set.\n     */\n    public setAngvel(vel: number): RigidBodyDesc {\n        this.angvel = vel;\n        return this;\n    }\n\n    /**\n     * Sets the mass properties of the rigid-body being built.\n     *\n     * Note that the final mass properties of the rigid-bodies depends\n     * on the initial mass-properties of the rigid-body (set by this method)\n     * to which is added the contributions of all the colliders with non-zero density\n     * attached to this rigid-body.\n     *\n     * Therefore, if you want your provided mass properties to be the final\n     * mass properties of your rigid-body, don't attach colliders to it, or\n     * only attach colliders with densities equal to zero.\n     *\n     * @param mass − The initial mass of the rigid-body to create.\n     * @param centerOfMass − The initial center-of-mass of the rigid-body to create.\n     * @param principalAngularInertia − The initial principal angular inertia of the rigid-body to create.\n     */\n    public setAdditionalMassProperties(\n        mass: number,\n        centerOfMass: Vector,\n        principalAngularInertia: number,\n    ): RigidBodyDesc {\n        this.mass = mass;\n        VectorOps.copy(this.centerOfMass, centerOfMass);\n        this.principalAngularInertia = principalAngularInertia;\n        this.massOnly = false;\n        return this;\n    }\n\n    /**\n     * Allow translation of this rigid-body only along specific axes.\n     * @param translationsEnabledX - Are translations along the X axis enabled?\n     * @param translationsEnabledY - Are translations along the y axis enabled?\n     */\n    public enabledTranslations(\n        translationsEnabledX: boolean,\n        translationsEnabledY: boolean,\n    ): RigidBodyDesc {\n        this.translationsEnabledX = translationsEnabledX;\n        this.translationsEnabledY = translationsEnabledY;\n        return this;\n    }\n\n    /**\n     * Allow translation of this rigid-body only along specific axes.\n     * @param translationsEnabledX - Are translations along the X axis enabled?\n     * @param translationsEnabledY - Are translations along the y axis enabled?\n     * @deprecated use `this.enabledTranslations` with the same arguments instead.\n     */\n    public restrictTranslations(\n        translationsEnabledX: boolean,\n        translationsEnabledY: boolean,\n    ): RigidBodyDesc {\n        return this.enabledTranslations(\n            translationsEnabledX,\n            translationsEnabledY,\n        );\n    }\n\n    /**\n     * Locks all translations that would have resulted from forces on\n     * the created rigid-body.\n     */\n    public lockTranslations(): RigidBodyDesc {\n        return this.restrictTranslations(false, false);\n    }\n\n    /**\n     * Locks all rotations that would have resulted from forces on\n     * the created rigid-body.\n     */\n    public lockRotations(): RigidBodyDesc {\n        this.rotationsEnabled = false;\n        return this;\n    }\n\n    // #endif\n\n\n    /**\n     * Sets the linear damping of the rigid-body to create.\n     *\n     * This will progressively slowdown the translational movement of the rigid-body.\n     *\n     * @param damping - The angular damping coefficient. Should be >= 0. The higher this\n     *                  value is, the stronger the translational slowdown will be.\n     */\n    public setLinearDamping(damping: number): RigidBodyDesc {\n        this.linearDamping = damping;\n        return this;\n    }\n\n    /**\n     * Sets the angular damping of the rigid-body to create.\n     *\n     * This will progressively slowdown the rotational movement of the rigid-body.\n     *\n     * @param damping - The angular damping coefficient. Should be >= 0. The higher this\n     *                  value is, the stronger the rotational slowdown will be.\n     */\n    public setAngularDamping(damping: number): RigidBodyDesc {\n        this.angularDamping = damping;\n        return this;\n    }\n\n    /**\n     * Sets whether or not the rigid-body to create can sleep.\n     *\n     * @param can - true if the rigid-body can sleep, false if it can't.\n     */\n    public setCanSleep(can: boolean): RigidBodyDesc {\n        this.canSleep = can;\n        return this;\n    }\n\n    /**\n     * Sets whether or not the rigid-body is to be created asleep.\n     *\n     * @param can - true if the rigid-body should be in sleep, default false.\n     */\n    setSleeping(sleeping: boolean): RigidBodyDesc {\n        this.sleeping = sleeping;\n        return this;\n    }\n\n    /**\n     * Sets whether Continuous Collision Detection (CCD) is enabled for this rigid-body.\n     *\n     * @param enabled - true if the rigid-body has CCD enabled.\n     */\n    public setCcdEnabled(enabled: boolean): RigidBodyDesc {\n        this.ccdEnabled = enabled;\n        return this;\n    }\n\n    /**\n     * Sets the maximum prediction distance Soft Continuous Collision-Detection.\n     *\n     * When set to 0, soft-CCD is disabled. Soft-CCD helps prevent tunneling especially of\n     * slow-but-thin to moderately fast objects. The soft CCD prediction distance indicates how\n     * far in the object’s path the CCD algorithm is allowed to inspect. Large values can impact\n     * performance badly by increasing the work needed from the broad-phase.\n     *\n     * It is a generally cheaper variant of regular CCD (that can be enabled with\n     * `RigidBodyDesc::setCcdEnabled` since it relies on predictive constraints instead of\n     * shape-cast and substeps.\n     */\n    public setSoftCcdPrediction(distance: number): RigidBodyDesc {\n        this.softCcdPrediction = distance;\n        return this;\n    }\n\n    /**\n     * Sets the user-defined object of this rigid-body.\n     *\n     * @param userData - The user-defined object to set.\n     */\n    public setUserData(data?: unknown): RigidBodyDesc {\n        this.userData = data;\n        return this;\n    }\n}\n","import {Rotation, Vector, VectorOps, RotationOps} from \"../math\";\nimport {\n    RawGenericJoint,\n    RawImpulseJointSet,\n    RawRigidBodySet,\n    RawJointAxis,\n    RawJointType,\n    RawMotorModel,\n} from \"../raw\";\nimport {RigidBody, RigidBodyHandle} from \"./rigid_body\";\nimport {RigidBodySet} from \"./rigid_body_set\";\n\n/**\n * The integer identifier of a collider added to a `ColliderSet`.\n */\nexport type ImpulseJointHandle = number;\n\n/**\n * An enum grouping all possible types of joints:\n *\n * - `Revolute`: A revolute joint that removes all degrees of freedom between the affected\n *               bodies except for the rotation along one axis.\n * - `Fixed`: A fixed joint that removes all relative degrees of freedom between the affected bodies.\n * - `Prismatic`: A prismatic joint that removes all degrees of freedom between the affected\n *                bodies except for the translation along one axis.\n * - `Spherical`: (3D only) A spherical joint that removes all relative linear degrees of freedom between the affected bodies.\n * - `Generic`: (3D only) A joint with customizable degrees of freedom, allowing any of the 6 axes to be locked.\n */\nexport enum JointType {\n    Revolute,\n    Fixed,\n    Prismatic,\n    Rope,\n    Spring,\n}\n\nexport enum MotorModel {\n    AccelerationBased,\n    ForceBased,\n}\n\n/**\n * An enum representing the possible joint axes of a generic joint.\n * They can be ORed together, like:\n * JointAxesMask.LinX || JointAxesMask.LinY\n * to get a joint that is only free in the X and Y translational (positional) axes.\n *\n * Possible free axes are:\n *\n * - `X`: X translation axis\n * - `Y`: Y translation axis\n * - `Z`: Z translation axis\n * - `AngX`: X angular rotation axis\n * - `AngY`: Y angular rotations axis\n * - `AngZ`: Z angular rotation axis\n */\nexport enum JointAxesMask {\n    LinX = 1 << 0,\n    LinY = 1 << 1,\n    LinZ = 1 << 2,\n    AngX = 1 << 3,\n    AngY = 1 << 4,\n    AngZ = 1 << 5,\n}\n\nexport class ImpulseJoint {\n    protected rawSet: RawImpulseJointSet; // The ImpulseJoint won't need to free this.\n    protected bodySet: RigidBodySet; // The ImpulseJoint won’t need to free this.\n    handle: ImpulseJointHandle;\n\n    constructor(\n        rawSet: RawImpulseJointSet,\n        bodySet: RigidBodySet,\n        handle: ImpulseJointHandle,\n    ) {\n        this.rawSet = rawSet;\n        this.bodySet = bodySet;\n        this.handle = handle;\n    }\n\n    public static newTyped(\n        rawSet: RawImpulseJointSet,\n        bodySet: RigidBodySet,\n        handle: ImpulseJointHandle,\n    ): ImpulseJoint {\n        switch (rawSet.jointType(handle)) {\n            case RawJointType.Revolute:\n                return new RevoluteImpulseJoint(rawSet, bodySet, handle);\n            case RawJointType.Prismatic:\n                return new PrismaticImpulseJoint(rawSet, bodySet, handle);\n            case RawJointType.Fixed:\n                return new FixedImpulseJoint(rawSet, bodySet, handle);\n            case RawJointType.Spring:\n                return new SpringImpulseJoint(rawSet, bodySet, handle);\n            case RawJointType.Rope:\n                return new RopeImpulseJoint(rawSet, bodySet, handle);\n            default:\n                return new ImpulseJoint(rawSet, bodySet, handle);\n        }\n    }\n\n    /** @internal */\n    public finalizeDeserialization(bodySet: RigidBodySet) {\n        this.bodySet = bodySet;\n    }\n\n    /**\n     * Checks if this joint is still valid (i.e. that it has\n     * not been deleted from the joint set yet).\n     */\n    public isValid(): boolean {\n        return this.rawSet.contains(this.handle);\n    }\n\n    /**\n     * The first rigid-body this joint it attached to.\n     */\n    public body1(): RigidBody {\n        return this.bodySet.get(this.rawSet.jointBodyHandle1(this.handle));\n    }\n\n    /**\n     * The second rigid-body this joint is attached to.\n     */\n    public body2(): RigidBody {\n        return this.bodySet.get(this.rawSet.jointBodyHandle2(this.handle));\n    }\n\n    /**\n     * The type of this joint given as a string.\n     */\n    public type(): JointType {\n        return this.rawSet.jointType(this.handle) as number as JointType;\n    }\n\n\n\n    /**\n     * The position of the first anchor of this joint.\n     *\n     * The first anchor gives the position of the application point on the\n     * local frame of the first rigid-body it is attached to.\n     */\n    public anchor1(): Vector {\n        return VectorOps.fromRaw(this.rawSet.jointAnchor1(this.handle));\n    }\n\n    /**\n     * The position of the second anchor of this joint.\n     *\n     * The second anchor gives the position of the application point on the\n     * local frame of the second rigid-body it is attached to.\n     */\n    public anchor2(): Vector {\n        return VectorOps.fromRaw(this.rawSet.jointAnchor2(this.handle));\n    }\n\n    /**\n     * Sets the position of the first anchor of this joint.\n     *\n     * The first anchor gives the position of the application point on the\n     * local frame of the first rigid-body it is attached to.\n     */\n    public setAnchor1(newPos: Vector) {\n        const rawPoint = VectorOps.intoRaw(newPos);\n        this.rawSet.jointSetAnchor1(this.handle, rawPoint);\n        rawPoint.free();\n    }\n\n    /**\n     * Sets the position of the second anchor of this joint.\n     *\n     * The second anchor gives the position of the application point on the\n     * local frame of the second rigid-body it is attached to.\n     */\n    public setAnchor2(newPos: Vector) {\n        const rawPoint = VectorOps.intoRaw(newPos);\n        this.rawSet.jointSetAnchor2(this.handle, rawPoint);\n        rawPoint.free();\n    }\n\n    /**\n     * Controls whether contacts are computed between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    public setContactsEnabled(enabled: boolean) {\n        this.rawSet.jointSetContactsEnabled(this.handle, enabled);\n    }\n\n    /**\n     * Indicates if contacts are enabled between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    public contactsEnabled(): boolean {\n        return this.rawSet.jointContactsEnabled(this.handle);\n    }\n}\n\nexport class UnitImpulseJoint extends ImpulseJoint {\n    /**\n     * The axis left free by this joint.\n     */\n    protected rawAxis?(): RawJointAxis;\n\n    /**\n     * Are the limits enabled for this joint?\n     */\n    public limitsEnabled(): boolean {\n        return this.rawSet.jointLimitsEnabled(this.handle, this.rawAxis());\n    }\n\n    /**\n     * The min limit of this joint.\n     */\n    public limitsMin(): number {\n        return this.rawSet.jointLimitsMin(this.handle, this.rawAxis());\n    }\n\n    /**\n     * The max limit of this joint.\n     */\n    public limitsMax(): number {\n        return this.rawSet.jointLimitsMax(this.handle, this.rawAxis());\n    }\n\n    /**\n     * Sets the limits of this joint.\n     *\n     * @param min - The minimum bound of this joint’s free coordinate.\n     * @param max - The maximum bound of this joint’s free coordinate.\n     */\n    public setLimits(min: number, max: number) {\n        this.rawSet.jointSetLimits(this.handle, this.rawAxis(), min, max);\n    }\n\n    public configureMotorModel(model: MotorModel) {\n        this.rawSet.jointConfigureMotorModel(\n            this.handle,\n            this.rawAxis(),\n            model as number as RawMotorModel,\n        );\n    }\n\n    public configureMotorVelocity(targetVel: number, factor: number) {\n        this.rawSet.jointConfigureMotorVelocity(\n            this.handle,\n            this.rawAxis(),\n            targetVel,\n            factor,\n        );\n    }\n\n    public configureMotorPosition(\n        targetPos: number,\n        stiffness: number,\n        damping: number,\n    ) {\n        this.rawSet.jointConfigureMotorPosition(\n            this.handle,\n            this.rawAxis(),\n            targetPos,\n            stiffness,\n            damping,\n        );\n    }\n\n    public configureMotor(\n        targetPos: number,\n        targetVel: number,\n        stiffness: number,\n        damping: number,\n    ) {\n        this.rawSet.jointConfigureMotor(\n            this.handle,\n            this.rawAxis(),\n            targetPos,\n            targetVel,\n            stiffness,\n            damping,\n        );\n    }\n}\n\nexport class FixedImpulseJoint extends ImpulseJoint {}\n\nexport class RopeImpulseJoint extends ImpulseJoint {}\n\nexport class SpringImpulseJoint extends ImpulseJoint {}\n\nexport class PrismaticImpulseJoint extends UnitImpulseJoint {\n    public rawAxis(): RawJointAxis {\n        return RawJointAxis.LinX;\n    }\n}\n\nexport class RevoluteImpulseJoint extends UnitImpulseJoint {\n    public rawAxis(): RawJointAxis {\n        return RawJointAxis.AngX;\n    }\n}\n\n\nexport class JointData {\n    anchor1: Vector;\n    anchor2: Vector;\n    axis: Vector;\n    frame1: Rotation;\n    frame2: Rotation;\n    jointType: JointType;\n    limitsEnabled: boolean;\n    limits: Array<number>;\n    axesMask: JointAxesMask;\n    stiffness: number;\n    damping: number;\n    length: number;\n\n    private constructor() {}\n\n    /**\n     * Creates a new joint descriptor that builds a Fixed joint.\n     *\n     * A fixed joint removes all the degrees of freedom between the affected bodies, ensuring their\n     * anchor and local frames coincide in world-space.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param frame1 - The reference orientation of the joint wrt. the first rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param frame2 - The reference orientation of the joint wrt. the second rigid-body.\n     */\n    public static fixed(\n        anchor1: Vector,\n        frame1: Rotation,\n        anchor2: Vector,\n        frame2: Rotation,\n    ): JointData {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.frame1 = frame1;\n        res.frame2 = frame2;\n        res.jointType = JointType.Fixed;\n        return res;\n    }\n\n    public static spring(\n        rest_length: number,\n        stiffness: number,\n        damping: number,\n        anchor1: Vector,\n        anchor2: Vector,\n    ): JointData {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.length = rest_length;\n        res.stiffness = stiffness;\n        res.damping = damping;\n        res.jointType = JointType.Spring;\n        return res;\n    }\n\n    public static rope(\n        length: number,\n        anchor1: Vector,\n        anchor2: Vector,\n    ): JointData {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.length = length;\n        res.jointType = JointType.Rope;\n        return res;\n    }\n\n    // #if DIM2\n\n    /**\n     * Create a new joint descriptor that builds revolute joints.\n     *\n     * A revolute joint allows three relative rotational degrees of freedom\n     * by preventing any relative translation between the anchors of the\n     * two attached rigid-bodies.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     */\n    public static revolute(anchor1: Vector, anchor2: Vector): JointData {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.jointType = JointType.Revolute;\n        return res;\n    }\n\n    /**\n     * Creates a new joint descriptor that builds a Prismatic joint.\n     *\n     * A prismatic joint removes all the degrees of freedom between the\n     * affected bodies, except for the translation along one axis.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param axis - Axis of the joint, expressed in the local-space of the rigid-bodies it is attached to.\n     */\n    public static prismatic(\n        anchor1: Vector,\n        anchor2: Vector,\n        axis: Vector,\n    ): JointData {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.axis = axis;\n        res.jointType = JointType.Prismatic;\n        return res;\n    }\n\n    // #endif\n\n\n    public intoRaw(): RawGenericJoint {\n        let rawA1 = VectorOps.intoRaw(this.anchor1);\n        let rawA2 = VectorOps.intoRaw(this.anchor2);\n        let rawAx;\n        let result;\n        let limitsEnabled = false;\n        let limitsMin = 0.0;\n        let limitsMax = 0.0;\n\n        switch (this.jointType) {\n            case JointType.Fixed:\n                let rawFra1 = RotationOps.intoRaw(this.frame1);\n                let rawFra2 = RotationOps.intoRaw(this.frame2);\n                result = RawGenericJoint.fixed(rawA1, rawFra1, rawA2, rawFra2);\n                rawFra1.free();\n                rawFra2.free();\n                break;\n            case JointType.Spring:\n                result = RawGenericJoint.spring(\n                    this.length,\n                    this.stiffness,\n                    this.damping,\n                    rawA1,\n                    rawA2,\n                );\n                break;\n            case JointType.Rope:\n                result = RawGenericJoint.rope(this.length, rawA1, rawA2);\n                break;\n            case JointType.Prismatic:\n                rawAx = VectorOps.intoRaw(this.axis);\n\n                if (!!this.limitsEnabled) {\n                    limitsEnabled = true;\n                    limitsMin = this.limits[0];\n                    limitsMax = this.limits[1];\n                }\n\n                // #if DIM2\n                result = RawGenericJoint.prismatic(\n                    rawA1,\n                    rawA2,\n                    rawAx,\n                    limitsEnabled,\n                    limitsMin,\n                    limitsMax,\n                );\n                // #endif\n\n\n                rawAx.free();\n                break;\n            // #if DIM2\n            case JointType.Revolute:\n                result = RawGenericJoint.revolute(rawA1, rawA2);\n                break;\n            // #endif\n        }\n\n        rawA1.free();\n        rawA2.free();\n\n        return result;\n    }\n}\n","/**\n * A rule applied to combine coefficients.\n *\n * Use this when configuring the `ColliderDesc` to specify\n * how friction and restitution coefficient should be combined\n * in a contact.\n */\nexport enum CoefficientCombineRule {\n    Average = 0,\n    Min = 1,\n    Multiply = 2,\n    Max = 3,\n}\n","// #if DIM2\nexport enum FeatureType {\n    Vertex,\n    Face,\n    Unknown,\n}\n// #endif\n\n","import {Vector, VectorOps, Rotation, RotationOps} from \"../math\";\nimport {RawColliderSet, RawShape, RawShapeType} from \"../raw\";\nimport {ShapeContact} from \"./contact\";\nimport {PointProjection} from \"./point\";\nimport {Ray, RayIntersection} from \"./ray\";\nimport {ShapeCastHit} from \"./toi\";\nimport {ColliderHandle} from \"./collider\";\n\nexport abstract class Shape {\n    public abstract intoRaw(): RawShape;\n\n    /**\n     * The concrete type of this shape.\n     */\n    public abstract get type(): ShapeType;\n\n    /**\n     * instant mode without cache\n     */\n    public static fromRaw(\n        rawSet: RawColliderSet,\n        handle: ColliderHandle,\n    ): Shape {\n        const rawType = rawSet.coShapeType(handle);\n\n        let extents: Vector;\n        let borderRadius: number;\n        let vs: Float32Array;\n        let indices: Uint32Array;\n        let halfHeight: number;\n        let radius: number;\n        let normal: Vector;\n\n        switch (rawType) {\n            case RawShapeType.Ball:\n                return new Ball(rawSet.coRadius(handle));\n            case RawShapeType.Cuboid:\n                extents = rawSet.coHalfExtents(handle);\n                // #if DIM2\n                return new Cuboid(extents.x, extents.y);\n                // #endif\n\n\n            case RawShapeType.RoundCuboid:\n                extents = rawSet.coHalfExtents(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n\n                // #if DIM2\n                return new RoundCuboid(extents.x, extents.y, borderRadius);\n                // #endif\n\n\n            case RawShapeType.Capsule:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                return new Capsule(halfHeight, radius);\n            case RawShapeType.Segment:\n                vs = rawSet.coVertices(handle);\n\n                // #if DIM2\n                return new Segment(\n                    VectorOps.new(vs[0], vs[1]),\n                    VectorOps.new(vs[2], vs[3]),\n                );\n                // #endif\n\n\n            case RawShapeType.Polyline:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                return new Polyline(vs, indices);\n            case RawShapeType.Triangle:\n                vs = rawSet.coVertices(handle);\n\n                // #if DIM2\n                return new Triangle(\n                    VectorOps.new(vs[0], vs[1]),\n                    VectorOps.new(vs[2], vs[3]),\n                    VectorOps.new(vs[4], vs[5]),\n                );\n                // #endif\n\n\n            case RawShapeType.RoundTriangle:\n                vs = rawSet.coVertices(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n\n                // #if DIM2\n                return new RoundTriangle(\n                    VectorOps.new(vs[0], vs[1]),\n                    VectorOps.new(vs[2], vs[3]),\n                    VectorOps.new(vs[4], vs[5]),\n                    borderRadius,\n                );\n                // #endif\n\n\n            case RawShapeType.HalfSpace:\n                normal = VectorOps.fromRaw(rawSet.coHalfspaceNormal(handle));\n                return new HalfSpace(normal);\n\n            case RawShapeType.Voxels:\n                const vox_data = rawSet.coVoxelData(handle);\n                const vox_size = rawSet.coVoxelSize(handle);\n                return new Voxels(vox_data, vox_size);\n\n            case RawShapeType.TriMesh:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                const tri_flags = rawSet.coTriMeshFlags(handle);\n                return new TriMesh(vs, indices, tri_flags);\n\n            case RawShapeType.HeightField:\n                const scale = rawSet.coHeightfieldScale(handle);\n                const heights = rawSet.coHeightfieldHeights(handle);\n\n                // #if DIM2\n                return new Heightfield(heights, scale);\n                // #endif\n\n\n            // #if DIM2\n            case RawShapeType.ConvexPolygon:\n                vs = rawSet.coVertices(handle);\n                return new ConvexPolygon(vs, false);\n            case RawShapeType.RoundConvexPolygon:\n                vs = rawSet.coVertices(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                return new RoundConvexPolygon(vs, borderRadius, false);\n            // #endif\n\n\n            default:\n                throw new Error(\"unknown shape type: \" + rawType);\n        }\n    }\n\n    /**\n     * Computes the time of impact between two moving shapes.\n     * @param shapePos1 - The initial position of this sahpe.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shapeVel1 - The velocity of this shape.\n     * @param shape2 - The second moving shape.\n     * @param shapePos2 - The initial position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @param shapeVel2 - The velocity of the second shape.\n     * @param targetDistance − If the shape moves closer to this distance from a collider, a hit\n     *                         will be returned.\n     * @param maxToi - The maximum time when the impact can happen.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast won’t immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that it’s on a path to exit that penetration state.\n     * @returns If the two moving shapes collider at some point along their trajectories, this returns the\n     *  time at which the two shape collider as well as the contact information during the impact. Returns\n     *  `null`if the two shapes never collide along their paths.\n     */\n    public castShape(\n        shapePos1: Vector,\n        shapeRot1: Rotation,\n        shapeVel1: Vector,\n        shape2: Shape,\n        shapePos2: Vector,\n        shapeRot2: Rotation,\n        shapeVel2: Vector,\n        targetDistance: number,\n        maxToi: number,\n        stopAtPenetration: boolean,\n    ): ShapeCastHit | null {\n        let rawPos1 = VectorOps.intoRaw(shapePos1);\n        let rawRot1 = RotationOps.intoRaw(shapeRot1);\n        let rawVel1 = VectorOps.intoRaw(shapeVel1);\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n        let rawVel2 = VectorOps.intoRaw(shapeVel2);\n\n        let rawShape1 = this.intoRaw();\n        let rawShape2 = shape2.intoRaw();\n\n        let result = ShapeCastHit.fromRaw(\n            null,\n            rawShape1.castShape(\n                rawPos1,\n                rawRot1,\n                rawVel1,\n                rawShape2,\n                rawPos2,\n                rawRot2,\n                rawVel2,\n                targetDistance,\n                maxToi,\n                stopAtPenetration,\n            ),\n        );\n\n        rawPos1.free();\n        rawRot1.free();\n        rawVel1.free();\n        rawPos2.free();\n        rawRot2.free();\n        rawVel2.free();\n\n        rawShape1.free();\n        rawShape2.free();\n\n        return result;\n    }\n\n    /**\n     * Tests if this shape intersects another shape.\n     *\n     * @param shapePos1 - The position of this shape.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shape2  - The second shape to test.\n     * @param shapePos2 - The position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @returns `true` if the two shapes intersect, `false` if they don’t.\n     */\n    public intersectsShape(\n        shapePos1: Vector,\n        shapeRot1: Rotation,\n        shape2: Shape,\n        shapePos2: Vector,\n        shapeRot2: Rotation,\n    ): boolean {\n        let rawPos1 = VectorOps.intoRaw(shapePos1);\n        let rawRot1 = RotationOps.intoRaw(shapeRot1);\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n\n        let rawShape1 = this.intoRaw();\n        let rawShape2 = shape2.intoRaw();\n\n        let result = rawShape1.intersectsShape(\n            rawPos1,\n            rawRot1,\n            rawShape2,\n            rawPos2,\n            rawRot2,\n        );\n\n        rawPos1.free();\n        rawRot1.free();\n        rawPos2.free();\n        rawRot2.free();\n\n        rawShape1.free();\n        rawShape2.free();\n\n        return result;\n    }\n\n    /**\n     * Computes one pair of contact points between two shapes.\n     *\n     * @param shapePos1 - The initial position of this sahpe.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shape2 - The second shape.\n     * @param shapePos2 - The initial position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n    contactShape(\n        shapePos1: Vector,\n        shapeRot1: Rotation,\n        shape2: Shape,\n        shapePos2: Vector,\n        shapeRot2: Rotation,\n        prediction: number,\n    ): ShapeContact | null {\n        let rawPos1 = VectorOps.intoRaw(shapePos1);\n        let rawRot1 = RotationOps.intoRaw(shapeRot1);\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n\n        let rawShape1 = this.intoRaw();\n        let rawShape2 = shape2.intoRaw();\n\n        let result = ShapeContact.fromRaw(\n            rawShape1.contactShape(\n                rawPos1,\n                rawRot1,\n                rawShape2,\n                rawPos2,\n                rawRot2,\n                prediction,\n            ),\n        );\n\n        rawPos1.free();\n        rawRot1.free();\n        rawPos2.free();\n        rawRot2.free();\n\n        rawShape1.free();\n        rawShape2.free();\n\n        return result;\n    }\n\n    containsPoint(\n        shapePos: Vector,\n        shapeRot: Rotation,\n        point: Vector,\n    ): boolean {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawPoint = VectorOps.intoRaw(point);\n        let rawShape = this.intoRaw();\n\n        let result = rawShape.containsPoint(rawPos, rawRot, rawPoint);\n\n        rawPos.free();\n        rawRot.free();\n        rawPoint.free();\n        rawShape.free();\n\n        return result;\n    }\n\n    projectPoint(\n        shapePos: Vector,\n        shapeRot: Rotation,\n        point: Vector,\n        solid: boolean,\n    ): PointProjection {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawPoint = VectorOps.intoRaw(point);\n        let rawShape = this.intoRaw();\n\n        let result = PointProjection.fromRaw(\n            rawShape.projectPoint(rawPos, rawRot, rawPoint, solid),\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawPoint.free();\n        rawShape.free();\n\n        return result;\n    }\n\n    intersectsRay(\n        ray: Ray,\n        shapePos: Vector,\n        shapeRot: Rotation,\n        maxToi: number,\n    ): boolean {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawRayOrig = VectorOps.intoRaw(ray.origin);\n        let rawRayDir = VectorOps.intoRaw(ray.dir);\n        let rawShape = this.intoRaw();\n\n        let result = rawShape.intersectsRay(\n            rawPos,\n            rawRot,\n            rawRayOrig,\n            rawRayDir,\n            maxToi,\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawRayOrig.free();\n        rawRayDir.free();\n        rawShape.free();\n\n        return result;\n    }\n\n    castRay(\n        ray: Ray,\n        shapePos: Vector,\n        shapeRot: Rotation,\n        maxToi: number,\n        solid: boolean,\n    ): number {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawRayOrig = VectorOps.intoRaw(ray.origin);\n        let rawRayDir = VectorOps.intoRaw(ray.dir);\n        let rawShape = this.intoRaw();\n\n        let result = rawShape.castRay(\n            rawPos,\n            rawRot,\n            rawRayOrig,\n            rawRayDir,\n            maxToi,\n            solid,\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawRayOrig.free();\n        rawRayDir.free();\n        rawShape.free();\n\n        return result;\n    }\n\n    castRayAndGetNormal(\n        ray: Ray,\n        shapePos: Vector,\n        shapeRot: Rotation,\n        maxToi: number,\n        solid: boolean,\n    ): RayIntersection {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawRayOrig = VectorOps.intoRaw(ray.origin);\n        let rawRayDir = VectorOps.intoRaw(ray.dir);\n        let rawShape = this.intoRaw();\n\n        let result = RayIntersection.fromRaw(\n            rawShape.castRayAndGetNormal(\n                rawPos,\n                rawRot,\n                rawRayOrig,\n                rawRayDir,\n                maxToi,\n                solid,\n            ),\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawRayOrig.free();\n        rawRayDir.free();\n        rawShape.free();\n\n        return result;\n    }\n}\n\n// #if DIM2\n/**\n * An enumeration representing the type of a shape.\n */\nexport enum ShapeType {\n    Ball = 0,\n    Cuboid = 1,\n    Capsule = 2,\n    Segment = 3,\n    Polyline = 4,\n    Triangle = 5,\n    TriMesh = 6,\n    HeightField = 7,\n    // Compound = 8,\n    ConvexPolygon = 9,\n    RoundCuboid = 10,\n    RoundTriangle = 11,\n    RoundConvexPolygon = 12,\n    HalfSpace = 13,\n    Voxels = 14,\n}\n\n// #endif\n\n\n// NOTE: this **must** match the TriMeshFlags on the rust side.\n/**\n * Flags controlling the behavior of the triangle mesh creation and of some\n * operations involving triangle meshes.\n */\nexport enum TriMeshFlags {\n    // NOTE: these two flags are not really useful in JS.\n    //\n    // /**\n    //  * If set, the half-edge topology of the trimesh will be computed if possible.\n    //  */\n    // HALF_EDGE_TOPOLOGY = 0b0000_0001,\n    // /** If set, the half-edge topology and connected components of the trimesh will be computed if possible.\n    //  *\n    //  * Because of the way it is currently implemented, connected components can only be computed on\n    //  * a mesh where the half-edge topology computation succeeds. It will no longer be the case in the\n    //  * future once we decouple the computations.\n    //  */\n    // CONNECTED_COMPONENTS = 0b0000_0010,\n    /**\n     * If set, any triangle that results in a failing half-hedge topology computation will be deleted.\n     */\n    DELETE_BAD_TOPOLOGY_TRIANGLES = 0b0000_0100,\n    /**\n     * If set, the trimesh will be assumed to be oriented (with outward normals).\n     *\n     * The pseudo-normals of its vertices and edges will be computed.\n     */\n    ORIENTED = 0b0000_1000,\n    /**\n     * If set, the duplicate vertices of the trimesh will be merged.\n     *\n     * Two vertices with the exact same coordinates will share the same entry on the\n     * vertex buffer and the index buffer is adjusted accordingly.\n     */\n    MERGE_DUPLICATE_VERTICES = 0b0001_0000,\n    /**\n     * If set, the triangles sharing two vertices with identical index values will be removed.\n     *\n     * Because of the way it is currently implemented, this methods implies that duplicate\n     * vertices will be merged. It will no longer be the case in the future once we decouple\n     * the computations.\n     */\n    DELETE_DEGENERATE_TRIANGLES = 0b0010_0000,\n    /**\n     * If set, two triangles sharing three vertices with identical index values (in any order)\n     * will be removed.\n     *\n     * Because of the way it is currently implemented, this methods implies that duplicate\n     * vertices will be merged. It will no longer be the case in the future once we decouple\n     * the computations.\n     */\n    DELETE_DUPLICATE_TRIANGLES = 0b0100_0000,\n    /**\n     * If set, a special treatment will be applied to contact manifold calculation to eliminate\n     * or fix contacts normals that could lead to incorrect bumps in physics simulation\n     * (especially on flat surfaces).\n     *\n     * This is achieved by taking into account adjacent triangle normals when computing contact\n     * points for a given triangle.\n     *\n     * /!\\ NOT SUPPORTED IN THE 2D VERSION OF RAPIER.\n     */\n    FIX_INTERNAL_EDGES = 0b1000_0000 | TriMeshFlags.MERGE_DUPLICATE_VERTICES,\n}\n\n/**\n * A shape that is a sphere in 3D and a circle in 2D.\n */\nexport class Ball extends Shape {\n    readonly type = ShapeType.Ball;\n\n    /**\n     * The balls radius.\n     */\n    radius: number;\n\n    /**\n     * Creates a new ball with the given radius.\n     * @param radius - The balls radius.\n     */\n    constructor(radius: number) {\n        super();\n        this.radius = radius;\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.ball(this.radius);\n    }\n}\n\nexport class HalfSpace extends Shape {\n    readonly type = ShapeType.HalfSpace;\n\n    /**\n     * The outward normal of the half-space.\n     */\n    normal: Vector;\n\n    /**\n     * Creates a new halfspace delimited by an infinite plane.\n     *\n     * @param normal - The outward normal of the plane.\n     */\n    constructor(normal: Vector) {\n        super();\n        this.normal = normal;\n    }\n\n    public intoRaw(): RawShape {\n        let n = VectorOps.intoRaw(this.normal);\n        let result = RawShape.halfspace(n);\n        n.free();\n        return result;\n    }\n}\n\n/**\n * A shape that is a box in 3D and a rectangle in 2D.\n */\nexport class Cuboid extends Shape {\n    readonly type = ShapeType.Cuboid;\n\n    /**\n     * The half extent of the cuboid along each coordinate axis.\n     */\n    halfExtents: Vector;\n\n    // #if DIM2\n    /**\n     * Creates a new 2D rectangle.\n     * @param hx - The half width of the rectangle.\n     * @param hy - The helf height of the rectangle.\n     */\n    constructor(hx: number, hy: number) {\n        super();\n        this.halfExtents = VectorOps.new(hx, hy);\n    }\n\n    // #endif\n\n\n    public intoRaw(): RawShape {\n        // #if DIM2\n        return RawShape.cuboid(this.halfExtents.x, this.halfExtents.y);\n        // #endif\n\n    }\n}\n\n/**\n * A shape that is a box in 3D and a rectangle in 2D, with round corners.\n */\nexport class RoundCuboid extends Shape {\n    readonly type = ShapeType.RoundCuboid;\n\n    /**\n     * The half extent of the cuboid along each coordinate axis.\n     */\n    halfExtents: Vector;\n\n    /**\n     * The radius of the cuboid's round border.\n     */\n    borderRadius: number;\n\n    // #if DIM2\n    /**\n     * Creates a new 2D rectangle.\n     * @param hx - The half width of the rectangle.\n     * @param hy - The helf height of the rectangle.\n     * @param borderRadius - The radius of the borders of this cuboid. This will\n     *   effectively increase the half-extents of the cuboid by this radius.\n     */\n    constructor(hx: number, hy: number, borderRadius: number) {\n        super();\n        this.halfExtents = VectorOps.new(hx, hy);\n        this.borderRadius = borderRadius;\n    }\n\n    // #endif\n\n\n    public intoRaw(): RawShape {\n        // #if DIM2\n        return RawShape.roundCuboid(\n            this.halfExtents.x,\n            this.halfExtents.y,\n            this.borderRadius,\n        );\n        // #endif\n\n    }\n}\n\n/**\n * A shape that is a capsule.\n */\nexport class Capsule extends Shape {\n    readonly type = ShapeType.Capsule;\n\n    /**\n     * The radius of the capsule's basis.\n     */\n    radius: number;\n\n    /**\n     * The capsule's half height, along the `y` axis.\n     */\n    halfHeight: number;\n\n    /**\n     * Creates a new capsule with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     */\n    constructor(halfHeight: number, radius: number) {\n        super();\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.capsule(this.halfHeight, this.radius);\n    }\n}\n\n/**\n * A shape that is a segment.\n */\nexport class Segment extends Shape {\n    readonly type = ShapeType.Segment;\n\n    /**\n     * The first point of the segment.\n     */\n    a: Vector;\n\n    /**\n     * The second point of the segment.\n     */\n    b: Vector;\n\n    /**\n     * Creates a new segment shape.\n     * @param a - The first point of the segment.\n     * @param b - The second point of the segment.\n     */\n    constructor(a: Vector, b: Vector) {\n        super();\n        this.a = a;\n        this.b = b;\n    }\n\n    public intoRaw(): RawShape {\n        let ra = VectorOps.intoRaw(this.a);\n        let rb = VectorOps.intoRaw(this.b);\n        let result = RawShape.segment(ra, rb);\n        ra.free();\n        rb.free();\n        return result;\n    }\n}\n\n/**\n * A shape that is a segment.\n */\nexport class Triangle extends Shape {\n    readonly type = ShapeType.Triangle;\n\n    /**\n     * The first point of the triangle.\n     */\n    a: Vector;\n\n    /**\n     * The second point of the triangle.\n     */\n    b: Vector;\n\n    /**\n     * The second point of the triangle.\n     */\n    c: Vector;\n\n    /**\n     * Creates a new triangle shape.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     */\n    constructor(a: Vector, b: Vector, c: Vector) {\n        super();\n        this.a = a;\n        this.b = b;\n        this.c = c;\n    }\n\n    public intoRaw(): RawShape {\n        let ra = VectorOps.intoRaw(this.a);\n        let rb = VectorOps.intoRaw(this.b);\n        let rc = VectorOps.intoRaw(this.c);\n        let result = RawShape.triangle(ra, rb, rc);\n        ra.free();\n        rb.free();\n        rc.free();\n        return result;\n    }\n}\n\n/**\n * A shape that is a triangle with round borders and a non-zero thickness.\n */\nexport class RoundTriangle extends Shape {\n    readonly type = ShapeType.RoundTriangle;\n\n    /**\n     * The first point of the triangle.\n     */\n    a: Vector;\n\n    /**\n     * The second point of the triangle.\n     */\n    b: Vector;\n\n    /**\n     * The second point of the triangle.\n     */\n    c: Vector;\n\n    /**\n     * The radius of the triangles's rounded edges and vertices.\n     * In 3D, this is also equal to half the thickness of the round triangle.\n     */\n    borderRadius: number;\n\n    /**\n     * Creates a new triangle shape with round corners.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     * @param borderRadius - The radius of the borders of this triangle. In 3D,\n     *   this is also equal to half the thickness of the triangle.\n     */\n    constructor(a: Vector, b: Vector, c: Vector, borderRadius: number) {\n        super();\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.borderRadius = borderRadius;\n    }\n\n    public intoRaw(): RawShape {\n        let ra = VectorOps.intoRaw(this.a);\n        let rb = VectorOps.intoRaw(this.b);\n        let rc = VectorOps.intoRaw(this.c);\n        let result = RawShape.roundTriangle(ra, rb, rc, this.borderRadius);\n        ra.free();\n        rb.free();\n        rc.free();\n        return result;\n    }\n}\n\n/**\n * A shape that is a triangle mesh.\n */\nexport class Polyline extends Shape {\n    readonly type = ShapeType.Polyline;\n\n    /**\n     * The vertices of the polyline.\n     */\n    vertices: Float32Array;\n\n    /**\n     * The indices of the segments.\n     */\n    indices: Uint32Array;\n\n    /**\n     * Creates a new polyline shape.\n     *\n     * @param vertices - The coordinates of the polyline's vertices.\n     * @param indices - The indices of the polyline's segments. If this is `null` or not provided, then\n     *    the vertices are assumed to form a line strip.\n     */\n    constructor(vertices: Float32Array, indices?: Uint32Array) {\n        super();\n        this.vertices = vertices;\n        this.indices = indices ?? new Uint32Array(0);\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.polyline(this.vertices, this.indices);\n    }\n}\n\n/**\n * A shape made of voxels.\n */\nexport class Voxels extends Shape {\n    readonly type = ShapeType.Voxels;\n\n    /**\n     * The points or grid coordinates used to initialize the voxels.\n     */\n    data: Float32Array | Int32Array;\n\n    /**\n     * The dimensions of each voxel.\n     */\n    voxelSize: Vector;\n\n    /**\n     * Creates a new shape made of voxels.\n     *\n     * @param data - Defines the set of voxels. If this is a `Int32Array` then\n     *               each voxel is defined from its (signed) grid coordinates,\n     *               with 3 (resp 2) contiguous integers per voxel in 3D (resp 2D).\n     *               If this is a `Float32Array`, each voxel will be such that\n     *               they contain at least one point from this array (where each\n     *               point is defined from 3 (resp 2) contiguous numbers per point\n     *               in 3D (resp 2D).\n     * @param voxelSize - The size of each voxel.\n     */\n    constructor(data: Float32Array | Int32Array, voxelSize: Vector) {\n        super();\n        this.data = data;\n        this.voxelSize = voxelSize;\n    }\n\n    public intoRaw(): RawShape {\n        let voxelSize = VectorOps.intoRaw(this.voxelSize);\n\n        let result;\n        if (this.data instanceof Int32Array) {\n            result = RawShape.voxels(voxelSize, this.data);\n        } else {\n            result = RawShape.voxelsFromPoints(voxelSize, this.data);\n        }\n\n        voxelSize.free();\n        return result;\n    }\n}\n\n/**\n * A shape that is a triangle mesh.\n */\nexport class TriMesh extends Shape {\n    readonly type = ShapeType.TriMesh;\n\n    /**\n     * The vertices of the triangle mesh.\n     */\n    vertices: Float32Array;\n\n    /**\n     * The indices of the triangles.\n     */\n    indices: Uint32Array;\n\n    /**\n     * The triangle mesh flags.\n     */\n    flags: TriMeshFlags;\n\n    /**\n     * Creates a new triangle mesh shape.\n     *\n     * @param vertices - The coordinates of the triangle mesh's vertices.\n     * @param indices - The indices of the triangle mesh's triangles.\n     */\n    constructor(\n        vertices: Float32Array,\n        indices: Uint32Array,\n        flags?: TriMeshFlags,\n    ) {\n        super();\n        this.vertices = vertices;\n        this.indices = indices;\n        this.flags = flags;\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.trimesh(this.vertices, this.indices, this.flags);\n    }\n}\n\n// #if DIM2\n/**\n * A shape that is a convex polygon.\n */\nexport class ConvexPolygon extends Shape {\n    readonly type = ShapeType.ConvexPolygon;\n\n    /**\n     * The vertices of the convex polygon.\n     */\n    vertices: Float32Array;\n\n    /**\n     * Do we want to assume the vertices already form a convex hull?\n     */\n    skipConvexHullComputation: boolean;\n\n    /**\n     * Creates a new convex polygon shape.\n     *\n     * @param vertices - The coordinates of the convex polygon's vertices.\n     * @param skipConvexHullComputation - If set to `true`, the input points will\n     *   be assumed to form a convex polyline and no convex-hull computation will\n     *   be done automatically.\n     */\n    constructor(vertices: Float32Array, skipConvexHullComputation: boolean) {\n        super();\n        this.vertices = vertices;\n        this.skipConvexHullComputation = !!skipConvexHullComputation;\n    }\n\n    public intoRaw(): RawShape {\n        if (this.skipConvexHullComputation) {\n            return RawShape.convexPolyline(this.vertices);\n        } else {\n            return RawShape.convexHull(this.vertices);\n        }\n    }\n}\n\n/**\n * A shape that is a convex polygon.\n */\nexport class RoundConvexPolygon extends Shape {\n    readonly type = ShapeType.RoundConvexPolygon;\n\n    /**\n     * The vertices of the convex polygon.\n     */\n    vertices: Float32Array;\n\n    /**\n     * Do we want to assume the vertices already form a convex hull?\n     */\n    skipConvexHullComputation: boolean;\n\n    /**\n     * The radius of the convex polygon's rounded edges and vertices.\n     */\n    borderRadius: number;\n\n    /**\n     * Creates a new convex polygon shape.\n     *\n     * @param vertices - The coordinates of the convex polygon's vertices.\n     * @param borderRadius - The radius of the borders of this convex polygon.\n     * @param skipConvexHullComputation - If set to `true`, the input points will\n     *   be assumed to form a convex polyline and no convex-hull computation will\n     *   be done automatically.\n     */\n    constructor(\n        vertices: Float32Array,\n        borderRadius: number,\n        skipConvexHullComputation: boolean,\n    ) {\n        super();\n        this.vertices = vertices;\n        this.borderRadius = borderRadius;\n        this.skipConvexHullComputation = !!skipConvexHullComputation;\n    }\n\n    public intoRaw(): RawShape {\n        if (this.skipConvexHullComputation) {\n            return RawShape.roundConvexPolyline(\n                this.vertices,\n                this.borderRadius,\n            );\n        } else {\n            return RawShape.roundConvexHull(this.vertices, this.borderRadius);\n        }\n    }\n}\n\n/**\n * A shape that is a heightfield.\n */\nexport class Heightfield extends Shape {\n    readonly type = ShapeType.HeightField;\n\n    /**\n     * The heights of the heightfield, along its local `y` axis.\n     */\n    heights: Float32Array;\n\n    /**\n     * The heightfield's length along its local `x` axis.\n     */\n    scale: Vector;\n\n    /**\n     * Creates a new heightfield shape.\n     *\n     * @param heights - The heights of the heightfield, along its local `y` axis.\n     * @param scale - The scale factor applied to the heightfield.\n     */\n    constructor(heights: Float32Array, scale: Vector) {\n        super();\n        this.heights = heights;\n        this.scale = scale;\n    }\n\n    public intoRaw(): RawShape {\n        let rawScale = VectorOps.intoRaw(this.scale);\n        let rawShape = RawShape.heightfield(this.heights, rawScale);\n        rawScale.free();\n        return rawShape;\n    }\n}\n\n// #endif\n\n","import {RawPidController} from \"../raw\";\nimport {Rotation, RotationOps, Vector, VectorOps} from \"../math\";\nimport {Collider, ColliderSet, InteractionGroups, Shape} from \"../geometry\";\nimport {QueryFilterFlags, World} from \"../pipeline\";\nimport {IntegrationParameters, RigidBody, RigidBodySet} from \"../dynamics\";\n\n// TODO: unify with the JointAxesMask\n/**\n * An enum representing the possible joint axes controlled by a PidController.\n * They can be ORed together, like:\n * PidAxesMask.LinX || PidAxesMask.LinY\n * to get a pid controller that only constraints the translational X and Y axes.\n *\n * Possible axes are:\n *\n * - `X`: X translation axis\n * - `Y`: Y translation axis\n * - `Z`: Z translation axis\n * - `AngX`: X angular rotation axis (3D only)\n * - `AngY`: Y angular rotation axis (3D only)\n * - `AngZ`: Z angular rotation axis\n */\nexport enum PidAxesMask {\n    None = 0,\n    LinX = 1 << 0,\n    LinY = 1 << 1,\n    LinZ = 1 << 2,\n    AngZ = 1 << 5,\n    // #if DIM2\n    AllLin = PidAxesMask.LinX | PidAxesMask.LinY,\n    AllAng = PidAxesMask.AngZ,\n    // #endif\n    All = PidAxesMask.AllLin | PidAxesMask.AllAng,\n}\n\n/**\n * A controller for controlling dynamic bodies using the\n * Proportional-Integral-Derivative correction model.\n */\nexport class PidController {\n    private raw: RawPidController;\n\n    private params: IntegrationParameters;\n    private bodies: RigidBodySet;\n\n    constructor(\n        params: IntegrationParameters,\n        bodies: RigidBodySet,\n        kp: number,\n        ki: number,\n        kd: number,\n        axes: PidAxesMask,\n    ) {\n        this.params = params;\n        this.bodies = bodies;\n        this.raw = new RawPidController(kp, ki, kd, axes);\n    }\n\n    /** @internal */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n\n        this.raw = undefined;\n    }\n\n    public setKp(kp: number, axes: PidAxesMask) {\n        this.raw.set_kp(kp, axes);\n    }\n\n    public setKi(ki: number, axes: PidAxesMask) {\n        this.raw.set_kp(ki, axes);\n    }\n\n    public setKd(kd: number, axes: PidAxesMask) {\n        this.raw.set_kp(kd, axes);\n    }\n\n    public setAxes(axes: PidAxesMask) {\n        this.raw.set_axes_mask(axes);\n    }\n\n    public resetIntegrals() {\n        this.raw.reset_integrals();\n    }\n\n    public applyLinearCorrection(\n        body: RigidBody,\n        targetPosition: Vector,\n        targetLinvel: Vector,\n    ) {\n        let rawPos = VectorOps.intoRaw(targetPosition);\n        let rawVel = VectorOps.intoRaw(targetLinvel);\n        this.raw.apply_linear_correction(\n            this.params.dt,\n            this.bodies.raw,\n            body.handle,\n            rawPos,\n            rawVel,\n        );\n        rawPos.free();\n        rawVel.free();\n    }\n\n    // #if DIM2\n    public applyAngularCorrection(\n        body: RigidBody,\n        targetRotation: number,\n        targetAngVel: number,\n    ) {\n        this.raw.apply_angular_correction(\n            this.params.dt,\n            this.bodies.raw,\n            body.handle,\n            targetRotation,\n            targetAngVel,\n        );\n    }\n    // #endif\n\n\n    public linearCorrection(\n        body: RigidBody,\n        targetPosition: Vector,\n        targetLinvel: Vector,\n    ): Vector {\n        let rawPos = VectorOps.intoRaw(targetPosition);\n        let rawVel = VectorOps.intoRaw(targetLinvel);\n        let correction = this.raw.linear_correction(\n            this.params.dt,\n            this.bodies.raw,\n            body.handle,\n            rawPos,\n            rawVel,\n        );\n        rawPos.free();\n        rawVel.free();\n\n        return VectorOps.fromRaw(correction);\n    }\n\n    // #if DIM2\n    public angularCorrection(\n        body: RigidBody,\n        targetRotation: number,\n        targetAngVel: number,\n    ): number {\n        return this.raw.angular_correction(\n            this.params.dt,\n            this.bodies.raw,\n            body.handle,\n            targetRotation,\n            targetAngVel,\n        );\n    }\n    // #endif\n\n}\n","import {RawContactForceEvent, RawEventQueue} from \"../raw\";\nimport {RigidBodyHandle} from \"../dynamics\";\nimport {Collider, ColliderHandle} from \"../geometry\";\nimport {Vector, VectorOps} from \"../math\";\n\n/**\n * Flags indicating what events are enabled for colliders.\n */\nexport enum ActiveEvents {\n    NONE = 0,\n    /**\n     * Enable collision events.\n     */\n    COLLISION_EVENTS = 0b0001,\n    /**\n     * Enable contact force events.\n     */\n    CONTACT_FORCE_EVENTS = 0b0010,\n}\n\n/**\n * Event occurring when the sum of the magnitudes of the\n * contact forces between two colliders exceed a threshold.\n *\n * This object should **not** be stored anywhere. Its properties can only be\n * read from within the closure given to `EventHandler.drainContactForceEvents`.\n */\nexport class TempContactForceEvent {\n    raw: RawContactForceEvent;\n\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    /**\n     * The first collider involved in the contact.\n     */\n    public collider1(): ColliderHandle {\n        return this.raw.collider1();\n    }\n\n    /**\n     * The second collider involved in the contact.\n     */\n    public collider2(): ColliderHandle {\n        return this.raw.collider2();\n    }\n\n    /**\n     * The sum of all the forces between the two colliders.\n     */\n    public totalForce(): Vector {\n        return VectorOps.fromRaw(this.raw.total_force());\n    }\n\n    /**\n     * The sum of the magnitudes of each force between the two colliders.\n     *\n     * Note that this is **not** the same as the magnitude of `self.total_force`.\n     * Here we are summing the magnitude of all the forces, instead of taking\n     * the magnitude of their sum.\n     */\n    public totalForceMagnitude(): number {\n        return this.raw.total_force_magnitude();\n    }\n\n    /**\n     * The world-space (unit) direction of the force with strongest magnitude.\n     */\n    public maxForceDirection(): Vector {\n        return VectorOps.fromRaw(this.raw.max_force_direction());\n    }\n\n    /**\n     * The magnitude of the largest force at a contact point of this contact pair.\n     */\n    public maxForceMagnitude(): number {\n        return this.raw.max_force_magnitude();\n    }\n}\n\n/**\n * A structure responsible for collecting events generated\n * by the physics engine.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `eventQueue.free()`\n * once you are done using it.\n */\nexport class EventQueue {\n    raw: RawEventQueue;\n\n    /**\n     * Creates a new event collector.\n     *\n     * @param autoDrain -setting this to `true` is strongly recommended. If true, the collector will\n     * be automatically drained before each `world.step(collector)`. If false, the collector will\n     * keep all events in memory unless it is manually drained/cleared; this may lead to unbounded use of\n     * RAM if no drain is performed.\n     */\n    constructor(autoDrain: boolean, raw?: RawEventQueue) {\n        this.raw = raw || new RawEventQueue(autoDrain);\n    }\n\n    /**\n     * Release the WASM memory occupied by this event-queue.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    /**\n     * Applies the given javascript closure on each collision event of this collector, then clear\n     * the internal collision event buffer.\n     *\n     * @param f - JavaScript closure applied to each collision event. The\n     * closure must take three arguments: two integers representing the handles of the colliders\n     * involved in the collision, and a boolean indicating if the collision started (true) or stopped\n     * (false).\n     */\n    public drainCollisionEvents(\n        f: (\n            handle1: ColliderHandle,\n            handle2: ColliderHandle,\n            started: boolean,\n        ) => void,\n    ) {\n        this.raw.drainCollisionEvents(f);\n    }\n\n    /**\n     * Applies the given javascript closure on each contact force event of this collector, then clear\n     * the internal collision event buffer.\n     *\n     * @param f - JavaScript closure applied to each collision event. The\n     *            closure must take one `TempContactForceEvent` argument.\n     */\n    public drainContactForceEvents(f: (event: TempContactForceEvent) => void) {\n        let event = new TempContactForceEvent();\n        this.raw.drainContactForceEvents((raw: RawContactForceEvent) => {\n            event.raw = raw;\n            f(event);\n            event.free();\n        });\n    }\n\n    /**\n     * Removes all events contained by this collector\n     */\n    public clear() {\n        this.raw.clear();\n    }\n}\n","import {RigidBodyHandle} from \"../dynamics\";\nimport {ColliderHandle} from \"../geometry\";\n\nexport enum ActiveHooks {\n    NONE = 0,\n    FILTER_CONTACT_PAIRS = 0b0001,\n    FILTER_INTERSECTION_PAIRS = 0b0010,\n    // MODIFY_SOLVER_CONTACTS = 0b0100, /* Not supported yet in JS. */\n}\n\nexport enum SolverFlags {\n    EMPTY = 0b000,\n    COMPUTE_IMPULSE = 0b001,\n}\n\nexport interface PhysicsHooks {\n    /**\n     * Function that determines if contacts computation should happen between two colliders, and how the\n     * constraints solver should behave for these contacts.\n     *\n     * This will only be executed and taken into account if at least one of the involved colliders contains the\n     * `ActiveHooks.FILTER_CONTACT_PAIR` flag in its active hooks.\n     *\n     * @param collider1 − Handle of the first collider involved in the potential contact.\n     * @param collider2 − Handle of the second collider involved in the potential contact.\n     * @param body1 − Handle of the first body involved in the potential contact.\n     * @param body2 − Handle of the second body involved in the potential contact.\n     */\n    filterContactPair(\n        collider1: ColliderHandle,\n        collider2: ColliderHandle,\n        body1: RigidBodyHandle,\n        body2: RigidBodyHandle,\n    ): SolverFlags | null;\n\n    /**\n     * Function that determines if intersection computation should happen between two colliders (where at least\n     * one is a sensor).\n     *\n     * This will only be executed and taken into account if `one of the involved colliders contains the\n     * `ActiveHooks.FILTER_INTERSECTION_PAIR` flag in its active hooks.\n     *\n     * @param collider1 − Handle of the first collider involved in the potential contact.\n     * @param collider2 − Handle of the second collider involved in the potential contact.\n     * @param body1 − Handle of the first body involved in the potential contact.\n     * @param body2 − Handle of the second body involved in the potential contact.\n     */\n    filterIntersectionPair(\n        collider1: ColliderHandle,\n        collider2: ColliderHandle,\n        body1: RigidBodyHandle,\n        body2: RigidBodyHandle,\n    ): boolean;\n}\n","import {RawRayColliderIntersection} from \"../raw\";\nimport {\n    ColliderHandle,\n    ColliderSet,\n    InteractionGroups,\n    PointColliderProjection,\n    Ray,\n    RayColliderIntersection,\n    RayColliderHit,\n    Shape,\n    ColliderShapeCastHit,\n} from \"../geometry\";\nimport {IslandManager, RigidBodyHandle, RigidBodySet} from \"../dynamics\";\nimport {Rotation, RotationOps, Vector, VectorOps} from \"../math\";\n\n// NOTE: must match the bits in the QueryFilterFlags on the Rust side.\n/**\n * Flags for excluding whole sets of colliders from a scene query.\n */\nexport enum QueryFilterFlags {\n    /**\n     * Exclude from the query any collider attached to a fixed rigid-body and colliders with no rigid-body attached.\n     */\n    EXCLUDE_FIXED = 0b0000_0001,\n    /**\n     * Exclude from the query any collider attached to a dynamic rigid-body.\n     */\n    EXCLUDE_KINEMATIC = 0b0000_0010,\n    /**\n     * Exclude from the query any collider attached to a kinematic rigid-body.\n     */\n    EXCLUDE_DYNAMIC = 0b0000_0100,\n    /**\n     * Exclude from the query any collider that is a sensor.\n     */\n    EXCLUDE_SENSORS = 0b0000_1000,\n    /**\n     * Exclude from the query any collider that is not a sensor.\n     */\n    EXCLUDE_SOLIDS = 0b0001_0000,\n    /**\n     * Excludes all colliders not attached to a dynamic rigid-body.\n     */\n    ONLY_DYNAMIC = QueryFilterFlags.EXCLUDE_FIXED |\n        QueryFilterFlags.EXCLUDE_KINEMATIC,\n    /**\n     * Excludes all colliders not attached to a kinematic rigid-body.\n     */\n    ONLY_KINEMATIC = QueryFilterFlags.EXCLUDE_DYNAMIC |\n        QueryFilterFlags.EXCLUDE_FIXED,\n    /**\n     * Exclude all colliders attached to a non-fixed rigid-body\n     * (this will not exclude colliders not attached to any rigid-body).\n     */\n    ONLY_FIXED = QueryFilterFlags.EXCLUDE_DYNAMIC |\n        QueryFilterFlags.EXCLUDE_KINEMATIC,\n}\n","import {RawColliderSet} from \"../raw\";\nimport {Rotation, RotationOps, Vector, VectorOps} from \"../math\";\nimport {\n    CoefficientCombineRule,\n    RigidBody,\n    RigidBodyHandle,\n    RigidBodySet,\n} from \"../dynamics\";\nimport {ActiveHooks, ActiveEvents} from \"../pipeline\";\nimport {InteractionGroups} from \"./interaction_groups\";\nimport {\n    Shape,\n    Cuboid,\n    Ball,\n    ShapeType,\n    Capsule,\n    Voxels,\n    TriMesh,\n    Polyline,\n    Heightfield,\n    Segment,\n    Triangle,\n    RoundTriangle,\n    RoundCuboid,\n    HalfSpace,\n    TriMeshFlags,\n    // #if DIM2\n    ConvexPolygon,\n    RoundConvexPolygon,\n    // #endif\n} from \"./shape\";\nimport {Ray, RayIntersection} from \"./ray\";\nimport {PointProjection} from \"./point\";\nimport {ColliderShapeCastHit, ShapeCastHit} from \"./toi\";\nimport {ShapeContact} from \"./contact\";\nimport {ColliderSet} from \"./collider_set\";\n\n/**\n * Flags affecting whether collision-detection happens between two colliders\n * depending on the type of rigid-bodies they are attached to.\n */\nexport enum ActiveCollisionTypes {\n    /**\n     * Enable collision-detection between a collider attached to a dynamic body\n     * and another collider attached to a dynamic body.\n     */\n    DYNAMIC_DYNAMIC = 0b0000_0000_0000_0001,\n    /**\n     * Enable collision-detection between a collider attached to a dynamic body\n     * and another collider attached to a kinematic body.\n     */\n    DYNAMIC_KINEMATIC = 0b0000_0000_0000_1100,\n    /**\n     * Enable collision-detection between a collider attached to a dynamic body\n     * and another collider attached to a fixed body (or not attached to any body).\n     */\n    DYNAMIC_FIXED = 0b0000_0000_0000_0010,\n    /**\n     * Enable collision-detection between a collider attached to a kinematic body\n     * and another collider attached to a kinematic body.\n     */\n    KINEMATIC_KINEMATIC = 0b1100_1100_0000_0000,\n\n    /**\n     * Enable collision-detection between a collider attached to a kinematic body\n     * and another collider attached to a fixed body (or not attached to any body).\n     */\n    KINEMATIC_FIXED = 0b0010_0010_0000_0000,\n\n    /**\n     * Enable collision-detection between a collider attached to a fixed body (or\n     * not attached to any body) and another collider attached to a fixed body (or\n     * not attached to any body).\n     */\n    FIXED_FIXED = 0b0000_0000_0010_0000,\n    /**\n     * The default active collision types, enabling collisions between a dynamic body\n     * and another body of any type, but not enabling collisions between two non-dynamic bodies.\n     */\n    DEFAULT = DYNAMIC_KINEMATIC | DYNAMIC_DYNAMIC | DYNAMIC_FIXED,\n    /**\n     * Enable collisions between any kind of rigid-bodies (including between two non-dynamic bodies).\n     */\n    ALL = DYNAMIC_KINEMATIC |\n        DYNAMIC_DYNAMIC |\n        DYNAMIC_FIXED |\n        KINEMATIC_KINEMATIC |\n        KINEMATIC_FIXED |\n        KINEMATIC_KINEMATIC,\n}\n\n/**\n * The integer identifier of a collider added to a `ColliderSet`.\n */\nexport type ColliderHandle = number;\n\n/**\n * A geometric entity that can be attached to a body so it can be affected\n * by contacts and proximity queries.\n */\nexport class Collider {\n    private colliderSet: ColliderSet; // The Collider won't need to free this.\n    readonly handle: ColliderHandle;\n    private _shape: Shape; // TODO: deprecate/remove this since it isn’t a reliable way of getting the latest shape properties.\n    private _parent: RigidBody | null;\n\n    constructor(\n        colliderSet: ColliderSet,\n        handle: ColliderHandle,\n        parent: RigidBody | null,\n        shape?: Shape,\n    ) {\n        this.colliderSet = colliderSet;\n        this.handle = handle;\n        this._parent = parent;\n        this._shape = shape;\n    }\n\n    /** @internal */\n    public finalizeDeserialization(bodies: RigidBodySet) {\n        if (this.handle != null) {\n            this._parent = bodies.get(\n                this.colliderSet.raw.coParent(this.handle),\n            );\n        }\n    }\n\n    private ensureShapeIsCached() {\n        if (!this._shape)\n            this._shape = Shape.fromRaw(this.colliderSet.raw, this.handle);\n    }\n\n    /**\n     * The shape of this collider.\n     */\n    public get shape(): Shape {\n        this.ensureShapeIsCached();\n        return this._shape;\n    }\n\n    /**\n     * Set the internal cached JS shape to null.\n     *\n     * This can be useful if you want to free some memory (assuming you are not\n     * holding any other references to the shape object), or in order to force\n     * the recalculation of the JS shape (the next time the `shape` getter is\n     * accessed) from the WASM source of truth.\n     */\n    public clearShapeCache() {\n        this._shape = null;\n    }\n\n    /**\n     * Checks if this collider is still valid (i.e. that it has\n     * not been deleted from the collider set yet).\n     */\n    public isValid(): boolean {\n        return this.colliderSet.raw.contains(this.handle);\n    }\n\n    /**\n     * The world-space translation of this collider.\n     */\n    public translation(): Vector {\n        return VectorOps.fromRaw(\n            this.colliderSet.raw.coTranslation(this.handle),\n        );\n    }\n\n    /**\n     * The translation of this collider relative to its parent rigid-body.\n     *\n     * Returns `null` if the collider doesn’t have a parent rigid-body.\n     */\n    public translationWrtParent(): Vector | null {\n        return VectorOps.fromRaw(\n            this.colliderSet.raw.coTranslationWrtParent(this.handle),\n        );\n    }\n\n    /**\n     * The world-space orientation of this collider.\n     */\n    public rotation(): Rotation {\n        return RotationOps.fromRaw(\n            this.colliderSet.raw.coRotation(this.handle),\n        );\n    }\n\n    /**\n     * The orientation of this collider relative to its parent rigid-body.\n     *\n     * Returns `null` if the collider doesn’t have a parent rigid-body.\n     */\n    public rotationWrtParent(): Rotation | null {\n        return RotationOps.fromRaw(\n            this.colliderSet.raw.coRotationWrtParent(this.handle),\n        );\n    }\n\n    /**\n     * Is this collider a sensor?\n     */\n    public isSensor(): boolean {\n        return this.colliderSet.raw.coIsSensor(this.handle);\n    }\n\n    /**\n     * Sets whether this collider is a sensor.\n     * @param isSensor - If `true`, the collider will be a sensor.\n     */\n    public setSensor(isSensor: boolean) {\n        this.colliderSet.raw.coSetSensor(this.handle, isSensor);\n    }\n\n    /**\n     * Sets the new shape of the collider.\n     * @param shape - The collider’s new shape.\n     */\n    public setShape(shape: Shape) {\n        let rawShape = shape.intoRaw();\n        this.colliderSet.raw.coSetShape(this.handle, rawShape);\n        rawShape.free();\n        this._shape = shape;\n    }\n\n    /**\n     * Sets whether this collider is enabled or not.\n     *\n     * @param enabled - Set to `false` to disable this collider (its parent rigid-body won’t be disabled automatically by this).\n     */\n    public setEnabled(enabled: boolean) {\n        this.colliderSet.raw.coSetEnabled(this.handle, enabled);\n    }\n\n    /**\n     * Is this collider enabled?\n     */\n    public isEnabled(): boolean {\n        return this.colliderSet.raw.coIsEnabled(this.handle);\n    }\n\n    /**\n     * Sets the restitution coefficient of the collider to be created.\n     *\n     * @param restitution - The restitution coefficient in `[0, 1]`. A value of 0 (the default) means no bouncing behavior\n     *                   while 1 means perfect bouncing (though energy may still be lost due to numerical errors of the\n     *                   constraints solver).\n     */\n    public setRestitution(restitution: number) {\n        this.colliderSet.raw.coSetRestitution(this.handle, restitution);\n    }\n\n    /**\n     * Sets the friction coefficient of the collider to be created.\n     *\n     * @param friction - The friction coefficient. Must be greater or equal to 0. This is generally smaller than 1. The\n     *                   higher the coefficient, the stronger friction forces will be for contacts with the collider\n     *                   being built.\n     */\n    public setFriction(friction: number) {\n        this.colliderSet.raw.coSetFriction(this.handle, friction);\n    }\n\n    /**\n     * Gets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     */\n    public frictionCombineRule(): CoefficientCombineRule {\n        return this.colliderSet.raw.coFrictionCombineRule(this.handle);\n    }\n\n    /**\n     * Sets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule − The combine rule to apply.\n     */\n    public setFrictionCombineRule(rule: CoefficientCombineRule) {\n        this.colliderSet.raw.coSetFrictionCombineRule(this.handle, rule);\n    }\n\n    /**\n     * Gets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     */\n    public restitutionCombineRule(): CoefficientCombineRule {\n        return this.colliderSet.raw.coRestitutionCombineRule(this.handle);\n    }\n\n    /**\n     * Sets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule − The combine rule to apply.\n     */\n    public setRestitutionCombineRule(rule: CoefficientCombineRule) {\n        this.colliderSet.raw.coSetRestitutionCombineRule(this.handle, rule);\n    }\n\n    /**\n     * Sets the collision groups used by this collider.\n     *\n     * Two colliders will interact iff. their collision groups are compatible.\n     * See the documentation of `InteractionGroups` for details on teh used bit pattern.\n     *\n     * @param groups - The collision groups used for the collider being built.\n     */\n    public setCollisionGroups(groups: InteractionGroups) {\n        this.colliderSet.raw.coSetCollisionGroups(this.handle, groups);\n    }\n\n    /**\n     * Sets the solver groups used by this collider.\n     *\n     * Forces between two colliders in contact will be computed iff their solver\n     * groups are compatible.\n     * See the documentation of `InteractionGroups` for details on the used bit pattern.\n     *\n     * @param groups - The solver groups used for the collider being built.\n     */\n    public setSolverGroups(groups: InteractionGroups) {\n        this.colliderSet.raw.coSetSolverGroups(this.handle, groups);\n    }\n\n    /**\n     * Sets the contact skin for this collider.\n     *\n     * See the documentation of `ColliderDesc.setContactSkin` for additional details.\n     */\n    public contactSkin(): number {\n        return this.colliderSet.raw.coContactSkin(this.handle);\n    }\n\n    /**\n     * Sets the contact skin for this collider.\n     *\n     * See the documentation of `ColliderDesc.setContactSkin` for additional details.\n     *\n     * @param thickness - The contact skin thickness.\n     */\n    public setContactSkin(thickness: number) {\n        return this.colliderSet.raw.coSetContactSkin(this.handle, thickness);\n    }\n\n    /**\n     * Get the physics hooks active for this collider.\n     */\n    public activeHooks(): ActiveHooks {\n        return this.colliderSet.raw.coActiveHooks(this.handle);\n    }\n\n    /**\n     * Set the physics hooks active for this collider.\n     *\n     * Use this to enable custom filtering rules for contact/intersecstion pairs involving this collider.\n     *\n     * @param activeHooks - The hooks active for contact/intersection pairs involving this collider.\n     */\n    public setActiveHooks(activeHooks: ActiveHooks) {\n        this.colliderSet.raw.coSetActiveHooks(this.handle, activeHooks);\n    }\n\n    /**\n     * The events active for this collider.\n     */\n    public activeEvents(): ActiveEvents {\n        return this.colliderSet.raw.coActiveEvents(this.handle);\n    }\n\n    /**\n     * Set the events active for this collider.\n     *\n     * Use this to enable contact and/or intersection event reporting for this collider.\n     *\n     * @param activeEvents - The events active for contact/intersection pairs involving this collider.\n     */\n    public setActiveEvents(activeEvents: ActiveEvents) {\n        this.colliderSet.raw.coSetActiveEvents(this.handle, activeEvents);\n    }\n\n    /**\n     * Gets the collision types active for this collider.\n     */\n    public activeCollisionTypes(): ActiveCollisionTypes {\n        return this.colliderSet.raw.coActiveCollisionTypes(this.handle);\n    }\n\n    /**\n     * Sets the total force magnitude beyond which a contact force event can be emitted.\n     *\n     * @param threshold - The new force threshold.\n     */\n    public setContactForceEventThreshold(threshold: number) {\n        return this.colliderSet.raw.coSetContactForceEventThreshold(\n            this.handle,\n            threshold,\n        );\n    }\n\n    /**\n     * The total force magnitude beyond which a contact force event can be emitted.\n     */\n    public contactForceEventThreshold(): number {\n        return this.colliderSet.raw.coContactForceEventThreshold(this.handle);\n    }\n\n    /**\n     * Set the collision types active for this collider.\n     *\n     * @param activeCollisionTypes - The hooks active for contact/intersection pairs involving this collider.\n     */\n    public setActiveCollisionTypes(activeCollisionTypes: ActiveCollisionTypes) {\n        this.colliderSet.raw.coSetActiveCollisionTypes(\n            this.handle,\n            activeCollisionTypes,\n        );\n    }\n\n    /**\n     * Sets the uniform density of this collider.\n     *\n     * This will override any previous mass-properties set by `this.setDensity`,\n     * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,\n     * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.\n     *\n     * The mass and angular inertia of this collider will be computed automatically based on its\n     * shape.\n     */\n    public setDensity(density: number) {\n        this.colliderSet.raw.coSetDensity(this.handle, density);\n    }\n\n    /**\n     * Sets the mass of this collider.\n     *\n     * This will override any previous mass-properties set by `this.setDensity`,\n     * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,\n     * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.\n     *\n     * The angular inertia of this collider will be computed automatically based on its shape\n     * and this mass value.\n     */\n    public setMass(mass: number) {\n        this.colliderSet.raw.coSetMass(this.handle, mass);\n    }\n\n\n    // #if DIM2\n    /**\n     * Sets the mass of this collider.\n     *\n     * This will override any previous mass-properties set by `this.setDensity`,\n     * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,\n     * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.\n     */\n    public setMassProperties(\n        mass: number,\n        centerOfMass: Vector,\n        principalAngularInertia: number,\n    ) {\n        let rawCom = VectorOps.intoRaw(centerOfMass);\n        this.colliderSet.raw.coSetMassProperties(\n            this.handle,\n            mass,\n            rawCom,\n            principalAngularInertia,\n        );\n        rawCom.free();\n    }\n\n    // #endif\n\n    /**\n     * Sets the translation of this collider.\n     *\n     * @param tra - The world-space position of the collider.\n     */\n    public setTranslation(tra: Vector) {\n        // #if DIM2\n        this.colliderSet.raw.coSetTranslation(this.handle, tra.x, tra.y);\n        // #endif\n    }\n\n    /**\n     * Sets the translation of this collider relative to its parent rigid-body.\n     *\n     * Does nothing if this collider isn't attached to a rigid-body.\n     *\n     * @param tra - The new translation of the collider relative to its parent.\n     */\n    public setTranslationWrtParent(tra: Vector) {\n        // #if DIM2\n        this.colliderSet.raw.coSetTranslationWrtParent(\n            this.handle,\n            tra.x,\n            tra.y,\n        );\n        // #endif\n    }\n\n    // #if DIM2\n    /**\n     * Sets the rotation angle of this collider.\n     *\n     * @param angle - The rotation angle, in radians.\n     */\n    public setRotation(angle: number) {\n        this.colliderSet.raw.coSetRotation(this.handle, angle);\n    }\n\n    /**\n     * Sets the rotation angle of this collider relative to its parent rigid-body.\n     *\n     * Does nothing if this collider isn't attached to a rigid-body.\n     *\n     * @param angle - The rotation angle, in radians.\n     */\n    public setRotationWrtParent(angle: number) {\n        this.colliderSet.raw.coSetRotationWrtParent(this.handle, angle);\n    }\n\n    // #endif\n\n    /**\n     * The type of the shape of this collider.\n     */\n    public shapeType(): ShapeType {\n        return this.colliderSet.raw.coShapeType(\n            this.handle,\n        ) as number as ShapeType;\n    }\n\n    /**\n     * The half-extents of this collider if it is a cuboid shape.\n     */\n    public halfExtents(): Vector {\n        return VectorOps.fromRaw(\n            this.colliderSet.raw.coHalfExtents(this.handle),\n        );\n    }\n\n    /**\n     * Sets the half-extents of this collider if it is a cuboid shape.\n     *\n     * @param newHalfExtents - desired half extents.\n     */\n    public setHalfExtents(newHalfExtents: Vector) {\n        const rawPoint = VectorOps.intoRaw(newHalfExtents);\n        this.colliderSet.raw.coSetHalfExtents(this.handle, rawPoint);\n    }\n\n    /**\n     * The radius of this collider if it is a ball, cylinder, capsule, or cone shape.\n     */\n    public radius(): number {\n        return this.colliderSet.raw.coRadius(this.handle);\n    }\n\n    /**\n     * Sets the radius of this collider if it is a ball, cylinder, capsule, or cone shape.\n     *\n     * @param newRadius - desired radius.\n     */\n    public setRadius(newRadius: number): void {\n        this.colliderSet.raw.coSetRadius(this.handle, newRadius);\n    }\n\n    /**\n     * The radius of the round edges of this collider if it is a round cylinder.\n     */\n    public roundRadius(): number {\n        return this.colliderSet.raw.coRoundRadius(this.handle);\n    }\n\n    /**\n     * Sets the radius of the round edges of this collider if it has round edges.\n     *\n     * @param newBorderRadius - desired round edge radius.\n     */\n    public setRoundRadius(newBorderRadius: number) {\n        this.colliderSet.raw.coSetRoundRadius(this.handle, newBorderRadius);\n    }\n\n    /**\n     * The half height of this collider if it is a cylinder, capsule, or cone shape.\n     */\n    public halfHeight(): number {\n        return this.colliderSet.raw.coHalfHeight(this.handle);\n    }\n\n    /**\n     * Sets the half height of this collider if it is a cylinder, capsule, or cone shape.\n     *\n     * @param newHalfheight - desired half height.\n     */\n    public setHalfHeight(newHalfheight: number) {\n        this.colliderSet.raw.coSetHalfHeight(this.handle, newHalfheight);\n    }\n\n    /**\n     * If this collider has a Voxels shape, this will mark the voxel at the\n     * given grid coordinates as filled or empty (depending on the `filled`\n     * argument).\n     *\n     * Each input value is assumed to be an integer.\n     *\n     * The operation is O(1), unless the provided coordinates are out of the\n     * bounds of the currently allocated internal grid in which case the grid\n     * will be grown automatically.\n     */\n    public setVoxel(\n        ix: number,\n        iy: number,\n        filled: boolean,\n    ) {\n        this.colliderSet.raw.coSetVoxel(\n            this.handle,\n            ix,\n            iy,\n            filled,\n        );\n        // We modified the shape, invalidate it to keep our cache\n        // up-to-date the next time the user requests the shape data.\n        // PERF: this isn’t ideal for performances as this adds a\n        //       hidden, non-constant, cost.\n        this._shape = null;\n    }\n\n    /**\n     * If this and `voxels2` are voxel colliders, and a voxel from `this` was\n     * modified with `setVoxel`, this will ensure that a\n     * moving object transitioning across the boundaries of these colliders\n     * won’t suffer from the \"internal edges\" artifact.\n     *\n     * The indices `ix, iy, iz` indicate the integer coordinates of the voxel in\n     * the local coordinate frame of `this`.\n     *\n     * If the voxels in `voxels2` live in a different coordinate space from `this`,\n     * then the `shift_*` argument indicate the distance, in voxel units, between\n     * the origin of `this` to the origin of `voxels2`.\n     *\n     * This method is intended to be called between `this` and all the other\n     * voxels colliders with a domain intersecting `this` or sharing a domain\n     * boundary. This is an incremental maintenance of the effect of\n     * `combineVoxelStates`.\n     */\n    public propagateVoxelChange(\n        voxels2: Collider,\n        ix: number,\n        iy: number,\n        shift_x: number,\n        shift_y: number,\n    ) {\n        this.colliderSet.raw.coPropagateVoxelChange(\n            this.handle,\n            voxels2.handle,\n            ix,\n            iy,\n            shift_x,\n            shift_y,\n        );\n        // We modified the shape, invalidate it to keep our cache\n        // up-to-date the next time the user requests the shape data.\n        // PERF: this isn’t ideal for performances as this adds a\n        //       hidden, non-constant, cost.\n        this._shape = null;\n    }\n\n    /**\n     * If this and `voxels2` are voxel colliders, this will ensure that a\n     * moving object transitioning across the boundaries of these colliders\n     * won’t suffer from the \"internal edges\" artifact.\n     *\n     * If the voxels in `voxels2` live in a different coordinate space from `this`,\n     * then the `shift_*` argument indicate the distance, in voxel units, between\n     * the origin of `this` to the origin of `voxels2`.\n     *\n     * This method is intended to be called once between all pairs of voxels\n     * colliders with intersecting domains or shared boundaries.\n     *\n     * If either voxels collider is then modified with `setVoxel`, the\n     * `propagateVoxelChange` method must be called to maintain the coupling\n     * between the voxels shapes after the modification.\n     */\n    public combineVoxelStates(\n        voxels2: Collider,\n        shift_x: number,\n        shift_y: number,\n    ) {\n        this.colliderSet.raw.coCombineVoxelStates(\n            this.handle,\n            voxels2.handle,\n            shift_x,\n            shift_y,\n        );\n        // We modified the shape, invalidate it to keep our cache\n        // up-to-date the next time the user requests the shape data.\n        // PERF: this isn’t ideal for performances as this adds a\n        //       hidden, non-constant, cost.\n        this._shape = null;\n    }\n\n    /**\n     * If this collider has a triangle mesh, polyline, convex polygon, or convex polyhedron shape,\n     * this returns the vertex buffer of said shape.\n     */\n    public vertices(): Float32Array {\n        return this.colliderSet.raw.coVertices(this.handle);\n    }\n\n    /**\n     * If this collider has a triangle mesh, polyline, or convex polyhedron shape,\n     * this returns the index buffer of said shape.\n     */\n    public indices(): Uint32Array | undefined {\n        return this.colliderSet.raw.coIndices(this.handle);\n    }\n\n    /**\n     * If this collider has a heightfield shape, this returns the heights buffer of\n     * the heightfield.\n     * In 3D, the returned height matrix is provided in column-major order.\n     */\n    public heightfieldHeights(): Float32Array {\n        return this.colliderSet.raw.coHeightfieldHeights(this.handle);\n    }\n\n    /**\n     * If this collider has a heightfield shape, this returns the scale\n     * applied to it.\n     */\n    public heightfieldScale(): Vector {\n        let scale = this.colliderSet.raw.coHeightfieldScale(this.handle);\n        return VectorOps.fromRaw(scale);\n    }\n\n\n    /**\n     * The rigid-body this collider is attached to.\n     */\n    public parent(): RigidBody | null {\n        return this._parent;\n    }\n\n    /**\n     * The friction coefficient of this collider.\n     */\n    public friction(): number {\n        return this.colliderSet.raw.coFriction(this.handle);\n    }\n\n    /**\n     * The restitution coefficient of this collider.\n     */\n    public restitution(): number {\n        return this.colliderSet.raw.coRestitution(this.handle);\n    }\n\n    /**\n     * The density of this collider.\n     */\n    public density(): number {\n        return this.colliderSet.raw.coDensity(this.handle);\n    }\n\n    /**\n     * The mass of this collider.\n     */\n    public mass(): number {\n        return this.colliderSet.raw.coMass(this.handle);\n    }\n\n    /**\n     * The volume of this collider.\n     */\n    public volume(): number {\n        return this.colliderSet.raw.coVolume(this.handle);\n    }\n\n    /**\n     * The collision groups of this collider.\n     */\n    public collisionGroups(): InteractionGroups {\n        return this.colliderSet.raw.coCollisionGroups(this.handle);\n    }\n\n    /**\n     * The solver groups of this collider.\n     */\n    public solverGroups(): InteractionGroups {\n        return this.colliderSet.raw.coSolverGroups(this.handle);\n    }\n\n    /**\n     * Tests if this collider contains a point.\n     *\n     * @param point - The point to test.\n     */\n    public containsPoint(point: Vector): boolean {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = this.colliderSet.raw.coContainsPoint(\n            this.handle,\n            rawPoint,\n        );\n\n        rawPoint.free();\n\n        return result;\n    }\n\n    /**\n     * Find the projection of a point on this collider.\n     *\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     */\n    public projectPoint(point: Vector, solid: boolean): PointProjection | null {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = PointProjection.fromRaw(\n            this.colliderSet.raw.coProjectPoint(this.handle, rawPoint, solid),\n        );\n\n        rawPoint.free();\n\n        return result;\n    }\n\n    /**\n     * Tests if this collider intersects the given ray.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     */\n    public intersectsRay(ray: Ray, maxToi: number): boolean {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = this.colliderSet.raw.coIntersectsRay(\n            this.handle,\n            rawOrig,\n            rawDir,\n            maxToi,\n        );\n\n        rawOrig.free();\n        rawDir.free();\n\n        return result;\n    }\n\n    /*\n     * Computes the smallest time between this and the given shape under translational movement are separated by a distance smaller or equal to distance.\n     *\n     * @param collider1Vel - The constant velocity of the current shape to cast (i.e. the cast direction).\n     * @param shape2 - The shape to cast against.\n     * @param shape2Pos - The position of the second shape.\n     * @param shape2Rot - The rotation of the second shape.\n     * @param shape2Vel - The constant velocity of the second shape.\n     * @param targetDistance − If the shape moves closer to this distance from a collider, a hit\n     *                         will be returned.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `collider1Vel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast won’t immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that it’s on a path to exit that penetration state.\n     */\n    public castShape(\n        collider1Vel: Vector,\n        shape2: Shape,\n        shape2Pos: Vector,\n        shape2Rot: Rotation,\n        shape2Vel: Vector,\n        targetDistance: number,\n        maxToi: number,\n        stopAtPenetration: boolean,\n    ): ShapeCastHit | null {\n        let rawCollider1Vel = VectorOps.intoRaw(collider1Vel);\n        let rawShape2Pos = VectorOps.intoRaw(shape2Pos);\n        let rawShape2Rot = RotationOps.intoRaw(shape2Rot);\n        let rawShape2Vel = VectorOps.intoRaw(shape2Vel);\n        let rawShape2 = shape2.intoRaw();\n\n        let result = ShapeCastHit.fromRaw(\n            this.colliderSet,\n            this.colliderSet.raw.coCastShape(\n                this.handle,\n                rawCollider1Vel,\n                rawShape2,\n                rawShape2Pos,\n                rawShape2Rot,\n                rawShape2Vel,\n                targetDistance,\n                maxToi,\n                stopAtPenetration,\n            ),\n        );\n\n        rawCollider1Vel.free();\n        rawShape2Pos.free();\n        rawShape2Rot.free();\n        rawShape2Vel.free();\n        rawShape2.free();\n\n        return result;\n    }\n\n    /*\n     * Computes the smallest time between this and the given collider under translational movement are separated by a distance smaller or equal to distance.\n     *\n     * @param collider1Vel - The constant velocity of the current collider to cast (i.e. the cast direction).\n     * @param collider2 - The collider to cast against.\n     * @param collider2Vel - The constant velocity of the second collider.\n     * @param targetDistance − If the shape moves closer to this distance from a collider, a hit\n     *                         will be returned.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast won’t immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that it’s on a path to exit that penetration state.\n     */\n    public castCollider(\n        collider1Vel: Vector,\n        collider2: Collider,\n        collider2Vel: Vector,\n        targetDistance: number,\n        maxToi: number,\n        stopAtPenetration: boolean,\n    ): ColliderShapeCastHit | null {\n        let rawCollider1Vel = VectorOps.intoRaw(collider1Vel);\n        let rawCollider2Vel = VectorOps.intoRaw(collider2Vel);\n\n        let result = ColliderShapeCastHit.fromRaw(\n            this.colliderSet,\n            this.colliderSet.raw.coCastCollider(\n                this.handle,\n                rawCollider1Vel,\n                collider2.handle,\n                rawCollider2Vel,\n                targetDistance,\n                maxToi,\n                stopAtPenetration,\n            ),\n        );\n\n        rawCollider1Vel.free();\n        rawCollider2Vel.free();\n\n        return result;\n    }\n\n    public intersectsShape(\n        shape2: Shape,\n        shapePos2: Vector,\n        shapeRot2: Rotation,\n    ): boolean {\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n        let rawShape2 = shape2.intoRaw();\n\n        let result = this.colliderSet.raw.coIntersectsShape(\n            this.handle,\n            rawShape2,\n            rawPos2,\n            rawRot2,\n        );\n\n        rawPos2.free();\n        rawRot2.free();\n        rawShape2.free();\n\n        return result;\n    }\n\n    /**\n     * Computes one pair of contact points between the shape owned by this collider and the given shape.\n     *\n     * @param shape2 - The second shape.\n     * @param shape2Pos - The initial position of the second shape.\n     * @param shape2Rot - The rotation of the second shape.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n    contactShape(\n        shape2: Shape,\n        shape2Pos: Vector,\n        shape2Rot: Rotation,\n        prediction: number,\n    ): ShapeContact | null {\n        let rawPos2 = VectorOps.intoRaw(shape2Pos);\n        let rawRot2 = RotationOps.intoRaw(shape2Rot);\n        let rawShape2 = shape2.intoRaw();\n\n        let result = ShapeContact.fromRaw(\n            this.colliderSet.raw.coContactShape(\n                this.handle,\n                rawShape2,\n                rawPos2,\n                rawRot2,\n                prediction,\n            ),\n        );\n\n        rawPos2.free();\n        rawRot2.free();\n        rawShape2.free();\n\n        return result;\n    }\n\n    /**\n     * Computes one pair of contact points between the collider and the given collider.\n     *\n     * @param collider2 - The second collider.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n    contactCollider(\n        collider2: Collider,\n        prediction: number,\n    ): ShapeContact | null {\n        let result = ShapeContact.fromRaw(\n            this.colliderSet.raw.coContactCollider(\n                this.handle,\n                collider2.handle,\n                prediction,\n            ),\n        );\n\n        return result;\n    }\n\n    /**\n     * Find the closest intersection between a ray and this collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @returns The time-of-impact between this collider and the ray, or `-1` if there is no intersection.\n     */\n    public castRay(ray: Ray, maxToi: number, solid: boolean): number {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = this.colliderSet.raw.coCastRay(\n            this.handle,\n            rawOrig,\n            rawDir,\n            maxToi,\n            solid,\n        );\n\n        rawOrig.free();\n        rawDir.free();\n\n        return result;\n    }\n\n    /**\n     * Find the closest intersection between a ray and this collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     */\n    public castRayAndGetNormal(\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n    ): RayIntersection | null {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = RayIntersection.fromRaw(\n            this.colliderSet.raw.coCastRayAndGetNormal(\n                this.handle,\n                rawOrig,\n                rawDir,\n                maxToi,\n                solid,\n            ),\n        );\n\n        rawOrig.free();\n        rawDir.free();\n\n        return result;\n    }\n}\n\nexport enum MassPropsMode {\n    Density,\n    Mass,\n    MassProps,\n}\n\nexport class ColliderDesc {\n    enabled: boolean;\n    shape: Shape;\n    massPropsMode: MassPropsMode;\n    mass: number;\n    centerOfMass: Vector;\n    // #if DIM2\n    principalAngularInertia: number;\n    rotationsEnabled: boolean;\n    // #endif\n    density: number;\n    friction: number;\n    restitution: number;\n    rotation: Rotation;\n    translation: Vector;\n    isSensor: boolean;\n    collisionGroups: InteractionGroups;\n    solverGroups: InteractionGroups;\n    frictionCombineRule: CoefficientCombineRule;\n    restitutionCombineRule: CoefficientCombineRule;\n    activeEvents: ActiveEvents;\n    activeHooks: ActiveHooks;\n    activeCollisionTypes: ActiveCollisionTypes;\n    contactForceEventThreshold: number;\n    contactSkin: number;\n\n    /**\n     * Initializes a collider descriptor from the collision shape.\n     *\n     * @param shape - The shape of the collider being built.\n     */\n    constructor(shape: Shape) {\n        this.enabled = true;\n        this.shape = shape;\n        this.massPropsMode = MassPropsMode.Density;\n        this.density = 1.0;\n        this.friction = 0.5;\n        this.restitution = 0.0;\n        this.rotation = RotationOps.identity();\n        this.translation = VectorOps.zeros();\n        this.isSensor = false;\n        this.collisionGroups = 0xffff_ffff;\n        this.solverGroups = 0xffff_ffff;\n        this.frictionCombineRule = CoefficientCombineRule.Average;\n        this.restitutionCombineRule = CoefficientCombineRule.Average;\n        this.activeCollisionTypes = ActiveCollisionTypes.DEFAULT;\n        this.activeEvents = ActiveEvents.NONE;\n        this.activeHooks = ActiveHooks.NONE;\n        this.mass = 0.0;\n        this.centerOfMass = VectorOps.zeros();\n        this.contactForceEventThreshold = 0.0;\n        this.contactSkin = 0.0;\n\n        // #if DIM2\n        this.principalAngularInertia = 0.0;\n        this.rotationsEnabled = true;\n        // #endif\n    }\n\n    /**\n     * Create a new collider descriptor with a ball shape.\n     *\n     * @param radius - The radius of the ball.\n     */\n    public static ball(radius: number): ColliderDesc {\n        const shape = new Ball(radius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Create a new collider descriptor with a capsule shape.\n     *\n     * @param halfHeight - The half-height of the capsule, along the `y` axis.\n     * @param radius - The radius of the capsule basis.\n     */\n    public static capsule(halfHeight: number, radius: number): ColliderDesc {\n        const shape = new Capsule(halfHeight, radius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new segment shape.\n     *\n     * @param a - The first point of the segment.\n     * @param b - The second point of the segment.\n     */\n    public static segment(a: Vector, b: Vector): ColliderDesc {\n        const shape = new Segment(a, b);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new triangle shape.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     */\n    public static triangle(a: Vector, b: Vector, c: Vector): ColliderDesc {\n        const shape = new Triangle(a, b, c);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new triangle shape with round corners.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     * @param borderRadius - The radius of the borders of this triangle. In 3D,\n     *   this is also equal to half the thickness of the triangle.\n     */\n    public static roundTriangle(\n        a: Vector,\n        b: Vector,\n        c: Vector,\n        borderRadius: number,\n    ): ColliderDesc {\n        const shape = new RoundTriangle(a, b, c, borderRadius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor with a polyline shape.\n     *\n     * @param vertices - The coordinates of the polyline's vertices.\n     * @param indices - The indices of the polyline's segments. If this is `undefined` or `null`,\n     *    the vertices are assumed to describe a line strip.\n     */\n    public static polyline(\n        vertices: Float32Array,\n        indices?: Uint32Array | null,\n    ): ColliderDesc {\n        const shape = new Polyline(vertices, indices);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor with a shape made of voxels.\n     *\n     * @param data - Defines the set of voxels. If this is a `Int32Array` then\n     *               each voxel is defined from its (signed) grid coordinates,\n     *               with 3 (resp 2) contiguous integers per voxel in 3D (resp 2D).\n     *               If this is a `Float32Array`, each voxel will be such that\n     *               they contain at least one point from this array (where each\n     *               point is defined from 3 (resp 2) contiguous numbers per point\n     *               in 3D (resp 2D).\n     * @param voxelSize - The size of each voxel.\n     */\n    public static voxels(\n        voxels: Float32Array | Int32Array,\n        voxelSize: Vector,\n    ): ColliderDesc {\n        const shape = new Voxels(voxels, voxelSize);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor with a triangle mesh shape.\n     *\n     * @param vertices - The coordinates of the triangle mesh's vertices.\n     * @param indices - The indices of the triangle mesh's triangles.\n     */\n    public static trimesh(\n        vertices: Float32Array,\n        indices: Uint32Array,\n        flags?: TriMeshFlags,\n    ): ColliderDesc {\n        const shape = new TriMesh(vertices, indices, flags);\n        return new ColliderDesc(shape);\n    }\n\n    // #if DIM2\n    /**\n     * Creates a new collider descriptor with a rectangular shape.\n     *\n     * @param hx - The half-width of the rectangle along its local `x` axis.\n     * @param hy - The half-width of the rectangle along its local `y` axis.\n     */\n    public static cuboid(hx: number, hy: number): ColliderDesc {\n        const shape = new Cuboid(hx, hy);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor with a rectangular shape with round borders.\n     *\n     * @param hx - The half-width of the rectangle along its local `x` axis.\n     * @param hy - The half-width of the rectangle along its local `y` axis.\n     * @param borderRadius - The radius of the cuboid's borders.\n     */\n    public static roundCuboid(\n        hx: number,\n        hy: number,\n        borderRadius: number,\n    ): ColliderDesc {\n        const shape = new RoundCuboid(hx, hy, borderRadius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider description with a halfspace (infinite plane) shape.\n     *\n     * @param normal - The outward normal of the plane.\n     */\n    public static halfspace(normal: Vector): ColliderDesc {\n        const shape = new HalfSpace(normal);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor with a heightfield shape.\n     *\n     * @param heights - The heights of the heightfield, along its local `y` axis.\n     * @param scale - The scale factor applied to the heightfield.\n     */\n    public static heightfield(\n        heights: Float32Array,\n        scale: Vector,\n    ): ColliderDesc {\n        const shape = new Heightfield(heights, scale);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Computes the convex-hull of the given points and use the resulting\n     * convex polygon as the shape for this new collider descriptor.\n     *\n     * @param points - The point that will be used to compute the convex-hull.\n     */\n    public static convexHull(points: Float32Array): ColliderDesc | null {\n        const shape = new ConvexPolygon(points, false);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor that uses the given set of points assumed\n     * to form a convex polyline (no convex-hull computation will be done).\n     *\n     * @param vertices - The vertices of the convex polyline.\n     */\n    public static convexPolyline(vertices: Float32Array): ColliderDesc | null {\n        const shape = new ConvexPolygon(vertices, true);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Computes the convex-hull of the given points and use the resulting\n     * convex polygon as the shape for this new collider descriptor. A\n     * border is added to that convex polygon to give it round corners.\n     *\n     * @param points - The point that will be used to compute the convex-hull.\n     * @param borderRadius - The radius of the round border added to the convex polygon.\n     */\n    public static roundConvexHull(\n        points: Float32Array,\n        borderRadius: number,\n    ): ColliderDesc | null {\n        const shape = new RoundConvexPolygon(points, borderRadius, false);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor that uses the given set of points assumed\n     * to form a round convex polyline (no convex-hull computation will be done).\n     *\n     * @param vertices - The vertices of the convex polyline.\n     * @param borderRadius - The radius of the round border added to the convex polyline.\n     */\n    public static roundConvexPolyline(\n        vertices: Float32Array,\n        borderRadius: number,\n    ): ColliderDesc | null {\n        const shape = new RoundConvexPolygon(vertices, borderRadius, true);\n        return new ColliderDesc(shape);\n    }\n\n    // #endif\n\n\n    // #if DIM2\n    /**\n     * Sets the position of the collider to be created relative to the rigid-body it is attached to.\n     */\n    public setTranslation(x: number, y: number): ColliderDesc {\n        if (typeof x != \"number\" || typeof y != \"number\")\n            throw TypeError(\"The translation components must be numbers.\");\n\n        this.translation = {x: x, y: y};\n        return this;\n    }\n\n    // #endif\n\n\n    /**\n     * Sets the rotation of the collider to be created relative to the rigid-body it is attached to.\n     *\n     * @param rot - The rotation of the collider to be created relative to the rigid-body it is attached to.\n     */\n    public setRotation(rot: Rotation): ColliderDesc {\n        // #if DIM2\n        this.rotation = rot;\n        // #endif\n        return this;\n    }\n\n    /**\n     * Sets whether or not the collider being created is a sensor.\n     *\n     * A sensor collider does not take part of the physics simulation, but generates\n     * proximity events.\n     *\n     * @param sensor - Set to `true` of the collider built is to be a sensor.\n     */\n    public setSensor(sensor: boolean): ColliderDesc {\n        this.isSensor = sensor;\n        return this;\n    }\n\n    /**\n     * Sets whether the created collider will be enabled or disabled.\n     * @param enabled − If set to `false` the collider will be disabled at creation.\n     */\n    public setEnabled(enabled: boolean): ColliderDesc {\n        this.enabled = enabled;\n        return this;\n    }\n\n    /**\n     * Sets the contact skin of the collider.\n     *\n     * The contact skin acts as if the collider was enlarged with a skin of width `skin_thickness`\n     * around it, keeping objects further apart when colliding.\n     *\n     * A non-zero contact skin can increase performance, and in some cases, stability. However\n     * it creates a small gap between colliding object (equal to the sum of their skin). If the\n     * skin is sufficiently small, this might not be visually significant or can be hidden by the\n     * rendering assets.\n     */\n    public setContactSkin(thickness: number): ColliderDesc {\n        this.contactSkin = thickness;\n        return this;\n    }\n\n    /**\n     * Sets the density of the collider being built.\n     *\n     * The mass and angular inertia tensor will be computed automatically based on this density and the collider’s shape.\n     *\n     * @param density - The density to set, must be greater or equal to 0. A density of 0 means that this collider\n     *                  will not affect the mass or angular inertia of the rigid-body it is attached to.\n     */\n    public setDensity(density: number): ColliderDesc {\n        this.massPropsMode = MassPropsMode.Density;\n        this.density = density;\n        return this;\n    }\n\n    /**\n     * Sets the mass of the collider being built.\n     *\n     * The angular inertia tensor will be computed automatically based on this mass and the collider’s shape.\n     *\n     * @param mass - The mass to set, must be greater or equal to 0.\n     */\n    public setMass(mass: number): ColliderDesc {\n        this.massPropsMode = MassPropsMode.Mass;\n        this.mass = mass;\n        return this;\n    }\n\n    // #if DIM2\n    /**\n     * Sets the mass properties of the collider being built.\n     *\n     * This replaces the mass-properties automatically computed from the collider's density and shape.\n     * These mass-properties will be added to the mass-properties of the rigid-body this collider will be attached to.\n     *\n     * @param mass − The mass of the collider to create.\n     * @param centerOfMass − The center-of-mass of the collider to create.\n     * @param principalAngularInertia − The principal angular inertia of the collider to create.\n     */\n    public setMassProperties(\n        mass: number,\n        centerOfMass: Vector,\n        principalAngularInertia: number,\n    ): ColliderDesc {\n        this.massPropsMode = MassPropsMode.MassProps;\n        this.mass = mass;\n        VectorOps.copy(this.centerOfMass, centerOfMass);\n        this.principalAngularInertia = principalAngularInertia;\n        return this;\n    }\n\n    // #endif\n\n\n    /**\n     * Sets the restitution coefficient of the collider to be created.\n     *\n     * @param restitution - The restitution coefficient in `[0, 1]`. A value of 0 (the default) means no bouncing behavior\n     *                   while 1 means perfect bouncing (though energy may still be lost due to numerical errors of the\n     *                   constraints solver).\n     */\n    public setRestitution(restitution: number): ColliderDesc {\n        this.restitution = restitution;\n        return this;\n    }\n\n    /**\n     * Sets the friction coefficient of the collider to be created.\n     *\n     * @param friction - The friction coefficient. Must be greater or equal to 0. This is generally smaller than 1. The\n     *                   higher the coefficient, the stronger friction forces will be for contacts with the collider\n     *                   being built.\n     */\n    public setFriction(friction: number): ColliderDesc {\n        this.friction = friction;\n        return this;\n    }\n\n    /**\n     * Sets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule − The combine rule to apply.\n     */\n    public setFrictionCombineRule(rule: CoefficientCombineRule): ColliderDesc {\n        this.frictionCombineRule = rule;\n        return this;\n    }\n\n    /**\n     * Sets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule − The combine rule to apply.\n     */\n    public setRestitutionCombineRule(\n        rule: CoefficientCombineRule,\n    ): ColliderDesc {\n        this.restitutionCombineRule = rule;\n        return this;\n    }\n\n    /**\n     * Sets the collision groups used by this collider.\n     *\n     * Two colliders will interact iff. their collision groups are compatible.\n     * See the documentation of `InteractionGroups` for details on teh used bit pattern.\n     *\n     * @param groups - The collision groups used for the collider being built.\n     */\n    public setCollisionGroups(groups: InteractionGroups): ColliderDesc {\n        this.collisionGroups = groups;\n        return this;\n    }\n\n    /**\n     * Sets the solver groups used by this collider.\n     *\n     * Forces between two colliders in contact will be computed iff their solver\n     * groups are compatible.\n     * See the documentation of `InteractionGroups` for details on the used bit pattern.\n     *\n     * @param groups - The solver groups used for the collider being built.\n     */\n    public setSolverGroups(groups: InteractionGroups): ColliderDesc {\n        this.solverGroups = groups;\n        return this;\n    }\n\n    /**\n     * Set the physics hooks active for this collider.\n     *\n     * Use this to enable custom filtering rules for contact/intersecstion pairs involving this collider.\n     *\n     * @param activeHooks - The hooks active for contact/intersection pairs involving this collider.\n     */\n    public setActiveHooks(activeHooks: ActiveHooks): ColliderDesc {\n        this.activeHooks = activeHooks;\n        return this;\n    }\n\n    /**\n     * Set the events active for this collider.\n     *\n     * Use this to enable contact and/or intersection event reporting for this collider.\n     *\n     * @param activeEvents - The events active for contact/intersection pairs involving this collider.\n     */\n    public setActiveEvents(activeEvents: ActiveEvents): ColliderDesc {\n        this.activeEvents = activeEvents;\n        return this;\n    }\n\n    /**\n     * Set the collision types active for this collider.\n     *\n     * @param activeCollisionTypes - The hooks active for contact/intersection pairs involving this collider.\n     */\n    public setActiveCollisionTypes(\n        activeCollisionTypes: ActiveCollisionTypes,\n    ): ColliderDesc {\n        this.activeCollisionTypes = activeCollisionTypes;\n        return this;\n    }\n\n    /**\n     * Sets the total force magnitude beyond which a contact force event can be emitted.\n     *\n     * @param threshold - The force threshold to set.\n     */\n    public setContactForceEventThreshold(threshold: number): ColliderDesc {\n        this.contactForceEventThreshold = threshold;\n        return this;\n    }\n}\n","export class Coarena<T> {\n    fconv: Float64Array;\n    uconv: Uint32Array;\n    data: Array<T>;\n    size: number;\n\n    public constructor() {\n        this.fconv = new Float64Array(1);\n        this.uconv = new Uint32Array(this.fconv.buffer);\n        this.data = new Array<T>();\n        this.size = 0;\n    }\n\n    public set(handle: number, data: T) {\n        let i = this.index(handle);\n        while (this.data.length <= i) {\n            this.data.push(null);\n        }\n\n        if (this.data[i] == null) this.size += 1;\n        this.data[i] = data;\n    }\n\n    public len(): number {\n        return this.size;\n    }\n\n    public delete(handle: number) {\n        let i = this.index(handle);\n        if (i < this.data.length) {\n            if (this.data[i] != null) this.size -= 1;\n            this.data[i] = null;\n        }\n    }\n\n    public clear() {\n        this.data = new Array<T>();\n    }\n\n    public get(handle: number): T | null {\n        let i = this.index(handle);\n        if (i < this.data.length) {\n            return this.data[i];\n        } else {\n            return null;\n        }\n    }\n\n    public forEach(f: (elt: T) => void) {\n        for (const elt of this.data) {\n            if (elt != null) f(elt);\n        }\n    }\n\n    public getAll(): Array<T> {\n        return this.data.filter((elt) => elt != null);\n    }\n\n    private index(handle: number): number {\n        /// Extracts the index part of a handle (the lower 32 bits).\n        /// This is done by first injecting the handle into an Float64Array\n        /// which is itself injected into an Uint32Array (at construction time).\n        /// The 0-th value of the Uint32Array will become the `number` integer\n        /// representation of the lower 32 bits.\n        /// Also `this.uconv[1]` then contains the generation number as a `number`,\n        /// which we don’t really need.\n        this.fconv[0] = handle;\n        return this.uconv[0];\n    }\n}\n","import {RawRigidBodySet, RawRigidBodyType} from \"../raw\";\nimport {Coarena} from \"../coarena\";\nimport {VectorOps, RotationOps} from \"../math\";\nimport {\n    RigidBody,\n    RigidBodyDesc,\n    RigidBodyHandle,\n    RigidBodyType,\n} from \"./rigid_body\";\nimport {ColliderSet} from \"../geometry\";\nimport {ImpulseJointSet} from \"./impulse_joint_set\";\nimport {MultibodyJointSet} from \"./multibody_joint_set\";\nimport {IslandManager} from \"./island_manager\";\n\n/**\n * A set of rigid bodies that can be handled by a physics pipeline.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `rigidBodySet.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class RigidBodySet {\n    raw: RawRigidBodySet;\n    private map: Coarena<RigidBody>;\n\n    /**\n     * Release the WASM memory occupied by this rigid-body set.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n\n    constructor(raw?: RawRigidBodySet) {\n        this.raw = raw || new RawRigidBodySet();\n        this.map = new Coarena<RigidBody>();\n        // deserialize\n        if (raw) {\n            raw.forEachRigidBodyHandle((handle: RigidBodyHandle) => {\n                this.map.set(handle, new RigidBody(raw, null, handle));\n            });\n        }\n    }\n\n    /**\n     * Internal method, do not call this explicitly.\n     */\n    public finalizeDeserialization(colliderSet: ColliderSet) {\n        this.map.forEach((rb) => rb.finalizeDeserialization(colliderSet));\n    }\n\n    /**\n     * Creates a new rigid-body and return its integer handle.\n     *\n     * @param desc - The description of the rigid-body to create.\n     */\n    public createRigidBody(\n        colliderSet: ColliderSet,\n        desc: RigidBodyDesc,\n    ): RigidBody {\n        let rawTra = VectorOps.intoRaw(desc.translation);\n        let rawRot = RotationOps.intoRaw(desc.rotation);\n        let rawLv = VectorOps.intoRaw(desc.linvel);\n        let rawCom = VectorOps.intoRaw(desc.centerOfMass);\n\n\n        let handle = this.raw.createRigidBody(\n            desc.enabled,\n            rawTra,\n            rawRot,\n            desc.gravityScale,\n            desc.mass,\n            desc.massOnly,\n            rawCom,\n            rawLv,\n            // #if DIM2\n            desc.angvel,\n            desc.principalAngularInertia,\n            desc.translationsEnabledX,\n            desc.translationsEnabledY,\n            desc.rotationsEnabled,\n            // #endif\n            desc.linearDamping,\n            desc.angularDamping,\n            desc.status as number as RawRigidBodyType,\n            desc.canSleep,\n            desc.sleeping,\n            desc.softCcdPrediction,\n            desc.ccdEnabled,\n            desc.dominanceGroup,\n            desc.additionalSolverIterations,\n        );\n\n        rawTra.free();\n        rawRot.free();\n        rawLv.free();\n        rawCom.free();\n\n\n        const body = new RigidBody(this.raw, colliderSet, handle);\n        body.userData = desc.userData;\n\n        this.map.set(handle, body);\n\n        return body;\n    }\n\n    /**\n     * Removes a rigid-body from this set.\n     *\n     * This will also remove all the colliders and joints attached to the rigid-body.\n     *\n     * @param handle - The integer handle of the rigid-body to remove.\n     * @param colliders - The set of colliders that may contain colliders attached to the removed rigid-body.\n     * @param impulseJoints - The set of impulse joints that may contain joints attached to the removed rigid-body.\n     * @param multibodyJoints - The set of multibody joints that may contain joints attached to the removed rigid-body.\n     */\n    public remove(\n        handle: RigidBodyHandle,\n        islands: IslandManager,\n        colliders: ColliderSet,\n        impulseJoints: ImpulseJointSet,\n        multibodyJoints: MultibodyJointSet,\n    ) {\n        // Unmap the entities that will be removed automatically because of the rigid-body removals.\n        for (let i = 0; i < this.raw.rbNumColliders(handle); i += 1) {\n            colliders.unmap(this.raw.rbCollider(handle, i));\n        }\n\n        impulseJoints.forEachJointHandleAttachedToRigidBody(handle, (handle) =>\n            impulseJoints.unmap(handle),\n        );\n        multibodyJoints.forEachJointHandleAttachedToRigidBody(\n            handle,\n            (handle) => multibodyJoints.unmap(handle),\n        );\n\n        // Remove the rigid-body.\n        this.raw.remove(\n            handle,\n            islands.raw,\n            colliders.raw,\n            impulseJoints.raw,\n            multibodyJoints.raw,\n        );\n        this.map.delete(handle);\n    }\n\n    /**\n     * The number of rigid-bodies on this set.\n     */\n    public len(): number {\n        return this.map.len();\n    }\n\n    /**\n     * Does this set contain a rigid-body with the given handle?\n     *\n     * @param handle - The rigid-body handle to check.\n     */\n    public contains(handle: RigidBodyHandle): boolean {\n        return this.get(handle) != null;\n    }\n\n    /**\n     * Gets the rigid-body with the given handle.\n     *\n     * @param handle - The handle of the rigid-body to retrieve.\n     */\n    public get(handle: RigidBodyHandle): RigidBody | null {\n        return this.map.get(handle);\n    }\n\n    /**\n     * Applies the given closure to each rigid-body contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEach(f: (body: RigidBody) => void) {\n        this.map.forEach(f);\n    }\n\n    /**\n     * Applies the given closure to each active rigid-bodies contained by this set.\n     *\n     * A rigid-body is active if it is not sleeping, i.e., if it moved recently.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEachActiveRigidBody(\n        islands: IslandManager,\n        f: (body: RigidBody) => void,\n    ) {\n        islands.forEachActiveRigidBodyHandle((handle) => {\n            f(this.get(handle));\n        });\n    }\n\n    /**\n     * Gets all rigid-bodies in the list.\n     *\n     * @returns rigid-bodies list.\n     */\n    public getAll(): RigidBody[] {\n        return this.map.getAll();\n    }\n}\n","import {RawIntegrationParameters} from \"../raw\";\n\nexport class IntegrationParameters {\n    raw: RawIntegrationParameters;\n\n    constructor(raw?: RawIntegrationParameters) {\n        this.raw = raw || new RawIntegrationParameters();\n    }\n\n    /**\n     * Free the WASM memory used by these integration parameters.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    /**\n     * The timestep length (default: `1.0 / 60.0`)\n     */\n    get dt(): number {\n        return this.raw.dt;\n    }\n\n    /**\n     * The Error Reduction Parameter in `[0, 1]` is the proportion of\n     * the positional error to be corrected at each time step (default: `0.2`).\n     */\n    get contact_erp(): number {\n        return this.raw.contact_erp;\n    }\n\n    get lengthUnit(): number {\n        return this.raw.lengthUnit;\n    }\n\n    /**\n     * Normalized amount of penetration the engine won’t attempt to correct (default: `0.001m`).\n     *\n     * This threshold considered by the physics engine is this value multiplied by the `lengthUnit`.\n     */\n    get normalizedAllowedLinearError(): number {\n        return this.raw.normalizedAllowedLinearError;\n    }\n\n    /**\n     * The maximal normalized distance separating two objects that will generate predictive contacts (default: `0.002`).\n     *\n     * This threshold considered by the physics engine is this value multiplied by the `lengthUnit`.\n     */\n    get normalizedPredictionDistance(): number {\n        return this.raw.normalizedPredictionDistance;\n    }\n\n    /**\n     * The number of solver iterations run by the constraints solver for calculating forces (default: `4`).\n     */\n    get numSolverIterations(): number {\n        return this.raw.numSolverIterations;\n    }\n\n    /**\n     * Number of addition friction resolution iteration run during the last solver sub-step (default: `4`).\n     */\n    get numAdditionalFrictionIterations(): number {\n        return this.raw.numAdditionalFrictionIterations;\n    }\n\n    /**\n     * Number of internal Project Gauss Seidel (PGS) iterations run at each solver iteration (default: `1`).\n     */\n    get numInternalPgsIterations(): number {\n        return this.raw.numInternalPgsIterations;\n    }\n\n    /**\n     * Minimum number of dynamic bodies in each active island (default: `128`).\n     */\n    get minIslandSize(): number {\n        return this.raw.minIslandSize;\n    }\n\n    /**\n     * Maximum number of substeps performed by the  solver (default: `1`).\n     */\n    get maxCcdSubsteps(): number {\n        return this.raw.maxCcdSubsteps;\n    }\n\n    set dt(value: number) {\n        this.raw.dt = value;\n    }\n\n    set contact_natural_frequency(value: number) {\n        this.raw.contact_natural_frequency = value;\n    }\n\n    set lengthUnit(value: number) {\n        this.raw.lengthUnit = value;\n    }\n\n    set normalizedAllowedLinearError(value: number) {\n        this.raw.normalizedAllowedLinearError = value;\n    }\n\n    set normalizedPredictionDistance(value: number) {\n        this.raw.normalizedPredictionDistance = value;\n    }\n\n    /**\n     * Sets the number of solver iterations run by the constraints solver for calculating forces (default: `4`).\n     */\n    set numSolverIterations(value: number) {\n        this.raw.numSolverIterations = value;\n    }\n\n    /**\n     * Sets the number of addition friction resolution iteration run during the last solver sub-step (default: `4`).\n     */\n    set numAdditionalFrictionIterations(value: number) {\n        this.raw.numAdditionalFrictionIterations = value;\n    }\n\n    /**\n     * Sets the number of internal Project Gauss Seidel (PGS) iterations run at each solver iteration (default: `1`).\n     */\n    set numInternalPgsIterations(value: number) {\n        this.raw.numInternalPgsIterations = value;\n    }\n\n    set minIslandSize(value: number) {\n        this.raw.minIslandSize = value;\n    }\n\n    set maxCcdSubsteps(value: number) {\n        this.raw.maxCcdSubsteps = value;\n    }\n\n    public switchToStandardPgsSolver() {\n        this.raw.switchToStandardPgsSolver();\n    }\n\n    public switchToSmallStepsPgsSolver() {\n        this.raw.switchToSmallStepsPgsSolver();\n    }\n\n    public switchToSmallStepsPgsSolverWithoutWarmstart() {\n        this.raw.switchToSmallStepsPgsSolverWithoutWarmstart();\n    }\n}\n","import {RawImpulseJointSet} from \"../raw\";\nimport {Coarena} from \"../coarena\";\nimport {RigidBodySet} from \"./rigid_body_set\";\nimport {\n    RevoluteImpulseJoint,\n    FixedImpulseJoint,\n    ImpulseJoint,\n    ImpulseJointHandle,\n    JointData,\n    JointType,\n    PrismaticImpulseJoint,\n} from \"./impulse_joint\";\nimport {IslandManager} from \"./island_manager\";\nimport {RigidBodyHandle} from \"./rigid_body\";\nimport {Collider, ColliderHandle} from \"../geometry\";\n\n/**\n * A set of joints.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `jointSet.free()`\n * once you are done using it (and all the joints it created).\n */\nexport class ImpulseJointSet {\n    raw: RawImpulseJointSet;\n    private map: Coarena<ImpulseJoint>;\n\n    /**\n     * Release the WASM memory occupied by this joint set.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n\n    constructor(raw?: RawImpulseJointSet) {\n        this.raw = raw || new RawImpulseJointSet();\n        this.map = new Coarena<ImpulseJoint>();\n        // Initialize the map with the existing elements, if any.\n        if (raw) {\n            raw.forEachJointHandle((handle: ImpulseJointHandle) => {\n                this.map.set(handle, ImpulseJoint.newTyped(raw, null, handle));\n            });\n        }\n    }\n\n    /** @internal */\n    public finalizeDeserialization(bodies: RigidBodySet) {\n        this.map.forEach((joint) => joint.finalizeDeserialization(bodies));\n    }\n\n    /**\n     * Creates a new joint and return its integer handle.\n     *\n     * @param bodies - The set of rigid-bodies containing the bodies the joint is attached to.\n     * @param desc - The joint's parameters.\n     * @param parent1 - The handle of the first rigid-body this joint is attached to.\n     * @param parent2 - The handle of the second rigid-body this joint is attached to.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    public createJoint(\n        bodies: RigidBodySet,\n        desc: JointData,\n        parent1: RigidBodyHandle,\n        parent2: RigidBodyHandle,\n        wakeUp: boolean,\n    ): ImpulseJoint {\n        const rawParams = desc.intoRaw();\n        const handle = this.raw.createJoint(\n            rawParams,\n            parent1,\n            parent2,\n            wakeUp,\n        );\n        rawParams.free();\n        let joint = ImpulseJoint.newTyped(this.raw, bodies, handle);\n        this.map.set(handle, joint);\n        return joint;\n    }\n\n    /**\n     * Remove a joint from this set.\n     *\n     * @param handle - The integer handle of the joint.\n     * @param wakeUp - If `true`, the rigid-bodies attached by the removed joint will be woken-up automatically.\n     */\n    public remove(handle: ImpulseJointHandle, wakeUp: boolean) {\n        this.raw.remove(handle, wakeUp);\n        this.unmap(handle);\n    }\n\n    /**\n     * Calls the given closure with the integer handle of each impulse joint attached to this rigid-body.\n     *\n     * @param f - The closure called with the integer handle of each impulse joint attached to the rigid-body.\n     */\n    public forEachJointHandleAttachedToRigidBody(\n        handle: RigidBodyHandle,\n        f: (handle: ImpulseJointHandle) => void,\n    ) {\n        this.raw.forEachJointAttachedToRigidBody(handle, f);\n    }\n\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n    public unmap(handle: ImpulseJointHandle) {\n        this.map.delete(handle);\n    }\n\n    /**\n     * The number of joints on this set.\n     */\n    public len(): number {\n        return this.map.len();\n    }\n\n    /**\n     * Does this set contain a joint with the given handle?\n     *\n     * @param handle - The joint handle to check.\n     */\n    public contains(handle: ImpulseJointHandle): boolean {\n        return this.get(handle) != null;\n    }\n\n    /**\n     * Gets the joint with the given handle.\n     *\n     * Returns `null` if no joint with the specified handle exists.\n     *\n     * @param handle - The integer handle of the joint to retrieve.\n     */\n    public get(handle: ImpulseJointHandle): ImpulseJoint | null {\n        return this.map.get(handle);\n    }\n\n    /**\n     * Applies the given closure to each joint contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEach(f: (joint: ImpulseJoint) => void) {\n        this.map.forEach(f);\n    }\n\n    /**\n     * Gets all joints in the list.\n     *\n     * @returns joint list.\n     */\n    public getAll(): ImpulseJoint[] {\n        return this.map.getAll();\n    }\n}\n","import {\n    RawImpulseJointSet,\n    RawJointAxis,\n    RawJointType,\n    RawMultibodyJointSet,\n} from \"../raw\";\nimport {\n    FixedImpulseJoint,\n    ImpulseJointHandle,\n    JointType,\n    MotorModel,\n    PrismaticImpulseJoint,\n    RevoluteImpulseJoint,\n} from \"./impulse_joint\";\n\n\n/**\n * The integer identifier of a collider added to a `ColliderSet`.\n */\nexport type MultibodyJointHandle = number;\n\nexport class MultibodyJoint {\n    protected rawSet: RawMultibodyJointSet; // The MultibodyJoint won't need to free this.\n    handle: MultibodyJointHandle;\n\n    constructor(rawSet: RawMultibodyJointSet, handle: MultibodyJointHandle) {\n        this.rawSet = rawSet;\n        this.handle = handle;\n    }\n\n    public static newTyped(\n        rawSet: RawMultibodyJointSet,\n        handle: MultibodyJointHandle,\n    ): MultibodyJoint {\n        switch (rawSet.jointType(handle)) {\n            case RawJointType.Revolute:\n                return new RevoluteMultibodyJoint(rawSet, handle);\n            case RawJointType.Prismatic:\n                return new PrismaticMultibodyJoint(rawSet, handle);\n            case RawJointType.Fixed:\n                return new FixedMultibodyJoint(rawSet, handle);\n            default:\n                return new MultibodyJoint(rawSet, handle);\n        }\n    }\n\n    /**\n     * Checks if this joint is still valid (i.e. that it has\n     * not been deleted from the joint set yet).\n     */\n    public isValid(): boolean {\n        return this.rawSet.contains(this.handle);\n    }\n\n    // /**\n    //  * The unique integer identifier of the first rigid-body this joint it attached to.\n    //  */\n    // public bodyHandle1(): RigidBodyHandle {\n    //     return this.rawSet.jointBodyHandle1(this.handle);\n    // }\n    //\n    // /**\n    //  * The unique integer identifier of the second rigid-body this joint is attached to.\n    //  */\n    // public bodyHandle2(): RigidBodyHandle {\n    //     return this.rawSet.jointBodyHandle2(this.handle);\n    // }\n    //\n    // /**\n    //  * The type of this joint given as a string.\n    //  */\n    // public type(): JointType {\n    //     return this.rawSet.jointType(this.handle);\n    // }\n    //\n    //\n    //\n    // /**\n    //  * The position of the first anchor of this joint.\n    //  *\n    //  * The first anchor gives the position of the points application point on the\n    //  * local frame of the first rigid-body it is attached to.\n    //  */\n    // public anchor1(): Vector {\n    //     return VectorOps.fromRaw(this.rawSet.jointAnchor1(this.handle));\n    // }\n    //\n    // /**\n    //  * The position of the second anchor of this joint.\n    //  *\n    //  * The second anchor gives the position of the points application point on the\n    //  * local frame of the second rigid-body it is attached to.\n    //  */\n    // public anchor2(): Vector {\n    //     return VectorOps.fromRaw(this.rawSet.jointAnchor2(this.handle));\n    // }\n\n    /**\n     * Controls whether contacts are computed between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    public setContactsEnabled(enabled: boolean) {\n        this.rawSet.jointSetContactsEnabled(this.handle, enabled);\n    }\n\n    /**\n     * Indicates if contacts are enabled between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    public contactsEnabled(): boolean {\n        return this.rawSet.jointContactsEnabled(this.handle);\n    }\n}\n\nexport class UnitMultibodyJoint extends MultibodyJoint {\n    /**\n     * The axis left free by this joint.\n     */\n    protected rawAxis?(): RawJointAxis;\n\n    // /**\n    //  * Are the limits enabled for this joint?\n    //  */\n    // public limitsEnabled(): boolean {\n    //     return this.rawSet.jointLimitsEnabled(this.handle, this.rawAxis());\n    // }\n    //\n    // /**\n    //  * The min limit of this joint.\n    //  */\n    // public limitsMin(): number {\n    //     return this.rawSet.jointLimitsMin(this.handle, this.rawAxis());\n    // }\n    //\n    // /**\n    //  * The max limit of this joint.\n    //  */\n    // public limitsMax(): number {\n    //     return this.rawSet.jointLimitsMax(this.handle, this.rawAxis());\n    // }\n    //\n    // public configureMotorModel(model: MotorModel) {\n    //     this.rawSet.jointConfigureMotorModel(this.handle, this.rawAxis(), model);\n    // }\n    //\n    // public configureMotorVelocity(targetVel: number, factor: number) {\n    //     this.rawSet.jointConfigureMotorVelocity(this.handle, this.rawAxis(), targetVel, factor);\n    // }\n    //\n    // public configureMotorPosition(targetPos: number, stiffness: number, damping: number) {\n    //     this.rawSet.jointConfigureMotorPosition(this.handle, this.rawAxis(), targetPos, stiffness, damping);\n    // }\n    //\n    // public configureMotor(targetPos: number, targetVel: number, stiffness: number, damping: number) {\n    //     this.rawSet.jointConfigureMotor(this.handle, this.rawAxis(), targetPos, targetVel, stiffness, damping);\n    // }\n}\n\nexport class FixedMultibodyJoint extends MultibodyJoint {}\n\nexport class PrismaticMultibodyJoint extends UnitMultibodyJoint {\n    public rawAxis(): RawJointAxis {\n        return RawJointAxis.LinX;\n    }\n}\n\nexport class RevoluteMultibodyJoint extends UnitMultibodyJoint {\n    public rawAxis(): RawJointAxis {\n        return RawJointAxis.AngX;\n    }\n}\n\n","import {RawMultibodyJointSet} from \"../raw\";\nimport {Coarena} from \"../coarena\";\nimport {RigidBodySet} from \"./rigid_body_set\";\nimport {\n    MultibodyJoint,\n    MultibodyJointHandle,\n    RevoluteMultibodyJoint,\n    FixedMultibodyJoint,\n    PrismaticMultibodyJoint,\n} from \"./multibody_joint\";\nimport {ImpulseJointHandle, JointData, JointType} from \"./impulse_joint\";\nimport {IslandManager} from \"./island_manager\";\nimport {ColliderHandle} from \"../geometry\";\nimport {RigidBodyHandle} from \"./rigid_body\";\n\n/**\n * A set of joints.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `jointSet.free()`\n * once you are done using it (and all the joints it created).\n */\nexport class MultibodyJointSet {\n    raw: RawMultibodyJointSet;\n    private map: Coarena<MultibodyJoint>;\n\n    /**\n     * Release the WASM memory occupied by this joint set.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n\n    constructor(raw?: RawMultibodyJointSet) {\n        this.raw = raw || new RawMultibodyJointSet();\n        this.map = new Coarena<MultibodyJoint>();\n        // Initialize the map with the existing elements, if any.\n        if (raw) {\n            raw.forEachJointHandle((handle: MultibodyJointHandle) => {\n                this.map.set(handle, MultibodyJoint.newTyped(this.raw, handle));\n            });\n        }\n    }\n\n    /**\n     * Creates a new joint and return its integer handle.\n     *\n     * @param desc - The joint's parameters.\n     * @param parent1 - The handle of the first rigid-body this joint is attached to.\n     * @param parent2 - The handle of the second rigid-body this joint is attached to.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    public createJoint(\n        desc: JointData,\n        parent1: RigidBodyHandle,\n        parent2: RigidBodyHandle,\n        wakeUp: boolean,\n    ): MultibodyJoint {\n        const rawParams = desc.intoRaw();\n        const handle = this.raw.createJoint(\n            rawParams,\n            parent1,\n            parent2,\n            wakeUp,\n        );\n        rawParams.free();\n        let joint = MultibodyJoint.newTyped(this.raw, handle);\n        this.map.set(handle, joint);\n        return joint;\n    }\n\n    /**\n     * Remove a joint from this set.\n     *\n     * @param handle - The integer handle of the joint.\n     * @param wake_up - If `true`, the rigid-bodies attached by the removed joint will be woken-up automatically.\n     */\n    public remove(handle: MultibodyJointHandle, wake_up: boolean) {\n        this.raw.remove(handle, wake_up);\n        this.map.delete(handle);\n    }\n\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n    public unmap(handle: MultibodyJointHandle) {\n        this.map.delete(handle);\n    }\n\n    /**\n     * The number of joints on this set.\n     */\n    public len(): number {\n        return this.map.len();\n    }\n\n    /**\n     * Does this set contain a joint with the given handle?\n     *\n     * @param handle - The joint handle to check.\n     */\n    public contains(handle: MultibodyJointHandle): boolean {\n        return this.get(handle) != null;\n    }\n\n    /**\n     * Gets the joint with the given handle.\n     *\n     * Returns `null` if no joint with the specified handle exists.\n     *\n     * @param handle - The integer handle of the joint to retrieve.\n     */\n    public get(handle: MultibodyJointHandle): MultibodyJoint | null {\n        return this.map.get(handle);\n    }\n\n    /**\n     * Applies the given closure to each joint contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEach(f: (joint: MultibodyJoint) => void) {\n        this.map.forEach(f);\n    }\n\n    /**\n     * Calls the given closure with the integer handle of each multibody joint attached to this rigid-body.\n     *\n     * @param f - The closure called with the integer handle of each multibody joint attached to the rigid-body.\n     */\n    public forEachJointHandleAttachedToRigidBody(\n        handle: RigidBodyHandle,\n        f: (handle: MultibodyJointHandle) => void,\n    ) {\n        this.raw.forEachJointAttachedToRigidBody(handle, f);\n    }\n\n    /**\n     * Gets all joints in the list.\n     *\n     * @returns joint list.\n     */\n    public getAll(): MultibodyJoint[] {\n        return this.map.getAll();\n    }\n}\n","import {RawCCDSolver} from \"../raw\";\n\n/**\n * The CCD solver responsible for resolving Continuous Collision Detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `ccdSolver.free()`\n * once you are done using it.\n */\nexport class CCDSolver {\n    raw: RawCCDSolver;\n\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawCCDSolver) {\n        this.raw = raw || new RawCCDSolver();\n    }\n}\n","import {RawIslandManager} from \"../raw\";\nimport {RigidBodyHandle} from \"./rigid_body\";\n\n/**\n * The CCD solver responsible for resolving Continuous Collision Detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `ccdSolver.free()`\n * once you are done using it.\n */\nexport class IslandManager {\n    raw: RawIslandManager;\n\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawIslandManager) {\n        this.raw = raw || new RawIslandManager();\n    }\n\n    /**\n     * Applies the given closure to the handle of each active rigid-bodies contained by this set.\n     *\n     * A rigid-body is active if it is not sleeping, i.e., if it moved recently.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEachActiveRigidBodyHandle(f: (handle: RigidBodyHandle) => void) {\n        this.raw.forEachActiveRigidBodyHandle(f);\n    }\n}\n","import {Vector, VectorOps} from \"../math\";\nimport {\n    RawFeatureType,\n    RawRayColliderIntersection,\n    RawRayColliderHit,\n    RawRayIntersection,\n} from \"../raw\";\nimport {Collider} from \"./collider\";\nimport {FeatureType} from \"./feature\";\nimport {ColliderSet} from \"./collider_set\";\n\n/**\n * A ray. This is a directed half-line.\n */\nexport class Ray {\n    /**\n     * The starting point of the ray.\n     */\n    public origin: Vector;\n    /**\n     * The direction of propagation of the ray.\n     */\n    public dir: Vector;\n\n    /**\n     * Builds a ray from its origin and direction.\n     *\n     * @param origin - The ray's starting point.\n     * @param dir - The ray's direction of propagation.\n     */\n    constructor(origin: Vector, dir: Vector) {\n        this.origin = origin;\n        this.dir = dir;\n    }\n\n    public pointAt(t: number): Vector {\n        return {\n            x: this.origin.x + this.dir.x * t,\n            y: this.origin.y + this.dir.y * t,\n        };\n    }\n}\n\n/**\n * The intersection between a ray and a collider.\n */\nexport class RayIntersection {\n    /**\n     * The time-of-impact of the ray with the collider.\n     *\n     * The hit point is obtained from the ray's origin and direction: `origin + dir * timeOfImpact`.\n     */\n    timeOfImpact: number;\n    /**\n     * The normal of the collider at the hit point.\n     */\n    normal: Vector;\n\n    /**\n     * The type of the geometric feature the point was projected on.\n     */\n    featureType = FeatureType.Unknown;\n\n    /**\n     * The id of the geometric feature the point was projected on.\n     */\n    featureId: number | undefined = undefined;\n\n    constructor(\n        timeOfImpact: number,\n        normal: Vector,\n        featureType?: FeatureType,\n        featureId?: number,\n    ) {\n        this.timeOfImpact = timeOfImpact;\n        this.normal = normal;\n        if (featureId !== undefined) this.featureId = featureId;\n        if (featureType !== undefined) this.featureType = featureType;\n    }\n\n    public static fromRaw(raw: RawRayIntersection): RayIntersection {\n        if (!raw) return null;\n\n        const result = new RayIntersection(\n            raw.time_of_impact(),\n            VectorOps.fromRaw(raw.normal()),\n            raw.featureType() as number as FeatureType,\n            raw.featureId(),\n        );\n        raw.free();\n        return result;\n    }\n}\n\n/**\n * The intersection between a ray and a collider (includes the collider handle).\n */\nexport class RayColliderIntersection {\n    /**\n     * The collider hit by the ray.\n     */\n    collider: Collider;\n    /**\n     * The time-of-impact of the ray with the collider.\n     *\n     * The hit point is obtained from the ray's origin and direction: `origin + dir * timeOfImpact`.\n     */\n    timeOfImpact: number;\n    /**\n     * The normal of the collider at the hit point.\n     */\n    normal: Vector;\n\n    /**\n     * The type of the geometric feature the point was projected on.\n     */\n    featureType = FeatureType.Unknown;\n\n    /**\n     * The id of the geometric feature the point was projected on.\n     */\n    featureId: number | undefined = undefined;\n\n    constructor(\n        collider: Collider,\n        timeOfImpact: number,\n        normal: Vector,\n        featureType?: FeatureType,\n        featureId?: number,\n    ) {\n        this.collider = collider;\n        this.timeOfImpact = timeOfImpact;\n        this.normal = normal;\n        if (featureId !== undefined) this.featureId = featureId;\n        if (featureType !== undefined) this.featureType = featureType;\n    }\n\n    public static fromRaw(\n        colliderSet: ColliderSet,\n        raw: RawRayColliderIntersection,\n    ): RayColliderIntersection {\n        if (!raw) return null;\n\n        const result = new RayColliderIntersection(\n            colliderSet.get(raw.colliderHandle()),\n            raw.time_of_impact(),\n            VectorOps.fromRaw(raw.normal()),\n            raw.featureType() as number as FeatureType,\n            raw.featureId(),\n        );\n        raw.free();\n        return result;\n    }\n}\n\n/**\n * The time of impact between a ray and a collider.\n */\nexport class RayColliderHit {\n    /**\n     * The handle of the collider hit by the ray.\n     */\n    collider: Collider;\n    /**\n     * The time-of-impact of the ray with the collider.\n     *\n     * The hit point is obtained from the ray's origin and direction: `origin + dir * timeOfImpact`.\n     */\n    timeOfImpact: number;\n\n    constructor(collider: Collider, timeOfImpact: number) {\n        this.collider = collider;\n        this.timeOfImpact = timeOfImpact;\n    }\n\n    public static fromRaw(\n        colliderSet: ColliderSet,\n        raw: RawRayColliderHit,\n    ): RayColliderHit {\n        if (!raw) return null;\n\n        const result = new RayColliderHit(\n            colliderSet.get(raw.colliderHandle()),\n            raw.timeOfImpact(),\n        );\n        raw.free();\n        return result;\n    }\n}\n","import {Collider, ColliderHandle} from \"./collider\";\nimport {Vector, VectorOps} from \"../math\";\nimport {\n    RawFeatureType,\n    RawPointColliderProjection,\n    RawPointProjection,\n} from \"../raw\";\nimport {FeatureType} from \"./feature\";\nimport {ColliderSet} from \"./collider_set\";\n\n/**\n * The projection of a point on a collider.\n */\nexport class PointProjection {\n    /**\n     * The projection of the point on the collider.\n     */\n    point: Vector;\n    /**\n     * Is the point inside of the collider?\n     */\n    isInside: boolean;\n\n    constructor(point: Vector, isInside: boolean) {\n        this.point = point;\n        this.isInside = isInside;\n    }\n\n    public static fromRaw(raw: RawPointProjection): PointProjection {\n        if (!raw) return null;\n\n        const result = new PointProjection(\n            VectorOps.fromRaw(raw.point()),\n            raw.isInside(),\n        );\n        raw.free();\n        return result;\n    }\n}\n\n/**\n * The projection of a point on a collider (includes the collider handle).\n */\nexport class PointColliderProjection {\n    /**\n     * The collider hit by the ray.\n     */\n    collider: Collider;\n    /**\n     * The projection of the point on the collider.\n     */\n    point: Vector;\n    /**\n     * Is the point inside of the collider?\n     */\n    isInside: boolean;\n\n    /**\n     * The type of the geometric feature the point was projected on.\n     */\n    featureType = FeatureType.Unknown;\n\n    /**\n     * The id of the geometric feature the point was projected on.\n     */\n    featureId: number | undefined = undefined;\n\n    constructor(\n        collider: Collider,\n        point: Vector,\n        isInside: boolean,\n        featureType?: FeatureType,\n        featureId?: number,\n    ) {\n        this.collider = collider;\n        this.point = point;\n        this.isInside = isInside;\n        if (featureId !== undefined) this.featureId = featureId;\n        if (featureType !== undefined) this.featureType = featureType;\n    }\n\n    public static fromRaw(\n        colliderSet: ColliderSet,\n        raw: RawPointColliderProjection,\n    ): PointColliderProjection {\n        if (!raw) return null;\n\n        const result = new PointColliderProjection(\n            colliderSet.get(raw.colliderHandle()),\n            VectorOps.fromRaw(raw.point()),\n            raw.isInside(),\n            raw.featureType() as number as FeatureType,\n            raw.featureId(),\n        );\n        raw.free();\n        return result;\n    }\n}\n","import {Collider} from \"./collider\";\nimport {Vector, VectorOps} from \"../math\";\nimport {RawShapeCastHit, RawColliderShapeCastHit} from \"../raw\";\nimport {ColliderSet} from \"./collider_set\";\n\n/**\n * The intersection between a ray and a collider.\n */\nexport class ShapeCastHit {\n    /**\n     * The time of impact of the two shapes.\n     */\n    time_of_impact: number;\n    /**\n     * The local-space contact point on the first shape, at\n     * the time of impact.\n     */\n    witness1: Vector;\n    /**\n     * The local-space contact point on the second shape, at\n     * the time of impact.\n     */\n    witness2: Vector;\n    /**\n     * The local-space normal on the first shape, at\n     * the time of impact.\n     */\n    normal1: Vector;\n    /**\n     * The local-space normal on the second shape, at\n     * the time of impact.\n     */\n    normal2: Vector;\n\n    constructor(\n        time_of_impact: number,\n        witness1: Vector,\n        witness2: Vector,\n        normal1: Vector,\n        normal2: Vector,\n    ) {\n        this.time_of_impact = time_of_impact;\n        this.witness1 = witness1;\n        this.witness2 = witness2;\n        this.normal1 = normal1;\n        this.normal2 = normal2;\n    }\n\n    public static fromRaw(\n        colliderSet: ColliderSet,\n        raw: RawShapeCastHit,\n    ): ShapeCastHit {\n        if (!raw) return null;\n\n        const result = new ShapeCastHit(\n            raw.time_of_impact(),\n            VectorOps.fromRaw(raw.witness1()),\n            VectorOps.fromRaw(raw.witness2()),\n            VectorOps.fromRaw(raw.normal1()),\n            VectorOps.fromRaw(raw.normal2()),\n        );\n        raw.free();\n        return result;\n    }\n}\n\n/**\n * The intersection between a ray and a collider.\n */\nexport class ColliderShapeCastHit extends ShapeCastHit {\n    /**\n     * The handle of the collider hit by the ray.\n     */\n    collider: Collider;\n\n    constructor(\n        collider: Collider,\n        time_of_impact: number,\n        witness1: Vector,\n        witness2: Vector,\n        normal1: Vector,\n        normal2: Vector,\n    ) {\n        super(time_of_impact, witness1, witness2, normal1, normal2);\n        this.collider = collider;\n    }\n\n    public static fromRaw(\n        colliderSet: ColliderSet,\n        raw: RawColliderShapeCastHit,\n    ): ColliderShapeCastHit {\n        if (!raw) return null;\n\n        const result = new ColliderShapeCastHit(\n            colliderSet.get(raw.colliderHandle()),\n            raw.time_of_impact(),\n            VectorOps.fromRaw(raw.witness1()),\n            VectorOps.fromRaw(raw.witness2()),\n            VectorOps.fromRaw(raw.normal1()),\n            VectorOps.fromRaw(raw.normal2()),\n        );\n        raw.free();\n        return result;\n    }\n}\n","import {RawBroadPhase, RawRayColliderIntersection} from \"../raw\";\nimport {RigidBodyHandle, RigidBodySet} from \"../dynamics\";\nimport {ColliderSet} from \"./collider_set\";\nimport {Ray, RayColliderHit, RayColliderIntersection} from \"./ray\";\nimport {InteractionGroups} from \"./interaction_groups\";\nimport {ColliderHandle} from \"./collider\";\nimport {Rotation, RotationOps, Vector, VectorOps} from \"../math\";\nimport {Shape} from \"./shape\";\nimport {PointColliderProjection} from \"./point\";\nimport {ColliderShapeCastHit} from \"./toi\";\nimport {QueryFilterFlags} from \"../pipeline\";\nimport {NarrowPhase} from \"./narrow_phase\";\n\n/**\n * The broad-phase used for coarse collision-detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `broadPhase.free()`\n * once you are done using it.\n */\nexport class BroadPhase {\n    raw: RawBroadPhase;\n\n    /**\n     * Release the WASM memory occupied by this broad-phase.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawBroadPhase) {\n        this.raw = raw || new RawBroadPhase();\n    }\n\n    /**\n     * Find the closest intersection between a ray and a set of collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param filter - The callback to filter out which collider will be hit.\n     */\n    public castRay(\n        narrowPhase: NarrowPhase,\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ): RayColliderHit | null {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = RayColliderHit.fromRaw(\n            colliders,\n            this.raw.castRay(\n                narrowPhase.raw,\n                bodies.raw,\n                colliders.raw,\n                rawOrig,\n                rawDir,\n                maxToi,\n                solid,\n                filterFlags,\n                filterGroups,\n                filterExcludeCollider,\n                filterExcludeRigidBody,\n                filterPredicate,\n            ),\n        );\n\n        rawOrig.free();\n        rawDir.free();\n\n        return result;\n    }\n\n    /**\n     * Find the closest intersection between a ray and a set of collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     */\n    public castRayAndGetNormal(\n        narrowPhase: NarrowPhase,\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ): RayColliderIntersection | null {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = RayColliderIntersection.fromRaw(\n            colliders,\n            this.raw.castRayAndGetNormal(\n                narrowPhase.raw,\n                bodies.raw,\n                colliders.raw,\n                rawOrig,\n                rawDir,\n                maxToi,\n                solid,\n                filterFlags,\n                filterGroups,\n                filterExcludeCollider,\n                filterExcludeRigidBody,\n                filterPredicate,\n            ),\n        );\n\n        rawOrig.free();\n        rawDir.free();\n\n        return result;\n    }\n\n    /**\n     * Cast a ray and collects all the intersections between a ray and the scene.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param callback - The callback called once per hit (in no particular order) between a ray and a collider.\n     *   If this callback returns `false`, then the cast will stop and no further hits will be detected/reported.\n     */\n    public intersectionsWithRay(\n        narrowPhase: NarrowPhase,\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        callback: (intersect: RayColliderIntersection) => boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ) {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let rawCallback = (rawInter: RawRayColliderIntersection) => {\n            return callback(\n                RayColliderIntersection.fromRaw(colliders, rawInter),\n            );\n        };\n\n        this.raw.intersectionsWithRay(\n            narrowPhase.raw,\n            bodies.raw,\n            colliders.raw,\n            rawOrig,\n            rawDir,\n            maxToi,\n            solid,\n            rawCallback,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider,\n            filterExcludeRigidBody,\n            filterPredicate,\n        );\n\n        rawOrig.free();\n        rawDir.free();\n    }\n\n    /**\n     * Gets the handle of up to one collider intersecting the given shape.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The position of the shape used for the intersection test.\n     * @param shapeRot - The orientation of the shape used for the intersection test.\n     * @param shape - The shape used for the intersection test.\n     * @param groups - The bit groups and filter associated to the ray, in order to only\n     *   hit the colliders with collision groups compatible with the ray's group.\n     */\n    public intersectionWithShape(\n        narrowPhase: NarrowPhase,\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        shapePos: Vector,\n        shapeRot: Rotation,\n        shape: Shape,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ): ColliderHandle | null {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawShape = shape.intoRaw();\n        let result = this.raw.intersectionWithShape(\n            narrowPhase.raw,\n            bodies.raw,\n            colliders.raw,\n            rawPos,\n            rawRot,\n            rawShape,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider,\n            filterExcludeRigidBody,\n            filterPredicate,\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawShape.free();\n\n        return result;\n    }\n\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    public projectPoint(\n        narrowPhase: NarrowPhase,\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        point: Vector,\n        solid: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ): PointColliderProjection | null {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = PointColliderProjection.fromRaw(\n            colliders,\n            this.raw.projectPoint(\n                narrowPhase.raw,\n                bodies.raw,\n                colliders.raw,\n                rawPoint,\n                solid,\n                filterFlags,\n                filterGroups,\n                filterExcludeCollider,\n                filterExcludeRigidBody,\n                filterPredicate,\n            ),\n        );\n\n        rawPoint.free();\n\n        return result;\n    }\n\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point to project.\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    public projectPointAndGetFeature(\n        narrowPhase: NarrowPhase,\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        point: Vector,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ): PointColliderProjection | null {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = PointColliderProjection.fromRaw(\n            colliders,\n            this.raw.projectPointAndGetFeature(\n                narrowPhase.raw,\n                bodies.raw,\n                colliders.raw,\n                rawPoint,\n                filterFlags,\n                filterGroups,\n                filterExcludeCollider,\n                filterExcludeRigidBody,\n                filterPredicate,\n            ),\n        );\n\n        rawPoint.free();\n\n        return result;\n    }\n\n    /**\n     * Find all the colliders containing the given point.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point used for the containment test.\n     * @param groups - The bit groups and filter associated to the point to test, in order to only\n     *   test on colliders with collision groups compatible with the ray's group.\n     * @param callback - A function called with the handles of each collider with a shape\n     *   containing the `point`.\n     */\n    public intersectionsWithPoint(\n        narrowPhase: NarrowPhase,\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        point: Vector,\n        callback: (handle: ColliderHandle) => boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ) {\n        let rawPoint = VectorOps.intoRaw(point);\n\n        this.raw.intersectionsWithPoint(\n            narrowPhase.raw,\n            bodies.raw,\n            colliders.raw,\n            rawPoint,\n            callback,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider,\n            filterExcludeRigidBody,\n            filterPredicate,\n        );\n\n        rawPoint.free();\n    }\n\n    /**\n     * Casts a shape at a constant linear velocity and retrieve the first collider it hits.\n     * This is similar to ray-casting except that we are casting a whole shape instead of\n     * just a point (the ray origin).\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The initial position of the shape to cast.\n     * @param shapeRot - The initial rotation of the shape to cast.\n     * @param shapeVel - The constant velocity of the shape to cast (i.e. the cast direction).\n     * @param shape - The shape to cast.\n     * @param targetDistance − If the shape moves closer to this distance from a collider, a hit\n     *                       will be returned.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast won’t immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that it’s on a path to exit that penetration state.\n     * @param groups - The bit groups and filter associated to the shape to cast, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     */\n    public castShape(\n        narrowPhase: NarrowPhase,\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        shapePos: Vector,\n        shapeRot: Rotation,\n        shapeVel: Vector,\n        shape: Shape,\n        targetDistance: number,\n        maxToi: number,\n        stopAtPenetration: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ): ColliderShapeCastHit | null {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawVel = VectorOps.intoRaw(shapeVel);\n        let rawShape = shape.intoRaw();\n\n        let result = ColliderShapeCastHit.fromRaw(\n            colliders,\n            this.raw.castShape(\n                narrowPhase.raw,\n                bodies.raw,\n                colliders.raw,\n                rawPos,\n                rawRot,\n                rawVel,\n                rawShape,\n                targetDistance,\n                maxToi,\n                stopAtPenetration,\n                filterFlags,\n                filterGroups,\n                filterExcludeCollider,\n                filterExcludeRigidBody,\n                filterPredicate,\n            ),\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawVel.free();\n        rawShape.free();\n\n        return result;\n    }\n\n    /**\n     * Retrieve all the colliders intersecting the given shape.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The position of the shape to test.\n     * @param shapeRot - The orientation of the shape to test.\n     * @param shape - The shape to test.\n     * @param groups - The bit groups and filter associated to the shape to test, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     * @param callback - A function called with the handles of each collider intersecting the `shape`.\n     */\n    public intersectionsWithShape(\n        narrowPhase: NarrowPhase,\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        shapePos: Vector,\n        shapeRot: Rotation,\n        shape: Shape,\n        callback: (handle: ColliderHandle) => boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawShape = shape.intoRaw();\n\n        this.raw.intersectionsWithShape(\n            narrowPhase.raw,\n            bodies.raw,\n            colliders.raw,\n            rawPos,\n            rawRot,\n            rawShape,\n            callback,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider,\n            filterExcludeRigidBody,\n            filterPredicate,\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawShape.free();\n    }\n\n    /**\n     * Finds the handles of all the colliders with an AABB intersecting the given AABB.\n     *\n     * @param aabbCenter - The center of the AABB to test.\n     * @param aabbHalfExtents - The half-extents of the AABB to test.\n     * @param callback - The callback that will be called with the handles of all the colliders\n     *                   currently intersecting the given AABB.\n     */\n    public collidersWithAabbIntersectingAabb(\n        narrowPhase: NarrowPhase,\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        aabbCenter: Vector,\n        aabbHalfExtents: Vector,\n        callback: (handle: ColliderHandle) => boolean,\n    ) {\n        let rawCenter = VectorOps.intoRaw(aabbCenter);\n        let rawHalfExtents = VectorOps.intoRaw(aabbHalfExtents);\n        this.raw.collidersWithAabbIntersectingAabb(\n            narrowPhase.raw,\n            bodies.raw,\n            colliders.raw,\n            rawCenter,\n            rawHalfExtents,\n            callback,\n        );\n        rawCenter.free();\n        rawHalfExtents.free();\n    }\n}\n","import {RawNarrowPhase, RawContactManifold} from \"../raw\";\nimport {ColliderHandle} from \"./collider\";\nimport {Vector, VectorOps} from \"../math\";\n\n/**\n * The narrow-phase used for precise collision-detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `narrowPhase.free()`\n * once you are done using it.\n */\nexport class NarrowPhase {\n    raw: RawNarrowPhase;\n    tempManifold: TempContactManifold;\n\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawNarrowPhase) {\n        this.raw = raw || new RawNarrowPhase();\n        this.tempManifold = new TempContactManifold(null);\n    }\n\n    /**\n     * Enumerates all the colliders potentially in contact with the given collider.\n     *\n     * @param collider1 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each collider that is in contact with `collider1`.\n     */\n    public contactPairsWith(\n        collider1: ColliderHandle,\n        f: (collider2: ColliderHandle) => void,\n    ) {\n        this.raw.contact_pairs_with(collider1, f);\n    }\n\n    /**\n     * Enumerates all the colliders intersecting the given colliders, assuming one of them\n     * is a sensor.\n     */\n    public intersectionPairsWith(\n        collider1: ColliderHandle,\n        f: (collider2: ColliderHandle) => void,\n    ) {\n        this.raw.intersection_pairs_with(collider1, f);\n    }\n\n    /**\n     * Iterates through all the contact manifolds between the given pair of colliders.\n     *\n     * @param collider1 - The first collider involved in the contact.\n     * @param collider2 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each contact manifold between the two colliders. If the second argument\n     *            passed to this closure is `true`, then the contact manifold data is flipped, i.e., methods like `localNormal1`\n     *            actually apply to the `collider2` and fields like `localNormal2` apply to the `collider1`.\n     */\n    public contactPair(\n        collider1: ColliderHandle,\n        collider2: ColliderHandle,\n        f: (manifold: TempContactManifold, flipped: boolean) => void,\n    ) {\n        const rawPair = this.raw.contact_pair(collider1, collider2);\n\n        if (!!rawPair) {\n            const flipped = rawPair.collider1() != collider1;\n\n            let i;\n            for (i = 0; i < rawPair.numContactManifolds(); ++i) {\n                this.tempManifold.raw = rawPair.contactManifold(i);\n                if (!!this.tempManifold.raw) {\n                    f(this.tempManifold, flipped);\n                }\n\n                // SAFETY: The RawContactManifold stores a raw pointer that will be invalidated\n                //         at the next timestep. So we must be sure to free the pair here\n                //         to avoid unsoundness in the Rust code.\n                this.tempManifold.free();\n            }\n            rawPair.free();\n        }\n    }\n\n    /**\n     * Returns `true` if `collider1` and `collider2` intersect and at least one of them is a sensor.\n     * @param collider1 − The first collider involved in the intersection.\n     * @param collider2 − The second collider involved in the intersection.\n     */\n    public intersectionPair(\n        collider1: ColliderHandle,\n        collider2: ColliderHandle,\n    ): boolean {\n        return this.raw.intersection_pair(collider1, collider2);\n    }\n}\n\nexport class TempContactManifold {\n    raw: RawContactManifold;\n\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw: RawContactManifold) {\n        this.raw = raw;\n    }\n\n    public normal(): Vector {\n        return VectorOps.fromRaw(this.raw.normal());\n    }\n\n    public localNormal1(): Vector {\n        return VectorOps.fromRaw(this.raw.local_n1());\n    }\n\n    public localNormal2(): Vector {\n        return VectorOps.fromRaw(this.raw.local_n2());\n    }\n\n    public subshape1(): number {\n        return this.raw.subshape1();\n    }\n\n    public subshape2(): number {\n        return this.raw.subshape2();\n    }\n\n    public numContacts(): number {\n        return this.raw.num_contacts();\n    }\n\n    public localContactPoint1(i: number): Vector | null {\n        return VectorOps.fromRaw(this.raw.contact_local_p1(i));\n    }\n\n    public localContactPoint2(i: number): Vector | null {\n        return VectorOps.fromRaw(this.raw.contact_local_p2(i));\n    }\n\n    public contactDist(i: number): number {\n        return this.raw.contact_dist(i);\n    }\n\n    public contactFid1(i: number): number {\n        return this.raw.contact_fid1(i);\n    }\n\n    public contactFid2(i: number): number {\n        return this.raw.contact_fid2(i);\n    }\n\n    public contactImpulse(i: number): number {\n        return this.raw.contact_impulse(i);\n    }\n\n    // #if DIM2\n    public contactTangentImpulse(i: number): number {\n        return this.raw.contact_tangent_impulse(i);\n    }\n    // #endif\n\n\n    public numSolverContacts(): number {\n        return this.raw.num_solver_contacts();\n    }\n\n    public solverContactPoint(i: number): Vector {\n        return VectorOps.fromRaw(this.raw.solver_contact_point(i));\n    }\n\n    public solverContactDist(i: number): number {\n        return this.raw.solver_contact_dist(i);\n    }\n\n    public solverContactFriction(i: number): number {\n        return this.raw.solver_contact_friction(i);\n    }\n\n    public solverContactRestitution(i: number): number {\n        return this.raw.solver_contact_restitution(i);\n    }\n\n    public solverContactTangentVelocity(i: number): Vector {\n        return VectorOps.fromRaw(this.raw.solver_contact_tangent_velocity(i));\n    }\n}\n","import {Vector, VectorOps} from \"../math\";\nimport {RawShapeContact} from \"../raw\";\n\n/**\n * The contact info between two shapes.\n */\nexport class ShapeContact {\n    /**\n     * Distance between the two contact points.\n     * If this is negative, this contact represents a penetration.\n     */\n    distance: number;\n\n    /**\n     * Position of the contact on the first shape.\n     */\n    point1: Vector;\n\n    /**\n     * Position of the contact on the second shape.\n     */\n    point2: Vector;\n\n    /**\n     * Contact normal, pointing towards the exterior of the first shape.\n     */\n    normal1: Vector;\n\n    /**\n     * Contact normal, pointing towards the exterior of the second shape.\n     * If these contact data are expressed in world-space, this normal is equal to -normal1.\n     */\n    normal2: Vector;\n\n    constructor(\n        dist: number,\n        point1: Vector,\n        point2: Vector,\n        normal1: Vector,\n        normal2: Vector,\n    ) {\n        this.distance = dist;\n        this.point1 = point1;\n        this.point2 = point2;\n        this.normal1 = normal1;\n        this.normal2 = normal2;\n    }\n\n    public static fromRaw(raw: RawShapeContact): ShapeContact {\n        if (!raw) return null;\n\n        const result = new ShapeContact(\n            raw.distance(),\n            VectorOps.fromRaw(raw.point1()),\n            VectorOps.fromRaw(raw.point2()),\n            VectorOps.fromRaw(raw.normal1()),\n            VectorOps.fromRaw(raw.normal2()),\n        );\n        raw.free();\n        return result;\n    }\n}\n","import {RawPhysicsPipeline} from \"../raw\";\nimport {Vector, VectorOps} from \"../math\";\nimport {\n    IntegrationParameters,\n    ImpulseJointSet,\n    MultibodyJointSet,\n    RigidBodyHandle,\n    RigidBodySet,\n    CCDSolver,\n    IslandManager,\n} from \"../dynamics\";\nimport {\n    BroadPhase,\n    ColliderHandle,\n    ColliderSet,\n    NarrowPhase,\n} from \"../geometry\";\nimport {EventQueue} from \"./event_queue\";\nimport {PhysicsHooks} from \"./physics_hooks\";\n\nexport class PhysicsPipeline {\n    raw: RawPhysicsPipeline;\n\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawPhysicsPipeline) {\n        this.raw = raw || new RawPhysicsPipeline();\n    }\n\n    public step(\n        gravity: Vector,\n        integrationParameters: IntegrationParameters,\n        islands: IslandManager,\n        broadPhase: BroadPhase,\n        narrowPhase: NarrowPhase,\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        impulseJoints: ImpulseJointSet,\n        multibodyJoints: MultibodyJointSet,\n        ccdSolver: CCDSolver,\n        eventQueue?: EventQueue,\n        hooks?: PhysicsHooks,\n    ) {\n        let rawG = VectorOps.intoRaw(gravity);\n\n        if (!!eventQueue) {\n            this.raw.stepWithEvents(\n                rawG,\n                integrationParameters.raw,\n                islands.raw,\n                broadPhase.raw,\n                narrowPhase.raw,\n                bodies.raw,\n                colliders.raw,\n                impulseJoints.raw,\n                multibodyJoints.raw,\n                ccdSolver.raw,\n                eventQueue.raw,\n                hooks,\n                !!hooks ? hooks.filterContactPair : null,\n                !!hooks ? hooks.filterIntersectionPair : null,\n            );\n        } else {\n            this.raw.step(\n                rawG,\n                integrationParameters.raw,\n                islands.raw,\n                broadPhase.raw,\n                narrowPhase.raw,\n                bodies.raw,\n                colliders.raw,\n                impulseJoints.raw,\n                multibodyJoints.raw,\n                ccdSolver.raw,\n            );\n        }\n\n        rawG.free();\n    }\n}\n","import {RawSerializationPipeline} from \"../raw\";\nimport {Vector, VectorOps} from \"../math\";\nimport {\n    IntegrationParameters,\n    IslandManager,\n    ImpulseJointSet,\n    MultibodyJointSet,\n    RigidBodySet,\n} from \"../dynamics\";\nimport {BroadPhase, ColliderSet, NarrowPhase} from \"../geometry\";\nimport {World} from \"./world\";\n\n/**\n * A pipeline for serializing the physics scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `serializationPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class SerializationPipeline {\n    raw: RawSerializationPipeline;\n\n    /**\n     * Release the WASM memory occupied by this serialization pipeline.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawSerializationPipeline) {\n        this.raw = raw || new RawSerializationPipeline();\n    }\n\n    /**\n     * Serialize a complete physics state into a single byte array.\n     * @param gravity - The current gravity affecting the simulation.\n     * @param integrationParameters - The integration parameters of the simulation.\n     * @param broadPhase - The broad-phase of the simulation.\n     * @param narrowPhase - The narrow-phase of the simulation.\n     * @param bodies - The rigid-bodies taking part into the simulation.\n     * @param colliders - The colliders taking part into the simulation.\n     * @param impulseJoints - The impulse joints taking part into the simulation.\n     * @param multibodyJoints - The multibody joints taking part into the simulation.\n     */\n    public serializeAll(\n        gravity: Vector,\n        integrationParameters: IntegrationParameters,\n        islands: IslandManager,\n        broadPhase: BroadPhase,\n        narrowPhase: NarrowPhase,\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        impulseJoints: ImpulseJointSet,\n        multibodyJoints: MultibodyJointSet,\n    ): Uint8Array {\n        let rawGra = VectorOps.intoRaw(gravity);\n\n        const res = this.raw.serializeAll(\n            rawGra,\n            integrationParameters.raw,\n            islands.raw,\n            broadPhase.raw,\n            narrowPhase.raw,\n            bodies.raw,\n            colliders.raw,\n            impulseJoints.raw,\n            multibodyJoints.raw,\n        );\n        rawGra.free();\n\n        return res;\n    }\n\n    /**\n     * Deserialize the complete physics state from a single byte array.\n     *\n     * @param data - The byte array to deserialize.\n     */\n    public deserializeAll(data: Uint8Array): World {\n        return World.fromRaw(this.raw.deserializeAll(data));\n    }\n}\n","import {RawDebugRenderPipeline} from \"../raw\";\nimport {Vector, VectorOps} from \"../math\";\nimport {\n    IntegrationParameters,\n    IslandManager,\n    ImpulseJointSet,\n    MultibodyJointSet,\n    RigidBodySet,\n} from \"../dynamics\";\nimport {BroadPhase, Collider, ColliderSet, NarrowPhase} from \"../geometry\";\nimport {QueryFilterFlags} from \"./query_pipeline\";\n\n/**\n * The vertex and color buffers for debug-redering the physics scene.\n */\nexport class DebugRenderBuffers {\n    /**\n     * The lines to render. This is a flat array containing all the lines\n     * to render. Each line is described as two consecutive point. Each\n     * point is described as two (in 2D) or three (in 3D) consecutive\n     * floats. For example, in 2D, the array: `[1, 2, 3, 4, 5, 6, 7, 8]`\n     * describes the two segments `[[1, 2], [3, 4]]` and `[[5, 6], [7, 8]]`.\n     */\n    public vertices: Float32Array;\n    /**\n     * The color buffer. There is one color per vertex, and each color\n     * has four consecutive components (in RGBA format).\n     */\n    public colors: Float32Array;\n\n    constructor(vertices: Float32Array, colors: Float32Array) {\n        this.vertices = vertices;\n        this.colors = colors;\n    }\n}\n\n/**\n * A pipeline for rendering the physics scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `debugRenderPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class DebugRenderPipeline {\n    raw: RawDebugRenderPipeline;\n    public vertices: Float32Array;\n    public colors: Float32Array;\n\n    /**\n     * Release the WASM memory occupied by this serialization pipeline.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n        this.vertices = undefined;\n        this.colors = undefined;\n    }\n\n    constructor(raw?: RawDebugRenderPipeline) {\n        this.raw = raw || new RawDebugRenderPipeline();\n    }\n\n    public render(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        impulse_joints: ImpulseJointSet,\n        multibody_joints: MultibodyJointSet,\n        narrow_phase: NarrowPhase,\n        filterFlags?: QueryFilterFlags,\n        filterPredicate?: (collider: Collider) => boolean,\n    ) {\n        this.raw.render(\n            bodies.raw,\n            colliders.raw,\n            impulse_joints.raw,\n            multibody_joints.raw,\n            narrow_phase.raw,\n            filterFlags,\n            colliders.castClosure(filterPredicate),\n        );\n        this.vertices = this.raw.vertices();\n        this.colors = this.raw.colors();\n    }\n}\n","import {RawKinematicCharacterController, RawCharacterCollision} from \"../raw\";\nimport {Rotation, Vector, VectorOps} from \"../math\";\nimport {\n    BroadPhase,\n    Collider,\n    ColliderSet,\n    InteractionGroups,\n    NarrowPhase,\n    Shape,\n} from \"../geometry\";\nimport {QueryFilterFlags, World} from \"../pipeline\";\nimport {IntegrationParameters, RigidBody, RigidBodySet} from \"../dynamics\";\n\n/**\n * A collision between the character and an obstacle hit on its path.\n */\nexport class CharacterCollision {\n    /** The collider involved in the collision. Null if the collider no longer exists in the physics world. */\n    public collider: Collider | null;\n    /** The translation delta applied to the character before this collision took place. */\n    public translationDeltaApplied: Vector;\n    /** The translation delta the character would move after this collision if there is no other obstacles. */\n    public translationDeltaRemaining: Vector;\n    /** The time-of-impact between the character and the obstacles. */\n    public toi: number;\n    /** The world-space contact point on the collider when the collision happens. */\n    public witness1: Vector;\n    /** The local-space contact point on the character when the collision happens. */\n    public witness2: Vector;\n    /** The world-space outward contact normal on the collider when the collision happens. */\n    public normal1: Vector;\n    /** The local-space outward contact normal on the character when the collision happens. */\n    public normal2: Vector;\n}\n\n/**\n * A character controller for controlling kinematic bodies and parentless colliders by hitting\n * and sliding against obstacles.\n */\nexport class KinematicCharacterController {\n    private raw: RawKinematicCharacterController;\n    private rawCharacterCollision: RawCharacterCollision;\n\n    private params: IntegrationParameters;\n    private broadPhase: BroadPhase;\n    private narrowPhase: NarrowPhase;\n    private bodies: RigidBodySet;\n    private colliders: ColliderSet;\n    private _applyImpulsesToDynamicBodies: boolean;\n    private _characterMass: number | null;\n\n    constructor(\n        offset: number,\n        params: IntegrationParameters,\n        broadPhase: BroadPhase,\n        narrowPhase: NarrowPhase,\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n    ) {\n        this.params = params;\n        this.bodies = bodies;\n        this.colliders = colliders;\n        this.broadPhase = broadPhase;\n        this.narrowPhase = narrowPhase;\n        this.raw = new RawKinematicCharacterController(offset);\n        this.rawCharacterCollision = new RawCharacterCollision();\n        this._applyImpulsesToDynamicBodies = false;\n        this._characterMass = null;\n    }\n\n    /** @internal */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n            this.rawCharacterCollision.free();\n        }\n\n        this.raw = undefined;\n        this.rawCharacterCollision = undefined;\n    }\n\n    /**\n     * The direction that goes \"up\". Used to determine where the floor is, and the floor’s angle.\n     */\n    public up(): Vector {\n        return this.raw.up();\n    }\n\n    /**\n     * Sets the direction that goes \"up\". Used to determine where the floor is, and the floor’s angle.\n     */\n    public setUp(vector: Vector) {\n        let rawVect = VectorOps.intoRaw(vector);\n        return this.raw.setUp(rawVect);\n        rawVect.free();\n    }\n\n    public applyImpulsesToDynamicBodies(): boolean {\n        return this._applyImpulsesToDynamicBodies;\n    }\n\n    public setApplyImpulsesToDynamicBodies(enabled: boolean) {\n        this._applyImpulsesToDynamicBodies = enabled;\n    }\n\n    /**\n     * Returns the custom value of the character mass, if it was set by `this.setCharacterMass`.\n     */\n    public characterMass(): number | null {\n        return this._characterMass;\n    }\n\n    /**\n     * Set the mass of the character to be used for impulse resolution if `self.applyImpulsesToDynamicBodies`\n     * is set to `true`.\n     *\n     * If no character mass is set explicitly (or if it is set to `null`) it is automatically assumed to be equal\n     * to the mass of the rigid-body the character collider is attached to; or equal to 0 if the character collider\n     * isn’t attached to any rigid-body.\n     *\n     * @param mass - The mass to set.\n     */\n    public setCharacterMass(mass: number | null) {\n        this._characterMass = mass;\n    }\n\n    /**\n     * A small gap to preserve between the character and its surroundings.\n     *\n     * This value should not be too large to avoid visual artifacts, but shouldn’t be too small\n     * (must not be zero) to improve numerical stability of the character controller.\n     */\n    public offset(): number {\n        return this.raw.offset();\n    }\n\n    /**\n     * Sets a small gap to preserve between the character and its surroundings.\n     *\n     * This value should not be too large to avoid visual artifacts, but shouldn’t be too small\n     * (must not be zero) to improve numerical stability of the character controller.\n     */\n    public setOffset(value: number) {\n        this.raw.setOffset(value);\n    }\n\n    /// Increase this number if your character appears to get stuck when sliding against surfaces.\n    ///\n    /// This is a small distance applied to the movement toward the contact normals of shapes hit\n    /// by the character controller. This helps shape-casting not getting stuck in an always-penetrating\n    /// state during the sliding calculation.\n    ///\n    /// This value should remain fairly small since it can introduce artificial \"bumps\" when sliding\n    /// along a flat surface.\n    public normalNudgeFactor(): number {\n        return this.raw.normalNudgeFactor();\n    }\n\n    /// Increase this number if your character appears to get stuck when sliding against surfaces.\n    ///\n    /// This is a small distance applied to the movement toward the contact normals of shapes hit\n    /// by the character controller. This helps shape-casting not getting stuck in an always-penetrating\n    /// state during the sliding calculation.\n    ///\n    /// This value should remain fairly small since it can introduce artificial \"bumps\" when sliding\n    /// along a flat surface.\n    public setNormalNudgeFactor(value: number) {\n        this.raw.setNormalNudgeFactor(value);\n    }\n\n    /**\n     * Is sliding against obstacles enabled?\n     */\n    public slideEnabled(): boolean {\n        return this.raw.slideEnabled();\n    }\n\n    /**\n     * Enable or disable sliding against obstacles.\n     */\n    public setSlideEnabled(enabled: boolean) {\n        this.raw.setSlideEnabled(enabled);\n    }\n\n    /**\n     * The maximum step height a character can automatically step over.\n     */\n    public autostepMaxHeight(): number | null {\n        return this.raw.autostepMaxHeight();\n    }\n\n    /**\n     * The minimum width of free space that must be available after stepping on a stair.\n     */\n    public autostepMinWidth(): number | null {\n        return this.raw.autostepMinWidth();\n    }\n\n    /**\n     * Can the character automatically step over dynamic bodies too?\n     */\n    public autostepIncludesDynamicBodies(): boolean | null {\n        return this.raw.autostepIncludesDynamicBodies();\n    }\n\n    /**\n     * Is automatically stepping over small objects enabled?\n     */\n    public autostepEnabled(): boolean {\n        return this.raw.autostepEnabled();\n    }\n\n    /**\n     * Enabled automatically stepping over small objects.\n     *\n     * @param maxHeight - The maximum step height a character can automatically step over.\n     * @param minWidth - The minimum width of free space that must be available after stepping on a stair.\n     * @param includeDynamicBodies - Can the character automatically step over dynamic bodies too?\n     */\n    public enableAutostep(\n        maxHeight: number,\n        minWidth: number,\n        includeDynamicBodies: boolean,\n    ) {\n        this.raw.enableAutostep(maxHeight, minWidth, includeDynamicBodies);\n    }\n\n    /**\n     * Disable automatically stepping over small objects.\n     */\n    public disableAutostep() {\n        return this.raw.disableAutostep();\n    }\n\n    /**\n     * The maximum angle (radians) between the floor’s normal and the `up` vector that the\n     * character is able to climb.\n     */\n    public maxSlopeClimbAngle(): number {\n        return this.raw.maxSlopeClimbAngle();\n    }\n\n    /**\n     * Sets the maximum angle (radians) between the floor’s normal and the `up` vector that the\n     * character is able to climb.\n     */\n    public setMaxSlopeClimbAngle(angle: number) {\n        this.raw.setMaxSlopeClimbAngle(angle);\n    }\n\n    /**\n     * The minimum angle (radians) between the floor’s normal and the `up` vector before the\n     * character starts to slide down automatically.\n     */\n    public minSlopeSlideAngle(): number {\n        return this.raw.minSlopeSlideAngle();\n    }\n\n    /**\n     * Sets the minimum angle (radians) between the floor’s normal and the `up` vector before the\n     * character starts to slide down automatically.\n     */\n    public setMinSlopeSlideAngle(angle: number) {\n        this.raw.setMinSlopeSlideAngle(angle);\n    }\n\n    /**\n     * If snap-to-ground is enabled, should the character be automatically snapped to the ground if\n     * the distance between the ground and its feet are smaller than the specified threshold?\n     */\n    public snapToGroundDistance(): number | null {\n        return this.raw.snapToGroundDistance();\n    }\n\n    /**\n     * Enables automatically snapping the character to the ground if the distance between\n     * the ground and its feet are smaller than the specified threshold.\n     */\n    public enableSnapToGround(distance: number) {\n        this.raw.enableSnapToGround(distance);\n    }\n\n    /**\n     * Disables automatically snapping the character to the ground.\n     */\n    public disableSnapToGround() {\n        this.raw.disableSnapToGround();\n    }\n\n    /**\n     * Is automatically snapping the character to the ground enabled?\n     */\n    public snapToGroundEnabled(): boolean {\n        return this.raw.snapToGroundEnabled();\n    }\n\n    /**\n     * Computes the movement the given collider is able to execute after hitting and sliding on obstacles.\n     *\n     * @param collider - The collider to move.\n     * @param desiredTranslationDelta - The desired collider movement.\n     * @param filterFlags - Flags for excluding whole subsets of colliders from the obstacles taken into account.\n     * @param filterGroups - Groups for excluding colliders with incompatible collision groups from the obstacles\n     *                       taken into account.\n     * @param filterPredicate - Any collider for which this closure returns `false` will be excluded from the\n     *                          obstacles taken into account.\n     */\n    public computeColliderMovement(\n        collider: Collider,\n        desiredTranslationDelta: Vector,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterPredicate?: (collider: Collider) => boolean,\n    ) {\n        let rawTranslationDelta = VectorOps.intoRaw(desiredTranslationDelta);\n        this.raw.computeColliderMovement(\n            this.params.dt,\n            this.broadPhase.raw,\n            this.narrowPhase.raw,\n            this.bodies.raw,\n            this.colliders.raw,\n            collider.handle,\n            rawTranslationDelta,\n            this._applyImpulsesToDynamicBodies,\n            this._characterMass,\n            filterFlags,\n            filterGroups,\n            this.colliders.castClosure(filterPredicate),\n        );\n        rawTranslationDelta.free();\n    }\n\n    /**\n     * The movement computed by the last call to `this.computeColliderMovement`.\n     */\n    public computedMovement(): Vector {\n        return VectorOps.fromRaw(this.raw.computedMovement());\n    }\n\n    /**\n     * The result of ground detection computed by the last call to `this.computeColliderMovement`.\n     */\n    public computedGrounded(): boolean {\n        return this.raw.computedGrounded();\n    }\n\n    /**\n     * The number of collisions against obstacles detected along the path of the last call\n     * to `this.computeColliderMovement`.\n     */\n    public numComputedCollisions(): number {\n        return this.raw.numComputedCollisions();\n    }\n\n    /**\n     * Returns the collision against one of the obstacles detected along the path of the last\n     * call to `this.computeColliderMovement`.\n     *\n     * @param i - The i-th collision will be returned.\n     * @param out - If this argument is set, it will be filled with the collision information.\n     */\n    public computedCollision(\n        i: number,\n        out?: CharacterCollision,\n    ): CharacterCollision | null {\n        if (!this.raw.computedCollision(i, this.rawCharacterCollision)) {\n            return null;\n        } else {\n            let c = this.rawCharacterCollision;\n            out = out ?? new CharacterCollision();\n            out.translationDeltaApplied = VectorOps.fromRaw(\n                c.translationDeltaApplied(),\n            );\n            out.translationDeltaRemaining = VectorOps.fromRaw(\n                c.translationDeltaRemaining(),\n            );\n            out.toi = c.toi();\n            out.witness1 = VectorOps.fromRaw(c.worldWitness1());\n            out.witness2 = VectorOps.fromRaw(c.worldWitness2());\n            out.normal1 = VectorOps.fromRaw(c.worldNormal1());\n            out.normal2 = VectorOps.fromRaw(c.worldNormal2());\n            out.collider = this.colliders.get(c.handle());\n            return out;\n        }\n    }\n}\n","import {\n    RawBroadPhase,\n    RawCCDSolver,\n    RawColliderSet,\n    RawDeserializedWorld,\n    RawIntegrationParameters,\n    RawIslandManager,\n    RawImpulseJointSet,\n    RawMultibodyJointSet,\n    RawNarrowPhase,\n    RawPhysicsPipeline,\n    RawRigidBodySet,\n    RawSerializationPipeline,\n    RawDebugRenderPipeline,\n} from \"../raw\";\n\nimport {\n    BroadPhase,\n    Collider,\n    ColliderDesc,\n    ColliderHandle,\n    ColliderSet,\n    InteractionGroups,\n    NarrowPhase,\n    PointColliderProjection,\n    Ray,\n    RayColliderIntersection,\n    RayColliderHit,\n    Shape,\n    ColliderShapeCastHit,\n    TempContactManifold,\n} from \"../geometry\";\nimport {\n    CCDSolver,\n    IntegrationParameters,\n    IslandManager,\n    ImpulseJoint,\n    ImpulseJointHandle,\n    MultibodyJoint,\n    MultibodyJointHandle,\n    JointData,\n    ImpulseJointSet,\n    MultibodyJointSet,\n    RigidBody,\n    RigidBodyDesc,\n    RigidBodyHandle,\n    RigidBodySet,\n} from \"../dynamics\";\nimport {Rotation, Vector, VectorOps} from \"../math\";\nimport {PhysicsPipeline} from \"./physics_pipeline\";\nimport {QueryFilterFlags} from \"./query_pipeline\";\nimport {SerializationPipeline} from \"./serialization_pipeline\";\nimport {EventQueue} from \"./event_queue\";\nimport {PhysicsHooks} from \"./physics_hooks\";\nimport {DebugRenderBuffers, DebugRenderPipeline} from \"./debug_render_pipeline\";\nimport {\n    KinematicCharacterController,\n    PidAxesMask,\n    PidController,\n} from \"../control\";\nimport {Coarena} from \"../coarena\";\n\n\n/**\n * The physics world.\n *\n * This contains all the data-structures necessary for creating and simulating\n * bodies with contacts, joints, and external forces.\n */\nexport class World {\n    public gravity: Vector;\n    integrationParameters: IntegrationParameters;\n    islands: IslandManager;\n    broadPhase: BroadPhase;\n    narrowPhase: NarrowPhase;\n    bodies: RigidBodySet;\n    colliders: ColliderSet;\n    impulseJoints: ImpulseJointSet;\n    multibodyJoints: MultibodyJointSet;\n    ccdSolver: CCDSolver;\n    physicsPipeline: PhysicsPipeline;\n    serializationPipeline: SerializationPipeline;\n    debugRenderPipeline: DebugRenderPipeline;\n    characterControllers: Set<KinematicCharacterController>;\n    pidControllers: Set<PidController>;\n\n\n    /**\n     * Release the WASM memory occupied by this physics world.\n     *\n     * All the fields of this physics world will be freed as well,\n     * so there is no need to call their `.free()` methods individually.\n     */\n    public free() {\n        this.integrationParameters.free();\n        this.islands.free();\n        this.broadPhase.free();\n        this.narrowPhase.free();\n        this.bodies.free();\n        this.colliders.free();\n        this.impulseJoints.free();\n        this.multibodyJoints.free();\n        this.ccdSolver.free();\n        this.physicsPipeline.free();\n        this.serializationPipeline.free();\n        this.debugRenderPipeline.free();\n        this.characterControllers.forEach((controller) => controller.free());\n        this.pidControllers.forEach((controller) => controller.free());\n\n\n        this.integrationParameters = undefined;\n        this.islands = undefined;\n        this.broadPhase = undefined;\n        this.narrowPhase = undefined;\n        this.bodies = undefined;\n        this.colliders = undefined;\n        this.ccdSolver = undefined;\n        this.impulseJoints = undefined;\n        this.multibodyJoints = undefined;\n        this.physicsPipeline = undefined;\n        this.serializationPipeline = undefined;\n        this.debugRenderPipeline = undefined;\n        this.characterControllers = undefined;\n        this.pidControllers = undefined;\n\n    }\n\n    constructor(\n        gravity: Vector,\n        rawIntegrationParameters?: RawIntegrationParameters,\n        rawIslands?: RawIslandManager,\n        rawBroadPhase?: RawBroadPhase,\n        rawNarrowPhase?: RawNarrowPhase,\n        rawBodies?: RawRigidBodySet,\n        rawColliders?: RawColliderSet,\n        rawImpulseJoints?: RawImpulseJointSet,\n        rawMultibodyJoints?: RawMultibodyJointSet,\n        rawCCDSolver?: RawCCDSolver,\n        rawPhysicsPipeline?: RawPhysicsPipeline,\n        rawSerializationPipeline?: RawSerializationPipeline,\n        rawDebugRenderPipeline?: RawDebugRenderPipeline,\n    ) {\n        this.gravity = gravity;\n        this.integrationParameters = new IntegrationParameters(\n            rawIntegrationParameters,\n        );\n        this.islands = new IslandManager(rawIslands);\n        this.broadPhase = new BroadPhase(rawBroadPhase);\n        this.narrowPhase = new NarrowPhase(rawNarrowPhase);\n        this.bodies = new RigidBodySet(rawBodies);\n        this.colliders = new ColliderSet(rawColliders);\n        this.impulseJoints = new ImpulseJointSet(rawImpulseJoints);\n        this.multibodyJoints = new MultibodyJointSet(rawMultibodyJoints);\n        this.ccdSolver = new CCDSolver(rawCCDSolver);\n        this.physicsPipeline = new PhysicsPipeline(rawPhysicsPipeline);\n        this.serializationPipeline = new SerializationPipeline(\n            rawSerializationPipeline,\n        );\n        this.debugRenderPipeline = new DebugRenderPipeline(\n            rawDebugRenderPipeline,\n        );\n        this.characterControllers = new Set<KinematicCharacterController>();\n        this.pidControllers = new Set<PidController>();\n\n\n        this.impulseJoints.finalizeDeserialization(this.bodies);\n        this.bodies.finalizeDeserialization(this.colliders);\n        this.colliders.finalizeDeserialization(this.bodies);\n    }\n\n    public static fromRaw(raw: RawDeserializedWorld): World {\n        if (!raw) return null;\n\n        return new World(\n            VectorOps.fromRaw(raw.takeGravity()),\n            raw.takeIntegrationParameters(),\n            raw.takeIslandManager(),\n            raw.takeBroadPhase(),\n            raw.takeNarrowPhase(),\n            raw.takeBodies(),\n            raw.takeColliders(),\n            raw.takeImpulseJoints(),\n            raw.takeMultibodyJoints(),\n        );\n    }\n\n    /**\n     * Takes a snapshot of this world.\n     *\n     * Use `World.restoreSnapshot` to create a new physics world with a state identical to\n     * the state when `.takeSnapshot()` is called.\n     */\n    public takeSnapshot(): Uint8Array {\n        return this.serializationPipeline.serializeAll(\n            this.gravity,\n            this.integrationParameters,\n            this.islands,\n            this.broadPhase,\n            this.narrowPhase,\n            this.bodies,\n            this.colliders,\n            this.impulseJoints,\n            this.multibodyJoints,\n        );\n    }\n\n    /**\n     * Creates a new physics world from a snapshot.\n     *\n     * This new physics world will be an identical copy of the snapshoted physics world.\n     */\n    public static restoreSnapshot(data: Uint8Array): World {\n        let deser = new SerializationPipeline();\n        return deser.deserializeAll(data);\n    }\n\n    /**\n     * Computes all the lines (and their colors) needed to render the scene.\n     *\n     * @param filterFlags - Flags for excluding whole subsets of colliders from rendering.\n     * @param filterPredicate - Any collider for which this closure returns `false` will be excluded from the\n     *                          debug rendering.\n     */\n    public debugRender(\n        filterFlags?: QueryFilterFlags,\n        filterPredicate?: (collider: Collider) => boolean,\n    ): DebugRenderBuffers {\n        this.debugRenderPipeline.render(\n            this.bodies,\n            this.colliders,\n            this.impulseJoints,\n            this.multibodyJoints,\n            this.narrowPhase,\n            filterFlags,\n            filterPredicate,\n        );\n        return new DebugRenderBuffers(\n            this.debugRenderPipeline.vertices,\n            this.debugRenderPipeline.colors,\n        );\n    }\n\n    /**\n     * Advance the simulation by one time step.\n     *\n     * All events generated by the physics engine are ignored.\n     *\n     * @param EventQueue - (optional) structure responsible for collecting\n     *   events generated by the physics engine.\n     */\n    public step(eventQueue?: EventQueue, hooks?: PhysicsHooks) {\n        this.physicsPipeline.step(\n            this.gravity,\n            this.integrationParameters,\n            this.islands,\n            this.broadPhase,\n            this.narrowPhase,\n            this.bodies,\n            this.colliders,\n            this.impulseJoints,\n            this.multibodyJoints,\n            this.ccdSolver,\n            eventQueue,\n            hooks,\n        );\n    }\n\n    /**\n     * Update colliders positions after rigid-bodies moved.\n     *\n     * When a rigid-body moves, the positions of the colliders attached to it need to be updated. This update is\n     * generally automatically done at the beginning and the end of each simulation step with World.step.\n     * If the positions need to be updated without running a simulation step this method can be called manually.\n     */\n    public propagateModifiedBodyPositionsToColliders() {\n        this.bodies.raw.propagateModifiedBodyPositionsToColliders(\n            this.colliders.raw,\n        );\n    }\n\n    // TODO: This needs to trigger a broad-phase update but without emitting collision events?\n    // /**\n    //  * Ensure subsequent scene queries take into account the collider positions set before this method is called.\n    //  *\n    //  * This does not step the physics simulation forward.\n    //  */\n    // public updateSceneQueries() {\n    //     this.propagateModifiedBodyPositionsToColliders();\n    //     this.queryPipeline.update(this.colliders);\n    // }\n\n    /**\n     * The current simulation timestep.\n     */\n    get timestep(): number {\n        return this.integrationParameters.dt;\n    }\n\n    /**\n     * Sets the new simulation timestep.\n     *\n     * The simulation timestep governs by how much the physics state of the world will\n     * be integrated. A simulation timestep should:\n     * - be as small as possible. Typical values evolve around 0.016 (assuming the chosen unit is milliseconds,\n     * corresponds to the time between two frames of a game running at 60FPS).\n     * - not vary too much during the course of the simulation. A timestep with large variations may\n     * cause instabilities in the simulation.\n     *\n     * @param dt - The timestep length, in seconds.\n     */\n    set timestep(dt: number) {\n        this.integrationParameters.dt = dt;\n    }\n\n    /**\n     * The approximate size of most dynamic objects in the scene.\n     *\n     * See the documentation of the `World.lengthUnit` setter for further details.\n     */\n    get lengthUnit(): number {\n        return this.integrationParameters.lengthUnit;\n    }\n\n    /**\n     * The approximate size of most dynamic objects in the scene.\n     *\n     * This value is used internally to estimate some length-based tolerance. In particular, the\n     * values `IntegrationParameters.allowedLinearError`,\n     * `IntegrationParameters.maxPenetrationCorrection`,\n     * `IntegrationParameters.predictionDistance`, `RigidBodyActivation.linearThreshold`\n     * are scaled by this value implicitly.\n     *\n     * This value can be understood as the number of units-per-meter in your physical world compared\n     * to a human-sized world in meter. For example, in a 2d game, if your typical object size is 100\n     * pixels, set the `[`Self::length_unit`]` parameter to 100.0. The physics engine will interpret\n     * it as if 100 pixels is equivalent to 1 meter in its various internal threshold.\n     * (default `1.0`).\n     */\n    set lengthUnit(unitsPerMeter: number) {\n        this.integrationParameters.lengthUnit = unitsPerMeter;\n    }\n\n    /**\n     * The number of solver iterations run by the constraints solver for calculating forces (default: `4`).\n     */\n    get numSolverIterations(): number {\n        return this.integrationParameters.numSolverIterations;\n    }\n\n    /**\n     * Sets the number of solver iterations run by the constraints solver for calculating forces (default: `4`).\n     *\n     * The greater this value is, the most rigid and realistic the physics simulation will be.\n     * However a greater number of iterations is more computationally intensive.\n     *\n     * @param niter - The new number of solver iterations.\n     */\n    set numSolverIterations(niter: number) {\n        this.integrationParameters.numSolverIterations = niter;\n    }\n\n    /**\n     * Number of addition friction resolution iteration run during the last solver sub-step (default: `4`).\n     */\n    get numAdditionalFrictionIterations(): number {\n        return this.integrationParameters.numAdditionalFrictionIterations;\n    }\n\n    /**\n     * Sets the number of addition friction resolution iteration run during the last solver sub-step (default: `4`).\n     *\n     * The greater this value is, the most realistic friction will be.\n     * However a greater number of iterations is more computationally intensive.\n     *\n     * @param niter - The new number of additional friction iterations.\n     */\n    set numAdditionalFrictionIterations(niter: number) {\n        this.integrationParameters.numAdditionalFrictionIterations = niter;\n    }\n\n    /**\n     * Number of internal Project Gauss Seidel (PGS) iterations run at each solver iteration (default: `1`).\n     */\n    get numInternalPgsIterations(): number {\n        return this.integrationParameters.numInternalPgsIterations;\n    }\n\n    /**\n     * Sets the Number of internal Project Gauss Seidel (PGS) iterations run at each solver iteration (default: `1`).\n     *\n     * Increasing this parameter will improve stability of the simulation. It will have a lesser effect than\n     * increasing `numSolverIterations` but is also less computationally expensive.\n     *\n     * @param niter - The new number of internal PGS iterations.\n     */\n    set numInternalPgsIterations(niter: number) {\n        this.integrationParameters.numInternalPgsIterations = niter;\n    }\n\n    /**\n     * The number of substeps continuous collision-detection can run (default: `1`).\n     */\n    get maxCcdSubsteps(): number {\n        return this.integrationParameters.maxCcdSubsteps;\n    }\n\n    /**\n     * Sets the number of substeps continuous collision-detection can run (default: `1`).\n     *\n     * CCD operates using a \"motion clamping\" mechanism where all fast-moving object trajectories will\n     * be truncated to their first impact on their path. The number of CCD substeps beyond 1 indicate how\n     * many times that trajectory will be updated and continued after a hit. This can results in smoother\n     * paths, but at a significant computational cost.\n     *\n     * @param niter - The new maximum number of CCD substeps. Setting to `0` disables CCD entirely.\n     */\n    set maxCcdSubsteps(substeps: number) {\n        this.integrationParameters.maxCcdSubsteps = substeps;\n    }\n\n    /// Configures the integration parameters to match the old PGS solver\n    /// from Rapier JS version <= 0.11.\n    ///\n    /// This solver was slightly faster than the new one but resulted\n    /// in less stable joints and worse convergence rates.\n    ///\n    /// This should only be used for comparison purpose or if you are\n    /// experiencing problems with the new solver.\n    ///\n    /// NOTE: this does not affect any `RigidBody.additional_solver_iterations` that will\n    ///       still create solver iterations based on the new \"small-steps\" PGS solver.\n    public switchToStandardPgsSolver() {\n        this.integrationParameters.switchToStandardPgsSolver();\n    }\n\n    /// Configures the integration parameters to match the new \"small-steps\" PGS solver\n    /// from Rapier version >= 0.12.\n    ///\n    /// The \"small-steps\" PGS solver is the default one when creating the physics world. So\n    /// calling this function is generally not needed unless `World.switch_to_standard_pgs_solver`\n    /// was called.\n    ///\n    /// This solver results in more stable joints and significantly better convergence\n    /// rates but is slightly slower in its default settings.\n    public switchToSmallStepsPgsSolver() {\n        this.integrationParameters.switchToSmallStepsPgsSolver();\n    }\n\n    /// Configures the integration parameters to match the new \"small-steps\" PGS solver\n    /// from Rapier version >= 0.12. Warmstarting is disabled.\n    ///\n    /// The \"small-steps\" PGS solver is the default one when creating the physics world. So\n    /// calling this function is generally not needed unless `World.switch_to_standard_pgs_solver`\n    /// was called.\n    ///\n    /// This solver results in more stable joints and significantly better convergence\n    /// rates but is slightly slower in its default settings.\n    public switchToSmallStepsPgsSolverWithoutWarmstart() {\n        this.integrationParameters.switchToSmallStepsPgsSolverWithoutWarmstart();\n    }\n\n    /**\n     * Creates a new rigid-body from the given rigid-body descriptor.\n     *\n     * @param body - The description of the rigid-body to create.\n     */\n    public createRigidBody(body: RigidBodyDesc): RigidBody {\n        return this.bodies.createRigidBody(this.colliders, body);\n    }\n\n    /**\n     * Creates a new character controller.\n     *\n     * @param offset - The artificial gap added between the character’s chape and its environment.\n     */\n    public createCharacterController(\n        offset: number,\n    ): KinematicCharacterController {\n        let controller = new KinematicCharacterController(\n            offset,\n            this.integrationParameters,\n            this.broadPhase,\n            this.narrowPhase,\n            this.bodies,\n            this.colliders,\n        );\n        this.characterControllers.add(controller);\n        return controller;\n    }\n\n    /**\n     * Removes a character controller from this world.\n     *\n     * @param controller - The character controller to remove.\n     */\n    public removeCharacterController(controller: KinematicCharacterController) {\n        this.characterControllers.delete(controller);\n        controller.free();\n    }\n\n    /**\n     * Creates a new PID (Proportional-Integral-Derivative) controller.\n     *\n     * @param kp - The Proportional gain applied to the instantaneous linear position errors.\n     *             This is usually set to a multiple of the inverse of simulation step time\n     *             (e.g. `60` if the delta-time is `1.0 / 60.0`).\n     * @param ki - The linear gain applied to the Integral part of the PID controller.\n     * @param kd - The Derivative gain applied to the instantaneous linear velocity errors.\n     *             This is usually set to a value in `[0.0, 1.0]` where `0.0` implies no damping\n     *             (no correction of velocity errors) and `1.0` implies complete damping (velocity errors\n     *             are corrected in a single simulation step).\n     * @param axes - The axes affected by this controller.\n     *               Only coordinate axes with a bit flags set to `true` will be taken into\n     *               account when calculating the errors and corrections.\n     */\n    public createPidController(\n        kp: number,\n        ki: number,\n        kd: number,\n        axes: PidAxesMask,\n    ): PidController {\n        let controller = new PidController(\n            this.integrationParameters,\n            this.bodies,\n            kp,\n            ki,\n            kd,\n            axes,\n        );\n        this.pidControllers.add(controller);\n        return controller;\n    }\n\n    /**\n     * Removes a PID controller from this world.\n     *\n     * @param controller - The PID controller to remove.\n     */\n    public removePidController(controller: PidController) {\n        this.pidControllers.delete(controller);\n        controller.free();\n    }\n\n\n    /**\n     * Creates a new collider.\n     *\n     * @param desc - The description of the collider.\n     * @param parent - The rigid-body this collider is attached to.\n     */\n    public createCollider(desc: ColliderDesc, parent?: RigidBody): Collider {\n        let parentHandle = parent ? parent.handle : undefined;\n        return this.colliders.createCollider(this.bodies, desc, parentHandle);\n    }\n\n    /**\n     * Creates a new impulse joint from the given joint descriptor.\n     *\n     * @param params - The description of the joint to create.\n     * @param parent1 - The first rigid-body attached to this joint.\n     * @param parent2 - The second rigid-body attached to this joint.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    public createImpulseJoint(\n        params: JointData,\n        parent1: RigidBody,\n        parent2: RigidBody,\n        wakeUp: boolean,\n    ): ImpulseJoint {\n        return this.impulseJoints.createJoint(\n            this.bodies,\n            params,\n            parent1.handle,\n            parent2.handle,\n            wakeUp,\n        );\n    }\n\n    /**\n     * Creates a new multibody joint from the given joint descriptor.\n     *\n     * @param params - The description of the joint to create.\n     * @param parent1 - The first rigid-body attached to this joint.\n     * @param parent2 - The second rigid-body attached to this joint.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    public createMultibodyJoint(\n        params: JointData,\n        parent1: RigidBody,\n        parent2: RigidBody,\n        wakeUp: boolean,\n    ): MultibodyJoint {\n        return this.multibodyJoints.createJoint(\n            params,\n            parent1.handle,\n            parent2.handle,\n            wakeUp,\n        );\n    }\n\n    /**\n     * Retrieves a rigid-body from its handle.\n     *\n     * @param handle - The integer handle of the rigid-body to retrieve.\n     */\n    public getRigidBody(handle: RigidBodyHandle): RigidBody {\n        return this.bodies.get(handle);\n    }\n\n    /**\n     * Retrieves a collider from its handle.\n     *\n     * @param handle - The integer handle of the collider to retrieve.\n     */\n    public getCollider(handle: ColliderHandle): Collider {\n        return this.colliders.get(handle);\n    }\n\n    /**\n     * Retrieves an impulse joint from its handle.\n     *\n     * @param handle - The integer handle of the impulse joint to retrieve.\n     */\n    public getImpulseJoint(handle: ImpulseJointHandle): ImpulseJoint {\n        return this.impulseJoints.get(handle);\n    }\n\n    /**\n     * Retrieves an multibody joint from its handle.\n     *\n     * @param handle - The integer handle of the multibody joint to retrieve.\n     */\n    public getMultibodyJoint(handle: MultibodyJointHandle): MultibodyJoint {\n        return this.multibodyJoints.get(handle);\n    }\n\n    /**\n     * Removes the given rigid-body from this physics world.\n     *\n     * This will remove this rigid-body as well as all its attached colliders and joints.\n     * Every other bodies touching or attached by joints to this rigid-body will be woken-up.\n     *\n     * @param body - The rigid-body to remove.\n     */\n    public removeRigidBody(body: RigidBody) {\n        if (this.bodies) {\n            this.bodies.remove(\n                body.handle,\n                this.islands,\n                this.colliders,\n                this.impulseJoints,\n                this.multibodyJoints,\n            );\n        }\n    }\n\n    /**\n     * Removes the given collider from this physics world.\n     *\n     * @param collider - The collider to remove.\n     * @param wakeUp - If set to `true`, the rigid-body this collider is attached to will be awaken.\n     */\n    public removeCollider(collider: Collider, wakeUp: boolean) {\n        if (this.colliders) {\n            this.colliders.remove(\n                collider.handle,\n                this.islands,\n                this.bodies,\n                wakeUp,\n            );\n        }\n    }\n\n    /**\n     * Removes the given impulse joint from this physics world.\n     *\n     * @param joint - The impulse joint to remove.\n     * @param wakeUp - If set to `true`, the rigid-bodies attached by this joint will be awaken.\n     */\n    public removeImpulseJoint(joint: ImpulseJoint, wakeUp: boolean) {\n        if (this.impulseJoints) {\n            this.impulseJoints.remove(joint.handle, wakeUp);\n        }\n    }\n\n    /**\n     * Removes the given multibody joint from this physics world.\n     *\n     * @param joint - The multibody joint to remove.\n     * @param wakeUp - If set to `true`, the rigid-bodies attached by this joint will be awaken.\n     */\n    public removeMultibodyJoint(joint: MultibodyJoint, wakeUp: boolean) {\n        if (this.impulseJoints) {\n            this.multibodyJoints.remove(joint.handle, wakeUp);\n        }\n    }\n\n    /**\n     * Applies the given closure to each collider managed by this physics world.\n     *\n     * @param f(collider) - The function to apply to each collider managed by this physics world. Called as `f(collider)`.\n     */\n    public forEachCollider(f: (collider: Collider) => void) {\n        this.colliders.forEach(f);\n    }\n\n    /**\n     * Applies the given closure to each rigid-body managed by this physics world.\n     *\n     * @param f(body) - The function to apply to each rigid-body managed by this physics world. Called as `f(collider)`.\n     */\n    public forEachRigidBody(f: (body: RigidBody) => void) {\n        this.bodies.forEach(f);\n    }\n\n    /**\n     * Applies the given closure to each active rigid-body managed by this physics world.\n     *\n     * After a short time of inactivity, a rigid-body is automatically deactivated (\"asleep\") by\n     * the physics engine in order to save computational power. A sleeping rigid-body never moves\n     * unless it is moved manually by the user.\n     *\n     * @param f - The function to apply to each active rigid-body managed by this physics world. Called as `f(collider)`.\n     */\n    public forEachActiveRigidBody(f: (body: RigidBody) => void) {\n        this.bodies.forEachActiveRigidBody(this.islands, f);\n    }\n\n    /**\n     * Find the closest intersection between a ray and the physics world.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param filter - The callback to filter out which collider will be hit.\n     */\n    public castRay(\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ): RayColliderHit | null {\n        return this.broadPhase.castRay(\n            this.narrowPhase,\n            this.bodies,\n            this.colliders,\n            ray,\n            maxToi,\n            solid,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Find the closest intersection between a ray and the physics world.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     */\n    public castRayAndGetNormal(\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ): RayColliderIntersection | null {\n        return this.broadPhase.castRayAndGetNormal(\n            this.narrowPhase,\n            this.bodies,\n            this.colliders,\n            ray,\n            maxToi,\n            solid,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Cast a ray and collects all the intersections between a ray and the scene.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param callback - The callback called once per hit (in no particular order) between a ray and a collider.\n     *   If this callback returns `false`, then the cast will stop and no further hits will be detected/reported.\n     */\n    public intersectionsWithRay(\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        callback: (intersect: RayColliderIntersection) => boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ) {\n        this.broadPhase.intersectionsWithRay(\n            this.narrowPhase,\n            this.bodies,\n            this.colliders,\n            ray,\n            maxToi,\n            solid,\n            callback,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Gets the handle of up to one collider intersecting the given shape.\n     *\n     * @param shapePos - The position of the shape used for the intersection test.\n     * @param shapeRot - The orientation of the shape used for the intersection test.\n     * @param shape - The shape used for the intersection test.\n     * @param groups - The bit groups and filter associated to the ray, in order to only\n     *   hit the colliders with collision groups compatible with the ray's group.\n     */\n    public intersectionWithShape(\n        shapePos: Vector,\n        shapeRot: Rotation,\n        shape: Shape,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ): Collider | null {\n        let handle = this.broadPhase.intersectionWithShape(\n            this.narrowPhase,\n            this.bodies,\n            this.colliders,\n            shapePos,\n            shapeRot,\n            shape,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n        return handle != null ? this.colliders.get(handle) : null;\n    }\n\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    public projectPoint(\n        point: Vector,\n        solid: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ): PointColliderProjection | null {\n        return this.broadPhase.projectPoint(\n            this.narrowPhase,\n            this.bodies,\n            this.colliders,\n            point,\n            solid,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param point - The point to project.\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    public projectPointAndGetFeature(\n        point: Vector,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ): PointColliderProjection | null {\n        return this.broadPhase.projectPointAndGetFeature(\n            this.narrowPhase,\n            this.bodies,\n            this.colliders,\n            point,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Find all the colliders containing the given point.\n     *\n     * @param point - The point used for the containment test.\n     * @param groups - The bit groups and filter associated to the point to test, in order to only\n     *   test on colliders with collision groups compatible with the ray's group.\n     * @param callback - A function called with the handles of each collider with a shape\n     *   containing the `point`.\n     */\n    public intersectionsWithPoint(\n        point: Vector,\n        callback: (handle: Collider) => boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ) {\n        this.broadPhase.intersectionsWithPoint(\n            this.narrowPhase,\n            this.bodies,\n            this.colliders,\n            point,\n            this.colliders.castClosure(callback),\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Casts a shape at a constant linear velocity and retrieve the first collider it hits.\n     * This is similar to ray-casting except that we are casting a whole shape instead of\n     * just a point (the ray origin).\n     *\n     * @param shapePos - The initial position of the shape to cast.\n     * @param shapeRot - The initial rotation of the shape to cast.\n     * @param shapeVel - The constant velocity of the shape to cast (i.e. the cast direction).\n     * @param shape - The shape to cast.\n     * @param targetDistance − If the shape moves closer to this distance from a collider, a hit\n     *                         will be returned.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast won’t immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that it’s on a path to exit that penetration state.\n     * @param groups - The bit groups and filter associated to the shape to cast, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     */\n    public castShape(\n        shapePos: Vector,\n        shapeRot: Rotation,\n        shapeVel: Vector,\n        shape: Shape,\n        targetDistance: number,\n        maxToi: number,\n        stopAtPenetration: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ): ColliderShapeCastHit | null {\n        return this.broadPhase.castShape(\n            this.narrowPhase,\n            this.bodies,\n            this.colliders,\n            shapePos,\n            shapeRot,\n            shapeVel,\n            shape,\n            targetDistance,\n            maxToi,\n            stopAtPenetration,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Retrieve all the colliders intersecting the given shape.\n     *\n     * @param shapePos - The position of the shape to test.\n     * @param shapeRot - The orientation of the shape to test.\n     * @param shape - The shape to test.\n     * @param groups - The bit groups and filter associated to the shape to test, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     * @param callback - A function called with the handles of each collider intersecting the `shape`.\n     */\n    public intersectionsWithShape(\n        shapePos: Vector,\n        shapeRot: Rotation,\n        shape: Shape,\n        callback: (collider: Collider) => boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ) {\n        this.broadPhase.intersectionsWithShape(\n            this.narrowPhase,\n            this.bodies,\n            this.colliders,\n            shapePos,\n            shapeRot,\n            shape,\n            this.colliders.castClosure(callback),\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Finds the handles of all the colliders with an AABB intersecting the given AABB.\n     *\n     * @param aabbCenter - The center of the AABB to test.\n     * @param aabbHalfExtents - The half-extents of the AABB to test.\n     * @param callback - The callback that will be called with the handles of all the colliders\n     *                   currently intersecting the given AABB.\n     */\n    public collidersWithAabbIntersectingAabb(\n        aabbCenter: Vector,\n        aabbHalfExtents: Vector,\n        callback: (handle: Collider) => boolean,\n    ) {\n        this.broadPhase.collidersWithAabbIntersectingAabb(\n            this.narrowPhase,\n            this.bodies,\n            this.colliders,\n            aabbCenter,\n            aabbHalfExtents,\n            this.colliders.castClosure(callback),\n        );\n    }\n\n    /**\n     * Enumerates all the colliders potentially in contact with the given collider.\n     *\n     * @param collider1 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each collider that is in contact with `collider1`.\n     */\n    public contactPairsWith(\n        collider1: Collider,\n        f: (collider2: Collider) => void,\n    ) {\n        this.narrowPhase.contactPairsWith(\n            collider1.handle,\n            this.colliders.castClosure(f),\n        );\n    }\n\n    /**\n     * Enumerates all the colliders intersecting the given colliders, assuming one of them\n     * is a sensor.\n     */\n    public intersectionPairsWith(\n        collider1: Collider,\n        f: (collider2: Collider) => void,\n    ) {\n        this.narrowPhase.intersectionPairsWith(\n            collider1.handle,\n            this.colliders.castClosure(f),\n        );\n    }\n\n    /**\n     * Iterates through all the contact manifolds between the given pair of colliders.\n     *\n     * @param collider1 - The first collider involved in the contact.\n     * @param collider2 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each contact manifold between the two colliders. If the second argument\n     *            passed to this closure is `true`, then the contact manifold data is flipped, i.e., methods like `localNormal1`\n     *            actually apply to the `collider2` and fields like `localNormal2` apply to the `collider1`.\n     */\n    public contactPair(\n        collider1: Collider,\n        collider2: Collider,\n        f: (manifold: TempContactManifold, flipped: boolean) => void,\n    ) {\n        this.narrowPhase.contactPair(collider1.handle, collider2.handle, f);\n    }\n\n    /**\n     * Returns `true` if `collider1` and `collider2` intersect and at least one of them is a sensor.\n     * @param collider1 − The first collider involved in the intersection.\n     * @param collider2 − The second collider involved in the intersection.\n     */\n    public intersectionPair(collider1: Collider, collider2: Collider): boolean {\n        return this.narrowPhase.intersectionPair(\n            collider1.handle,\n            collider2.handle,\n        );\n    }\n\n    /**\n     * Sets whether internal performance profiling is enabled (default: false).\n     *\n     * Only works if the internal profiler is enabled with `World.profilerEnabled = true`.\n     */\n    set profilerEnabled(enabled: boolean) {\n        this.physicsPipeline.raw.set_profiler_enabled(enabled);\n    }\n\n    /**\n     * Indicates if the internal performance profiling is enabled.\n     *\n     * Only works if the internal profiler is enabled with `World.profilerEnabled = true`.\n     */\n    get profilerEnabled(): boolean {\n        return this.physicsPipeline.raw.is_profiler_enabled();\n    }\n\n    /**\n     * The time spent in milliseconds by the last step to run the entire simulation step.\n     *\n     * Only works if the internal profiler is enabled with `World.profilerEnabled = true`.\n     */\n    public timingStep(): number {\n        return this.physicsPipeline.raw.timing_step();\n    }\n\n    /**\n     * The time spent in milliseconds by the last step to run the collision-detection\n     * (broad-phase + narrow-phase).\n     *\n     * Only works if the internal profiler is enabled with `World.profilerEnabled = true`.\n     */\n    public timingCollisionDetection(): number {\n        return this.physicsPipeline.raw.timing_collision_detection();\n    }\n\n    /**\n     * The time spent in milliseconds by the last step to run the broad-phase.\n     *\n     * This timing is included in `timingCollisionDetection`.\n     * Only works if the internal profiler is enabled with `World.profilerEnabled = true`.\n     */\n    public timingBroadPhase(): number {\n        return this.physicsPipeline.raw.timing_broad_phase();\n    }\n\n    /**\n     * The time spent in milliseconds by the last step to run the narrow-phase.\n     *\n     * This timing is included in `timingCollisionDetection`.\n     * Only works if the internal profiler is enabled with `World.profilerEnabled = true`.\n     */\n    public timingNarrowPhase(): number {\n        return this.physicsPipeline.raw.timing_narrow_phase();\n    }\n\n    /**\n     * The time spent in milliseconds by the last step to run the constraint solver.\n     *\n     * Only works if the internal profiler is enabled with `World.profilerEnabled = true`.\n     */\n    public timingSolver(): number {\n        return this.physicsPipeline.raw.timing_solver();\n    }\n\n    /**\n     * The time spent in milliseconds by the last step to run the constraint\n     * initialization.\n     *\n     * This timing is included in `timingSolver`.\n     * Only works if the internal profiler is enabled with `World.profilerEnabled = true`.\n     */\n    public timingVelocityAssembly(): number {\n        return this.physicsPipeline.raw.timing_velocity_assembly();\n    }\n\n    /**\n     * The time spent in milliseconds by the last step to run the constraint\n     * resolution.\n     *\n     * This timing is included in `timingSolver`.\n     * Only works if the internal profiler is enabled with `World.profilerEnabled = true`.\n     */\n    public timingVelocityResolution(): number {\n        return this.physicsPipeline.raw.timing_velocity_resolution();\n    }\n\n    /**\n     * The time spent in milliseconds by the last step to run the rigid-body\n     * velocity update.\n     *\n     * This timing is included in `timingSolver`.\n     * Only works if the internal profiler is enabled with `World.profilerEnabled = true`.\n     */\n    public timingVelocityUpdate(): number {\n        return this.physicsPipeline.raw.timing_velocity_update();\n    }\n\n    /**\n     * The time spent in milliseconds by writing rigid-body velocities\n     * calculated by the solver back into the rigid-bodies.\n     *\n     * This timing is included in `timingSolver`.\n     * Only works if the internal profiler is enabled with `World.profilerEnabled = true`.\n     */\n    public timingVelocityWriteback(): number {\n        return this.physicsPipeline.raw.timing_velocity_writeback();\n    }\n\n    /**\n     * The total time spent in CCD detection and resolution.\n     *\n     * Only works if the internal profiler is enabled with `World.profilerEnabled = true`.\n     */\n    public timingCcd(): number {\n        return this.physicsPipeline.raw.timing_ccd();\n    }\n\n    /**\n     * The total time spent searching for the continuous hits during CCD.\n     *\n     * This timing is included in `timingCcd`.\n     * Only works if the internal profiler is enabled with `World.profilerEnabled = true`.\n     */\n    public timingCcdToiComputation(): number {\n        return this.physicsPipeline.raw.timing_ccd_toi_computation();\n    }\n\n    /**\n     * The total time spent in the broad-phase during CCD.\n     *\n     * This timing is included in `timingCcd`.\n     * Only works if the internal profiler is enabled with `World.profilerEnabled = true`.\n     */\n    public timingCcdBroadPhase(): number {\n        return this.physicsPipeline.raw.timing_ccd_broad_phase();\n    }\n\n    /**\n     * The total time spent in the narrow-phase during CCD.\n     *\n     * This timing is included in `timingCcd`.\n     * Only works if the internal profiler is enabled with `World.profilerEnabled = true`.\n     */\n    public timingCcdNarrowPhase(): number {\n        return this.physicsPipeline.raw.timing_ccd_narrow_phase();\n    }\n\n    /**\n     * The total time spent in the constraints resolution during CCD.\n     *\n     * This timing is included in `timingCcd`.\n     * Only works if the internal profiler is enabled with `World.profilerEnabled = true`.\n     */\n    public timingCcdSolver(): number {\n        return this.physicsPipeline.raw.timing_ccd_solver();\n    }\n\n    /**\n     * The total time spent in the islands calculation during CCD.\n     *\n     * Only works if the internal profiler is enabled with `World.profilerEnabled = true`.\n     */\n    public timingIslandConstruction(): number {\n        return this.physicsPipeline.raw.timing_island_construction();\n    }\n\n    /**\n     * The total time spent propagating detected user changes.\n     *\n     * Only works if the internal profiler is enabled with `World.profilerEnabled = true`.\n     */\n    public timingUserChanges(): number {\n        return this.physicsPipeline.raw.timing_user_changes();\n    }\n}\n","import {RawColliderSet} from \"../raw\";\nimport {Coarena} from \"../coarena\";\nimport {RotationOps, VectorOps} from \"../math\";\nimport {Collider, ColliderDesc, ColliderHandle} from \"./collider\";\nimport {ImpulseJointHandle, IslandManager, RigidBodyHandle} from \"../dynamics\";\nimport {RigidBodySet} from \"../dynamics\";\n\n/**\n * A set of rigid bodies that can be handled by a physics pipeline.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `colliderSet.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class ColliderSet {\n    raw: RawColliderSet;\n    private map: Coarena<Collider>;\n\n    /**\n     * Release the WASM memory occupied by this collider set.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n\n    constructor(raw?: RawColliderSet) {\n        this.raw = raw || new RawColliderSet();\n        this.map = new Coarena<Collider>();\n        // Initialize the map with the existing elements, if any.\n        if (raw) {\n            raw.forEachColliderHandle((handle: ColliderHandle) => {\n                this.map.set(handle, new Collider(this, handle, null));\n            });\n        }\n    }\n\n    /** @internal */\n    public castClosure<Res>(\n        f?: (collider: Collider) => Res,\n    ): (handle: ColliderHandle) => Res | undefined {\n        return (handle) => {\n            if (!!f) {\n                return f(this.get(handle));\n            } else {\n                return undefined;\n            }\n        };\n    }\n\n    /** @internal */\n    public finalizeDeserialization(bodies: RigidBodySet) {\n        this.map.forEach((collider) =>\n            collider.finalizeDeserialization(bodies),\n        );\n    }\n\n    /**\n     * Creates a new collider and return its integer handle.\n     *\n     * @param bodies - The set of bodies where the collider's parent can be found.\n     * @param desc - The collider's description.\n     * @param parentHandle - The integer handle of the rigid-body this collider is attached to.\n     */\n    public createCollider(\n        bodies: RigidBodySet,\n        desc: ColliderDesc,\n        parentHandle: RigidBodyHandle,\n    ): Collider {\n        let hasParent = parentHandle != undefined && parentHandle != null;\n\n        if (hasParent && isNaN(parentHandle))\n            throw Error(\n                \"Cannot create a collider with a parent rigid-body handle that is not a number.\",\n            );\n\n        let rawShape = desc.shape.intoRaw();\n        let rawTra = VectorOps.intoRaw(desc.translation);\n        let rawRot = RotationOps.intoRaw(desc.rotation);\n        let rawCom = VectorOps.intoRaw(desc.centerOfMass);\n\n\n        let handle = this.raw.createCollider(\n            desc.enabled,\n            rawShape,\n            rawTra,\n            rawRot,\n            desc.massPropsMode,\n            desc.mass,\n            rawCom,\n            // #if DIM2\n            desc.principalAngularInertia,\n            // #endif\n            desc.density,\n            desc.friction,\n            desc.restitution,\n            desc.frictionCombineRule,\n            desc.restitutionCombineRule,\n            desc.isSensor,\n            desc.collisionGroups,\n            desc.solverGroups,\n            desc.activeCollisionTypes,\n            desc.activeHooks,\n            desc.activeEvents,\n            desc.contactForceEventThreshold,\n            desc.contactSkin,\n            hasParent,\n            hasParent ? parentHandle : 0,\n            bodies.raw,\n        );\n\n        rawShape.free();\n        rawTra.free();\n        rawRot.free();\n        rawCom.free();\n\n\n        let parent = hasParent ? bodies.get(parentHandle) : null;\n        let collider = new Collider(this, handle, parent, desc.shape);\n        this.map.set(handle, collider);\n        return collider;\n    }\n\n    /**\n     * Remove a collider from this set.\n     *\n     * @param handle - The integer handle of the collider to remove.\n     * @param bodies - The set of rigid-body containing the rigid-body the collider is attached to.\n     * @param wakeUp - If `true`, the rigid-body the removed collider is attached to will be woken-up automatically.\n     */\n    public remove(\n        handle: ColliderHandle,\n        islands: IslandManager,\n        bodies: RigidBodySet,\n        wakeUp: boolean,\n    ) {\n        this.raw.remove(handle, islands.raw, bodies.raw, wakeUp);\n        this.unmap(handle);\n    }\n\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n    public unmap(handle: ImpulseJointHandle) {\n        this.map.delete(handle);\n    }\n\n    /**\n     * Gets the rigid-body with the given handle.\n     *\n     * @param handle - The handle of the rigid-body to retrieve.\n     */\n    public get(handle: ColliderHandle): Collider | null {\n        return this.map.get(handle);\n    }\n\n    /**\n     * The number of colliders on this set.\n     */\n    public len(): number {\n        return this.map.len();\n    }\n\n    /**\n     * Does this set contain a collider with the given handle?\n     *\n     * @param handle - The collider handle to check.\n     */\n    public contains(handle: ColliderHandle): boolean {\n        return this.get(handle) != null;\n    }\n\n    /**\n     * Applies the given closure to each collider contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEach(f: (collider: Collider) => void) {\n        this.map.forEach(f);\n    }\n\n    /**\n     * Gets all colliders in the list.\n     *\n     * @returns collider list.\n     */\n    public getAll(): Collider[] {\n        return this.map.getAll();\n    }\n}\n","/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","// @ts-ignore\nimport wasmBase64 from \"../pkg/rapier_wasm2d_bg.wasm\";\nimport wasmInit from \"../pkg/rapier_wasm2d\";\nimport base64 from \"base64-js\";\n\n/**\n * Initializes RAPIER.\n * Has to be called and awaited before using any library methods.\n */\nexport async function init() {\n    await wasmInit(base64.toByteArray(wasmBase64 as unknown as string).buffer);\n}\n","import {version as vers, reserve_memory as reserve} from \"./raw\";\n\nexport function version(): string {\n    return vers();\n}\n\n/// Reserves additional memory in WASM land.\n///\n/// This will grow the internal WASM memory buffer so that it can fit at least\n/// the specified amount of extra bytes. This can help reduce future runtime\n/// overhead due to dynamic internal memory growth once the limit of the\n/// pre-allocated memory is reached.\n///\n/// This feature is still experimental. Due to the nature of the internal\n/// allocator, there can be situations where the allocator decides to perform\n/// additional internal memory growth even though not all `extraBytesCount`\n/// are occupied yet.\nexport function reserveMemory(extraBytesCount: number) {\n    reserve(extraBytesCount);\n}\n\nexport * from \"./math\";\nexport * from \"./dynamics\";\nexport * from \"./geometry\";\nexport * from \"./pipeline\";\nexport * from \"./init\";\nexport * from \"./control\";\n"],"names":["wasm","heap","Array","fill","undefined","getObject","idx","push","heap_next","length","addHeapObject","obj","handleError","f","args","apply","this","e","__wbindgen_export_0","cachedTextDecoder","TextDecoder","ignoreBOM","fatal","decode","Error","cachedUint8ArrayMemory0","getStringFromWasm0","ptr","len","byteLength","Uint8Array","memory","buffer","subarray","isLikeNone","x","cachedDataViewMemory0","getDataViewMemory0","detached","DataView","takeObject","ret","dropObject","_assertClass","instance","klass","name","stack_pointer","addBorrowedObject","cachedInt32ArrayMemory0","getArrayI32FromWasm0","Int32Array","cachedFloat32ArrayMemory0","getFloat32ArrayMemory0","Float32Array","getArrayF32FromWasm0","cachedUint32ArrayMemory0","getUint32ArrayMemory0","Uint32Array","WASM_VECTOR_LEN","passArray32ToWasm0","arg","malloc","set","passArrayF32ToWasm0","Object","freeze","Vertex","Face","Unknown","RawJointAxis","LinX","LinY","AngX","RawJointType","Revolute","Fixed","Prismatic","Rope","Spring","Generic","AccelerationBased","ForceBased","Dynamic","KinematicPositionBased","KinematicVelocityBased","RawShapeType","Ball","Cuboid","Capsule","Segment","Polyline","Triangle","TriMesh","HeightField","Compound","ConvexPolygon","RoundCuboid","RoundTriangle","RoundConvexPolygon","HalfSpace","Voxels","RawBroadPhaseFinalization","FinalizationRegistry","register","unregister","__wbg_rawbroadphase_free","RawBroadPhase","static","create","prototype","__wbg_ptr","__destroy_into_raw","free","constructor","rawbroadphase_new","castRay","narrow_phase","bodies","colliders","rayOrig","rayDir","maxToi","solid","filter_flags","filter_groups","filter_exclude_collider","filter_exclude_rigid_body","filter_predicate","RawNarrowPhase","RawRigidBodySet","RawColliderSet","RawVector","rawbroadphase_castRay","RawRayColliderHit","__wrap","castRayAndGetNormal","rawbroadphase_castRayAndGetNormal","RawRayColliderIntersection","intersectionsWithRay","callback","rawbroadphase_intersectionsWithRay","intersectionWithShape","shapePos","shapeRot","shape","retptr","__wbindgen_add_to_stack_pointer","RawRotation","RawShape","rawbroadphase_intersectionWithShape","r0","getInt32","r2","getFloat64","projectPoint","point","rawbroadphase_projectPoint","RawPointColliderProjection","projectPointAndGetFeature","rawbroadphase_projectPointAndGetFeature","intersectionsWithPoint","rawbroadphase_intersectionsWithPoint","castShape","shapeVel","target_distance","stop_at_penetration","rawbroadphase_castShape","RawColliderShapeCastHit","intersectionsWithShape","rawbroadphase_intersectionsWithShape","collidersWithAabbIntersectingAabb","aabbCenter","aabbHalfExtents","rawbroadphase_collidersWithAabbIntersectingAabb","RawCCDSolverFinalization","__wbg_rawccdsolver_free","RawCCDSolver","rawccdsolver_new","RawCharacterCollisionFinalization","__wbg_rawcharactercollision_free","RawCharacterCollision","rawcharactercollision_new","handle","rawcharactercollision_handle","translationDeltaApplied","rawcharactercollision_translationDeltaApplied","translationDeltaRemaining","rawcharactercollision_translationDeltaRemaining","toi","rawcharactercollision_toi","worldWitness1","rawcharactercollision_worldWitness1","worldWitness2","rawcharactercollision_worldWitness2","worldNormal1","rawcharactercollision_worldNormal1","worldNormal2","rawcharactercollision_worldNormal2","RawColliderSetFinalization","__wbg_rawcolliderset_free","coTranslation","rawcolliderset_coTranslation","coRotation","rawcolliderset_coRotation","coTranslationWrtParent","rawcolliderset_coTranslationWrtParent","coRotationWrtParent","rawcolliderset_coRotationWrtParent","coSetTranslation","y","rawcolliderset_coSetTranslation","coSetTranslationWrtParent","rawcolliderset_coSetTranslationWrtParent","coSetRotation","angle","rawcolliderset_coSetRotation","coSetRotationWrtParent","rawcolliderset_coSetRotationWrtParent","coIsSensor","rawcolliderset_coIsSensor","coShapeType","rawcolliderset_coShapeType","coHalfspaceNormal","rawcolliderset_coHalfspaceNormal","coHalfExtents","rawcolliderset_coHalfExtents","coSetHalfExtents","newHalfExtents","rawcolliderset_coSetHalfExtents","coRadius","rawcolliderset_coRadius","coSetRadius","newRadius","rawcolliderset_coSetRadius","coHalfHeight","rawcolliderset_coHalfHeight","coSetHalfHeight","newHalfheight","rawcolliderset_coSetHalfHeight","coRoundRadius","rawcolliderset_coRoundRadius","coSetRoundRadius","newBorderRadius","rawcolliderset_coSetRoundRadius","coVoxelData","rawcolliderset_coVoxelData","r1","v1","slice","__wbindgen_export_1","coVoxelSize","rawcolliderset_coVoxelSize","coSetVoxel","ix","iy","filled","rawcolliderset_coSetVoxel","coPropagateVoxelChange","handle1","handle2","shift_x","shift_y","rawcolliderset_coPropagateVoxelChange","coCombineVoxelStates","rawcolliderset_coCombineVoxelStates","coVertices","rawcolliderset_coVertices","coIndices","rawcolliderset_coIndices","getArrayU32FromWasm0","coTriMeshFlags","rawcolliderset_coTriMeshFlags","coHeightfieldHeights","rawcolliderset_coHeightfieldHeights","coHeightfieldScale","rawcolliderset_coHeightfieldScale","coParent","rawcolliderset_coParent","coSetEnabled","enabled","rawcolliderset_coSetEnabled","coIsEnabled","rawcolliderset_coIsEnabled","coSetContactSkin","contact_skin","rawcolliderset_coSetContactSkin","coContactSkin","rawcolliderset_coContactSkin","coFriction","rawcolliderset_coFriction","coRestitution","rawcolliderset_coRestitution","coDensity","rawcolliderset_coDensity","coMass","rawcolliderset_coMass","coVolume","rawcolliderset_coVolume","coCollisionGroups","rawcolliderset_coCollisionGroups","coSolverGroups","rawcolliderset_coSolverGroups","coActiveHooks","rawcolliderset_coActiveHooks","coActiveCollisionTypes","rawcolliderset_coActiveCollisionTypes","coActiveEvents","rawcolliderset_coActiveEvents","coContactForceEventThreshold","rawcolliderset_coContactForceEventThreshold","coContainsPoint","rawcolliderset_coContainsPoint","coCastShape","colliderVel","shape2","shape2Pos","shape2Rot","shape2Vel","rawcolliderset_coCastShape","RawShapeCastHit","coCastCollider","collider1Vel","collider2handle","collider2Vel","max_toi","rawcolliderset_coCastCollider","coIntersectsShape","shapePos2","shapeRot2","rawcolliderset_coIntersectsShape","coContactShape","prediction","rawcolliderset_coContactShape","RawShapeContact","coContactCollider","rawcolliderset_coContactCollider","coProjectPoint","rawcolliderset_coProjectPoint","RawPointProjection","coIntersectsRay","rawcolliderset_coIntersectsRay","coCastRay","rawcolliderset_coCastRay","coCastRayAndGetNormal","rawcolliderset_coCastRayAndGetNormal","RawRayIntersection","coSetSensor","is_sensor","rawcolliderset_coSetSensor","coSetRestitution","restitution","rawcolliderset_coSetRestitution","coSetFriction","friction","rawcolliderset_coSetFriction","coFrictionCombineRule","rawcolliderset_coFrictionCombineRule","coSetFrictionCombineRule","rule","rawcolliderset_coSetFrictionCombineRule","coRestitutionCombineRule","rawcolliderset_coRestitutionCombineRule","coSetRestitutionCombineRule","rawcolliderset_coSetRestitutionCombineRule","coSetCollisionGroups","groups","rawcolliderset_coSetCollisionGroups","coSetSolverGroups","rawcolliderset_coSetSolverGroups","coSetActiveHooks","hooks","rawcolliderset_coSetActiveHooks","coSetActiveEvents","events","rawcolliderset_coSetActiveEvents","coSetActiveCollisionTypes","types","rawcolliderset_coSetActiveCollisionTypes","coSetShape","rawcolliderset_coSetShape","coSetContactForceEventThreshold","threshold","rawcolliderset_coSetContactForceEventThreshold","coSetDensity","density","rawcolliderset_coSetDensity","coSetMass","mass","rawcolliderset_coSetMass","coSetMassProperties","centerOfMass","principalAngularInertia","rawcolliderset_coSetMassProperties","rawcolliderset_new","rawcolliderset_len","contains","rawcolliderset_contains","createCollider","translation","rotation","massPropsMode","frictionCombineRule","restitutionCombineRule","isSensor","collisionGroups","solverGroups","activeCollisionTypes","activeHooks","activeEvents","contactForceEventThreshold","contactSkin","hasParent","parent","rawcolliderset_createCollider","remove","islands","wakeUp","RawIslandManager","rawcolliderset_remove","isHandleValid","forEachColliderHandle","rawcolliderset_forEachColliderHandle","RawColliderShapeCastHitFinalization","__wbg_rawcollidershapecasthit_free","colliderHandle","rawcollidershapecasthit_colliderHandle","time_of_impact","rawcollidershapecasthit_time_of_impact","witness1","rawcollidershapecasthit_witness1","witness2","rawcollidershapecasthit_witness2","normal1","rawcollidershapecasthit_normal1","normal2","rawcollidershapecasthit_normal2","RawContactForceEventFinalization","__wbg_rawcontactforceevent_free","RawContactForceEvent","collider1","collider2","rawcontactforceevent_collider2","total_force","rawcontactforceevent_total_force","total_force_magnitude","rawcontactforceevent_total_force_magnitude","max_force_direction","max_force_magnitude","rawcontactforceevent_max_force_magnitude","RawContactManifoldFinalization","__wbg_rawcontactmanifold_free","RawContactManifold","normal","rawcontactmanifold_normal","local_n1","rawcontactmanifold_local_n1","local_n2","rawcontactmanifold_local_n2","subshape1","rawcontactmanifold_subshape1","subshape2","rawcontactmanifold_subshape2","num_contacts","rawcontactmanifold_num_contacts","contact_local_p1","i","rawcontactmanifold_contact_local_p1","contact_local_p2","rawcontactmanifold_contact_local_p2","contact_dist","rawcontactmanifold_contact_dist","contact_fid1","rawcontactmanifold_contact_fid1","contact_fid2","rawcontactmanifold_contact_fid2","contact_impulse","rawcontactmanifold_contact_impulse","contact_tangent_impulse","rawcontactmanifold_contact_tangent_impulse","num_solver_contacts","rawcontactmanifold_num_solver_contacts","solver_contact_point","rawcontactmanifold_solver_contact_point","solver_contact_dist","rawcontactmanifold_solver_contact_dist","solver_contact_friction","rawcontactmanifold_solver_contact_friction","solver_contact_restitution","rawcontactmanifold_solver_contact_restitution","solver_contact_tangent_velocity","rawcontactmanifold_solver_contact_tangent_velocity","RawContactPairFinalization","__wbg_rawcontactpair_free","RawContactPair","rawcontactpair_collider1","rawcontactpair_collider2","numContactManifolds","rawcontactpair_numContactManifolds","contactManifold","rawcontactpair_contactManifold","RawDebugRenderPipelineFinalization","__wbg_rawdebugrenderpipeline_free","RawDebugRenderPipeline","rawdebugrenderpipeline_new","vertices","rawdebugrenderpipeline_vertices","colors","rawdebugrenderpipeline_colors","render","impulse_joints","multibody_joints","RawImpulseJointSet","RawMultibodyJointSet","rawdebugrenderpipeline_render","RawDeserializedWorldFinalization","__wbg_rawdeserializedworld_free","RawDeserializedWorld","takeGravity","rawdeserializedworld_takeGravity","takeIntegrationParameters","rawdeserializedworld_takeIntegrationParameters","RawIntegrationParameters","takeIslandManager","rawdeserializedworld_takeIslandManager","takeBroadPhase","rawdeserializedworld_takeBroadPhase","takeNarrowPhase","rawdeserializedworld_takeNarrowPhase","takeBodies","rawdeserializedworld_takeBodies","takeColliders","rawdeserializedworld_takeColliders","takeImpulseJoints","rawdeserializedworld_takeImpulseJoints","takeMultibodyJoints","rawdeserializedworld_takeMultibodyJoints","RawEventQueueFinalization","__wbg_raweventqueue_free","RawEventQueue","autoDrain","raweventqueue_new","drainCollisionEvents","raweventqueue_drainCollisionEvents","drainContactForceEvents","raweventqueue_drainContactForceEvents","clear","raweventqueue_clear","RawGenericJointFinalization","__wbg_rawgenericjoint_free","RawGenericJoint","rest_length","stiffness","damping","anchor1","anchor2","rawgenericjoint_spring","rawgenericjoint_rope","axis","limitsEnabled","limitsMin","limitsMax","rawgenericjoint_prismatic","axes1","axes2","rawgenericjoint_fixed","rawgenericjoint_revolute","RawImpulseJointSetFinalization","__wbg_rawimpulsejointset_free","jointType","rawimpulsejointset_jointType","jointBodyHandle1","rawimpulsejointset_jointBodyHandle1","jointBodyHandle2","rawimpulsejointset_jointBodyHandle2","jointFrameX1","rawimpulsejointset_jointFrameX1","jointFrameX2","rawimpulsejointset_jointFrameX2","jointAnchor1","rawimpulsejointset_jointAnchor1","jointAnchor2","rawimpulsejointset_jointAnchor2","jointSetAnchor1","newPos","rawimpulsejointset_jointSetAnchor1","jointSetAnchor2","rawimpulsejointset_jointSetAnchor2","jointContactsEnabled","rawimpulsejointset_jointContactsEnabled","jointSetContactsEnabled","rawimpulsejointset_jointSetContactsEnabled","jointLimitsEnabled","rawimpulsejointset_jointLimitsEnabled","jointLimitsMin","rawimpulsejointset_jointLimitsMin","jointLimitsMax","rawimpulsejointset_jointLimitsMax","jointSetLimits","min","max","rawimpulsejointset_jointSetLimits","jointConfigureMotorModel","model","rawimpulsejointset_jointConfigureMotorModel","jointConfigureMotorVelocity","targetVel","factor","rawimpulsejointset_jointConfigureMotorVelocity","jointConfigureMotorPosition","targetPos","rawimpulsejointset_jointConfigureMotorPosition","jointConfigureMotor","rawimpulsejointset_jointConfigureMotor","rawimpulsejointset_new","createJoint","params","parent1","parent2","wake_up","rawimpulsejointset_createJoint","rawimpulsejointset_remove","rawimpulsejointset_len","rawimpulsejointset_contains","forEachJointHandle","rawimpulsejointset_forEachJointHandle","forEachJointAttachedToRigidBody","body","rawimpulsejointset_forEachJointAttachedToRigidBody","RawIntegrationParametersFinalization","__wbg_rawintegrationparameters_free","rawintegrationparameters_new","dt","rawintegrationparameters_dt","contact_erp","rawintegrationparameters_contact_erp","normalizedAllowedLinearError","normalizedPredictionDistance","rawintegrationparameters_normalizedPredictionDistance","numSolverIterations","rawintegrationparameters_numSolverIterations","numAdditionalFrictionIterations","rawintegrationparameters_numAdditionalFrictionIterations","numInternalPgsIterations","rawintegrationparameters_numInternalPgsIterations","minIslandSize","rawintegrationparameters_minIslandSize","maxCcdSubsteps","rawintegrationparameters_maxCcdSubsteps","lengthUnit","value","rawintegrationparameters_set_dt","contact_natural_frequency","rawintegrationparameters_set_contact_natural_frequency","rawintegrationparameters_set_normalizedAllowedLinearError","rawintegrationparameters_set_normalizedPredictionDistance","rawintegrationparameters_set_numSolverIterations","rawintegrationparameters_set_numAdditionalFrictionIterations","rawintegrationparameters_set_numInternalPgsIterations","rawintegrationparameters_set_minIslandSize","rawintegrationparameters_set_maxCcdSubsteps","rawintegrationparameters_set_lengthUnit","switchToStandardPgsSolver","rawintegrationparameters_switchToStandardPgsSolver","switchToSmallStepsPgsSolver","rawintegrationparameters_switchToSmallStepsPgsSolver","switchToSmallStepsPgsSolverWithoutWarmstart","rawintegrationparameters_switchToSmallStepsPgsSolverWithoutWarmstart","RawIslandManagerFinalization","__wbg_rawislandmanager_free","rawislandmanager_new","forEachActiveRigidBodyHandle","rawislandmanager_forEachActiveRigidBodyHandle","RawKinematicCharacterControllerFinalization","__wbg_rawkinematiccharactercontroller_free","RawKinematicCharacterController","offset","rawkinematiccharactercontroller_new","up","setUp","vector","rawkinematiccharactercontroller_setUp","normalNudgeFactor","rawkinematiccharactercontroller_normalNudgeFactor","setNormalNudgeFactor","rawkinematiccharactercontroller_setNormalNudgeFactor","setOffset","rawkinematiccharactercontroller_setOffset","slideEnabled","rawkinematiccharactercontroller_slideEnabled","setSlideEnabled","rawkinematiccharactercontroller_setSlideEnabled","autostepMaxHeight","rawkinematiccharactercontroller_autostepMaxHeight","autostepMinWidth","rawkinematiccharactercontroller_autostepMinWidth","autostepIncludesDynamicBodies","rawkinematiccharactercontroller_autostepIncludesDynamicBodies","autostepEnabled","rawkinematiccharactercontroller_autostepEnabled","enableAutostep","maxHeight","minWidth","includeDynamicBodies","rawkinematiccharactercontroller_enableAutostep","disableAutostep","rawkinematiccharactercontroller_disableAutostep","maxSlopeClimbAngle","setMaxSlopeClimbAngle","minSlopeSlideAngle","rawkinematiccharactercontroller_minSlopeSlideAngle","setMinSlopeSlideAngle","rawkinematiccharactercontroller_setMinSlopeSlideAngle","snapToGroundDistance","rawkinematiccharactercontroller_snapToGroundDistance","enableSnapToGround","distance","rawkinematiccharactercontroller_enableSnapToGround","disableSnapToGround","rawkinematiccharactercontroller_disableSnapToGround","snapToGroundEnabled","rawkinematiccharactercontroller_snapToGroundEnabled","computeColliderMovement","broad_phase","collider_handle","desired_translation_delta","apply_impulses_to_dynamic_bodies","character_mass","rawkinematiccharactercontroller_computeColliderMovement","Math","fround","computedMovement","rawkinematiccharactercontroller_computedMovement","computedGrounded","rawkinematiccharactercontroller_computedGrounded","numComputedCollisions","rawkinematiccharactercontroller_numComputedCollisions","computedCollision","collision","rawkinematiccharactercontroller_computedCollision","RawMultibodyJointSetFinalization","__wbg_rawmultibodyjointset_free","rawmultibodyjointset_jointType","rawmultibodyjointset_jointFrameX1","rawmultibodyjointset_jointFrameX2","rawmultibodyjointset_jointAnchor1","rawmultibodyjointset_jointAnchor2","rawmultibodyjointset_jointContactsEnabled","rawmultibodyjointset_jointSetContactsEnabled","rawmultibodyjointset_jointLimitsEnabled","rawmultibodyjointset_jointLimitsMin","rawmultibodyjointset_jointLimitsMax","rawmultibodyjointset_new","rawmultibodyjointset_createJoint","rawmultibodyjointset_remove","rawmultibodyjointset_contains","rawmultibodyjointset_forEachJointHandle","rawmultibodyjointset_forEachJointAttachedToRigidBody","RawNarrowPhaseFinalization","__wbg_rawnarrowphase_free","rawnarrowphase_new","contact_pairs_with","rawnarrowphase_contact_pairs_with","contact_pair","rawnarrowphase_contact_pair","intersection_pairs_with","rawnarrowphase_intersection_pairs_with","intersection_pair","rawnarrowphase_intersection_pair","RawPhysicsPipelineFinalization","__wbg_rawphysicspipeline_free","RawPhysicsPipeline","rawphysicspipeline_new","set_profiler_enabled","rawphysicspipeline_set_profiler_enabled","is_profiler_enabled","rawphysicspipeline_is_profiler_enabled","timing_step","rawphysicspipeline_timing_step","timing_collision_detection","rawphysicspipeline_timing_collision_detection","timing_broad_phase","rawphysicspipeline_timing_broad_phase","timing_narrow_phase","rawphysicspipeline_timing_narrow_phase","timing_solver","rawphysicspipeline_timing_solver","timing_velocity_assembly","rawphysicspipeline_timing_velocity_assembly","timing_velocity_resolution","rawphysicspipeline_timing_velocity_resolution","timing_velocity_update","rawphysicspipeline_timing_velocity_update","timing_velocity_writeback","rawphysicspipeline_timing_velocity_writeback","timing_ccd","rawphysicspipeline_timing_ccd","timing_ccd_toi_computation","rawphysicspipeline_timing_ccd_toi_computation","timing_ccd_broad_phase","rawphysicspipeline_timing_ccd_broad_phase","timing_ccd_narrow_phase","rawphysicspipeline_timing_ccd_narrow_phase","timing_ccd_solver","rawphysicspipeline_timing_ccd_solver","timing_island_construction","rawphysicspipeline_timing_island_construction","timing_user_changes","rawphysicspipeline_timing_user_changes","step","gravity","integrationParameters","broadPhase","narrowPhase","joints","articulations","ccd_solver","rawphysicspipeline_step","stepWithEvents","eventQueue","hookObject","hookFilterContactPair","hookFilterIntersectionPair","rawphysicspipeline_stepWithEvents","RawPidControllerFinalization","__wbg_rawpidcontroller_free","RawPidController","kp","ki","kd","axes_mask","rawpidcontroller_new","set_kp","axes","rawpidcontroller_set_kp","set_ki","rawpidcontroller_set_ki","set_kd","rawpidcontroller_set_kd","set_axes_mask","rawpidcontroller_set_axes_mask","reset_integrals","rawpidcontroller_reset_integrals","apply_linear_correction","rb_handle","target_translation","target_linvel","rawpidcontroller_apply_linear_correction","apply_angular_correction","target_rotation","target_angvel","rawpidcontroller_apply_angular_correction","linear_correction","rawpidcontroller_linear_correction","angular_correction","rawpidcontroller_angular_correction","RawPointColliderProjectionFinalization","__wbg_rawpointcolliderprojection_free","rawpointcolliderprojection_colliderHandle","rawpointcolliderprojection_point","isInside","rawpointcolliderprojection_isInside","featureType","rawpointcolliderprojection_featureType","featureId","rawpointcolliderprojection_featureId","RawPointProjectionFinalization","__wbg_rawpointprojection_free","rawpointprojection_point","rawpointprojection_isInside","RawRayColliderHitFinalization","__wbg_rawraycolliderhit_free","timeOfImpact","RawRayColliderIntersectionFinalization","__wbg_rawraycolliderintersection_free","RawRayIntersectionFinalization","__wbg_rawrayintersection_free","RawRigidBodySetFinalization","__wbg_rawrigidbodyset_free","rbTranslation","rawrigidbodyset_rbTranslation","rbRotation","rawrigidbodyset_rbRotation","rbSleep","rawrigidbodyset_rbSleep","rbIsSleeping","rawrigidbodyset_rbIsSleeping","rbIsMoving","rawrigidbodyset_rbIsMoving","rbNextTranslation","rawrigidbodyset_rbNextTranslation","rbNextRotation","rawrigidbodyset_rbNextRotation","rbSetTranslation","rawrigidbodyset_rbSetTranslation","rbSetRotation","rawrigidbodyset_rbSetRotation","rbSetLinvel","linvel","rawrigidbodyset_rbSetLinvel","rbSetAngvel","angvel","rawrigidbodyset_rbSetAngvel","rbSetNextKinematicTranslation","rawrigidbodyset_rbSetNextKinematicTranslation","rbSetNextKinematicRotation","rawrigidbodyset_rbSetNextKinematicRotation","rbRecomputeMassPropertiesFromColliders","rawrigidbodyset_rbRecomputeMassPropertiesFromColliders","rbSetAdditionalMass","rawrigidbodyset_rbSetAdditionalMass","rbSetAdditionalMassProperties","rawrigidbodyset_rbSetAdditionalMassProperties","rbLinvel","rawrigidbodyset_rbLinvel","rbAngvel","rawrigidbodyset_rbAngvel","rbVelocityAtPoint","rawrigidbodyset_rbVelocityAtPoint","rbLockTranslations","locked","rawrigidbodyset_rbLockTranslations","rbSetEnabledTranslations","allow_x","allow_y","rawrigidbodyset_rbSetEnabledTranslations","rbLockRotations","rawrigidbodyset_rbLockRotations","rbDominanceGroup","rawrigidbodyset_rbDominanceGroup","rbSetDominanceGroup","group","rawrigidbodyset_rbSetDominanceGroup","rbEnableCcd","rawrigidbodyset_rbEnableCcd","rbSetSoftCcdPrediction","rawrigidbodyset_rbSetSoftCcdPrediction","rbMass","rawrigidbodyset_rbMass","rbInvMass","rawrigidbodyset_rbInvMass","rbEffectiveInvMass","rawrigidbodyset_rbEffectiveInvMass","rbLocalCom","rawrigidbodyset_rbLocalCom","rbWorldCom","rawrigidbodyset_rbWorldCom","rbInvPrincipalInertiaSqrt","rawrigidbodyset_rbInvPrincipalInertiaSqrt","rbPrincipalInertia","rawrigidbodyset_rbPrincipalInertia","rbEffectiveWorldInvInertiaSqrt","rawrigidbodyset_rbEffectiveWorldInvInertiaSqrt","rbEffectiveAngularInertia","rawrigidbodyset_rbEffectiveAngularInertia","rbWakeUp","rawrigidbodyset_rbWakeUp","rbIsCcdEnabled","rawrigidbodyset_rbIsCcdEnabled","rbSoftCcdPrediction","rawrigidbodyset_rbSoftCcdPrediction","rbNumColliders","rawrigidbodyset_rbNumColliders","rbCollider","at","rawrigidbodyset_rbCollider","rbBodyType","rawrigidbodyset_rbBodyType","rbSetBodyType","status","rawrigidbodyset_rbSetBodyType","rbIsFixed","rawrigidbodyset_rbIsFixed","rbIsKinematic","rawrigidbodyset_rbIsKinematic","rbIsDynamic","rawrigidbodyset_rbIsDynamic","rbLinearDamping","rawrigidbodyset_rbLinearDamping","rbAngularDamping","rawrigidbodyset_rbAngularDamping","rbSetLinearDamping","rawrigidbodyset_rbSetLinearDamping","rbSetAngularDamping","rawrigidbodyset_rbSetAngularDamping","rbSetEnabled","rawrigidbodyset_rbSetEnabled","rbIsEnabled","rawrigidbodyset_rbIsEnabled","rbGravityScale","rawrigidbodyset_rbGravityScale","rbSetGravityScale","rawrigidbodyset_rbSetGravityScale","rbResetForces","rawrigidbodyset_rbResetForces","rbResetTorques","rawrigidbodyset_rbResetTorques","rbAddForce","force","rawrigidbodyset_rbAddForce","rbApplyImpulse","impulse","rawrigidbodyset_rbApplyImpulse","rbAddTorque","torque","rawrigidbodyset_rbAddTorque","rbApplyTorqueImpulse","torque_impulse","rawrigidbodyset_rbApplyTorqueImpulse","rbAddForceAtPoint","rawrigidbodyset_rbAddForceAtPoint","rbApplyImpulseAtPoint","rawrigidbodyset_rbApplyImpulseAtPoint","rbAdditionalSolverIterations","rawrigidbodyset_rbAdditionalSolverIterations","rbSetAdditionalSolverIterations","iters","rawrigidbodyset_rbSetAdditionalSolverIterations","rbUserData","rawrigidbodyset_rbUserData","rbSetUserData","data","rawrigidbodyset_rbSetUserData","rbUserForce","rawrigidbodyset_rbUserForce","rbUserTorque","rawrigidbodyset_rbUserTorque","rawrigidbodyset_new","createRigidBody","gravityScale","massOnly","translationEnabledX","translationEnabledY","rotationsEnabled","linearDamping","angularDamping","rb_type","canSleep","sleeping","softCcdPrediciton","ccdEnabled","dominanceGroup","additional_solver_iterations","rawrigidbodyset_createRigidBody","rawrigidbodyset_remove","rawrigidbodyset_contains","forEachRigidBodyHandle","rawrigidbodyset_forEachRigidBodyHandle","propagateModifiedBodyPositionsToColliders","rawrigidbodyset_propagateModifiedBodyPositionsToColliders","RawRotationFinalization","__wbg_rawrotation_free","rawrotation_identity","rawrotation_fromAngle","im","re","rawrotation_re","rawrotation_angle","RawSerializationPipelineFinalization","__wbg_rawserializationpipeline_free","RawSerializationPipeline","serializeAll","rawserializationpipeline_serializeAll","deserializeAll","rawserializationpipeline_deserializeAll","RawShapeFinalization","__wbg_rawshape_free","hx","hy","rawshape_cuboid","borderRadius","rawshape_roundCuboid","radius","rawshape_ball","rawshape_halfspace","halfHeight","rawshape_capsule","voxel_size","grid_coords","ptr0","__wbindgen_export_2","len0","rawshape_voxels","points","rawshape_voxelsFromPoints","indices","ptr1","len1","rawshape_polyline","flags","rawshape_trimesh","heights","scale","rawshape_heightfield","p1","p2","rawshape_segment","p3","rawshape_triangle","rawshape_roundTriangle","rawshape_convexHull","rawshape_roundConvexHull","rawshape_convexPolyline","rawshape_roundConvexPolyline","shapePos1","shapeRot1","shapeVel1","shapeVel2","rawshape_castShape","intersectsShape","rawshape_intersectsShape","contactShape","rawshape_contactShape","containsPoint","rawshape_containsPoint","rawshape_projectPoint","intersectsRay","rawshape_intersectsRay","rawshape_castRay","rawshape_castRayAndGetNormal","RawShapeCastHitFinalization","__wbg_rawshapecasthit_free","rawshapecasthit_witness1","RawShapeContactFinalization","__wbg_rawshapecontact_free","point1","point2","RawVectorFinalization","__wbg_rawvector_free","rawvector_zero","rawvector_new","rawvector_set_x","xy","rawvector_xy","yx","rawvector_yx","async","__wbg_init","module_or_path","getPrototypeOf","console","warn","URL","imports","wbg","__wbg_bind_c8359b1cba058168","arg0","arg1","arg2","arg3","bind","__wbg_buffer_609cc3eee51ed158","__wbg_call_672a4d21634d4a24","call","arguments","__wbg_call_7cccdd69e0791ae2","__wbg_call_833bed5770ea2041","__wbg_call_b8adc8b1d0a0d8eb","arg4","__wbg_length_3b4f022188ae8db6","__wbg_length_a446193dc22c12f8","__wbg_new_a12002a7f91c75be","__wbg_newnoargs_105ed471475aaf50","Function","__wbg_newwithbyteoffsetandlength_d97e637ebe145a9a","__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354","__wbg_newwithlength_5a5efe313cfd59f1","__wbg_now_2c95c9de01293173","now","__wbg_performance_7a3ffd0b17f663ad","performance","__wbg_rawcontactforceevent_new","__wbg_rawraycolliderintersection_new","__wbg_set_10bad9bee0e9c58b","__wbg_set_65595bdd868b3009","__wbg_static_accessor_GLOBAL_88a902d13a557d07","global","__wbg_static_accessor_GLOBAL_THIS_56578be7e9f832b0","globalThis","__wbg_static_accessor_SELF_37c5d418e4bf5819","self","__wbg_static_accessor_WINDOW_5de37043a91a9c40","window","__wbindgen_boolean_get","v","__wbindgen_is_function","__wbindgen_is_undefined","__wbindgen_memory","__wbindgen_number_get","setFloat64","setInt32","__wbindgen_number_new","__wbindgen_object_clone_ref","__wbindgen_object_drop_ref","__wbindgen_throw","__wbg_get_imports","Request","fetch","module","Response","WebAssembly","instantiateStreaming","headers","get","bytes","arrayBuffer","instantiate","Instance","__wbg_load","exports","__wbindgen_wasm_module","__wbg_finalize_init","Vector2","VectorOps","new","raw","res","out","input","RotationOps","fromAngle","RigidBodyType","JointType","MotorModel","JointAxesMask","CoefficientCombineRule","FeatureType","ShapeType","TriMeshFlags","PidAxesMask","ActiveEvents","ActiveHooks","SolverFlags","QueryFilterFlags","ActiveCollisionTypes","MassPropsMode","RigidBody","rawSet","colliderSet","finalizeDeserialization","isValid","lockTranslations","lockRotations","setEnabledTranslations","enableX","enableY","restrictTranslations","setDominanceGroup","additionalSolverIterations","setAdditionalSolverIterations","enableCcd","setSoftCcdPrediction","softCcdPrediction","fromRaw","nextTranslation","nextRotation","setTranslation","tra","setLinvel","vel","rawVel","intoRaw","setGravityScale","setRotation","setAngvel","setNextKinematicTranslation","t","setNextKinematicRotation","velocityAtPoint","rawPoint","result","effectiveInvMass","invMass","localCom","worldCom","invPrincipalInertiaSqrt","principalInertia","effectiveWorldInvInertiaSqrt","effectiveAngularInertia","sleep","isCcdEnabled","numColliders","collider","setEnabled","isEnabled","bodyType","setBodyType","type","isSleeping","isMoving","isFixed","isKinematic","isDynamic","setLinearDamping","recomputeMassPropertiesFromColliders","setAdditionalMass","setAdditionalMassProperties","rawCom","setAngularDamping","resetForces","resetTorques","addForce","rawForce","applyImpulse","rawImpulse","addTorque","applyTorqueImpulse","torqueImpulse","addForceAtPoint","applyImpulseAtPoint","userForce","userTorque","RigidBodyDesc","zeros","identity","translationsEnabledX","translationsEnabledY","TypeError","rot","copy","enabledTranslations","setCanSleep","can","setSleeping","setCcdEnabled","setUserData","userData","Coarena","fconv","Float64Array","uconv","size","index","delete","forEach","elt","getAll","filter","RigidBodySet","map","rb","desc","rawTra","rawRot","rawLv","impulseJoints","multibodyJoints","unmap","forEachJointHandleAttachedToRigidBody","forEachActiveRigidBody","IntegrationParameters","ImpulseJoint","bodySet","RevoluteImpulseJoint","PrismaticImpulseJoint","FixedImpulseJoint","SpringImpulseJoint","RopeImpulseJoint","body1","body2","setAnchor1","setAnchor2","setContactsEnabled","contactsEnabled","UnitImpulseJoint","rawAxis","setLimits","configureMotorModel","configureMotorVelocity","configureMotorPosition","configureMotor","JointData","frame1","frame2","rawAx","rawA1","rawA2","rawFra1","rawFra2","fixed","spring","rope","limits","prismatic","revolute","ImpulseJointSet","newTyped","joint","rawParams","MultibodyJoint","RevoluteMultibodyJoint","PrismaticMultibodyJoint","FixedMultibodyJoint","UnitMultibodyJoint","MultibodyJointSet","CCDSolver","IslandManager","Ray","origin","dir","pointAt","RayIntersection","RayColliderIntersection","RayColliderHit","PointProjection","PointColliderProjection","ShapeCastHit","ColliderShapeCastHit","super","BroadPhase","ray","filterFlags","filterGroups","filterExcludeCollider","filterExcludeRigidBody","filterPredicate","rawOrig","rawDir","rawInter","rawPos","rawShape","targetDistance","stopAtPenetration","rawCenter","rawHalfExtents","NarrowPhase","tempManifold","TempContactManifold","contactPairsWith","intersectionPairsWith","contactPair","rawPair","flipped","intersectionPair","localNormal1","localNormal2","numContacts","localContactPoint1","localContactPoint2","contactDist","contactFid1","contactFid2","contactImpulse","contactTangentImpulse","numSolverContacts","solverContactPoint","solverContactDist","solverContactFriction","solverContactRestitution","solverContactTangentVelocity","ShapeContact","dist","Shape","rawType","extents","vs","vox_data","vox_size","tri_flags","Heightfield","rawPos1","rawRot1","rawVel1","rawPos2","rawRot2","rawVel2","rawShape1","rawShape2","rawRayOrig","rawRayDir","ball","n","halfspace","halfExtents","cuboid","roundCuboid","capsule","a","b","ra","segment","c","rc","triangle","roundTriangle","polyline","voxelSize","voxels","voxelsFromPoints","trimesh","skipConvexHullComputation","convexPolyline","convexHull","roundConvexPolyline","roundConvexHull","rawScale","heightfield","PhysicsPipeline","ccdSolver","rawG","filterContactPair","filterIntersectionPair","SerializationPipeline","rawGra","World","DebugRenderBuffers","DebugRenderPipeline","castClosure","CharacterCollision","KinematicCharacterController","rawCharacterCollision","_applyImpulsesToDynamicBodies","_characterMass","rawVect","applyImpulsesToDynamicBodies","setApplyImpulsesToDynamicBodies","characterMass","setCharacterMass","desiredTranslationDelta","rawTranslationDelta","PidController","setKp","setKi","setKd","setAxes","resetIntegrals","applyLinearCorrection","targetPosition","targetLinvel","applyAngularCorrection","targetRotation","targetAngVel","linearCorrection","correction","angularCorrection","rawIntegrationParameters","rawIslands","rawBroadPhase","rawNarrowPhase","rawBodies","rawColliders","rawImpulseJoints","rawMultibodyJoints","rawCCDSolver","rawPhysicsPipeline","rawSerializationPipeline","rawDebugRenderPipeline","ColliderSet","physicsPipeline","serializationPipeline","debugRenderPipeline","characterControllers","Set","pidControllers","controller","takeSnapshot","debugRender","timestep","unitsPerMeter","niter","substeps","createCharacterController","add","removeCharacterController","createPidController","removePidController","parentHandle","createImpulseJoint","createMultibodyJoint","getRigidBody","getCollider","getImpulseJoint","getMultibodyJoint","removeRigidBody","removeCollider","removeImpulseJoint","removeMultibodyJoint","forEachCollider","forEachRigidBody","profilerEnabled","timingStep","timingCollisionDetection","timingBroadPhase","timingNarrowPhase","timingSolver","timingVelocityAssembly","timingVelocityResolution","timingVelocityUpdate","timingVelocityWriteback","timingCcd","timingCcdToiComputation","timingCcdBroadPhase","timingCcdNarrowPhase","timingCcdSolver","timingIslandConstruction","timingUserChanges","TempContactForceEvent","totalForce","totalForceMagnitude","maxForceDirection","maxForceMagnitude","EventQueue","event","Collider","_parent","_shape","ensureShapeIsCached","clearShapeCache","translationWrtParent","rotationWrtParent","setSensor","setShape","setRestitution","setFriction","setFrictionCombineRule","setRestitutionCombineRule","setCollisionGroups","setSolverGroups","setContactSkin","thickness","setActiveHooks","setActiveEvents","setContactForceEventThreshold","setActiveCollisionTypes","setDensity","setMass","setMassProperties","setTranslationWrtParent","setRotationWrtParent","shapeType","setHalfExtents","setRadius","roundRadius","setRoundRadius","setHalfHeight","setVoxel","propagateVoxelChange","voxels2","combineVoxelStates","heightfieldHeights","heightfieldScale","volume","rawCollider1Vel","rawShape2Pos","rawShape2Rot","rawShape2Vel","castCollider","rawCollider2Vel","contactCollider","ColliderDesc","Density","Average","DEFAULT","NONE","sensor","Mass","MassProps","isNaN","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","next","rejected","done","then","base64Js","b64","lens","getLens","validLen","placeHoldersLen","tmp","arr","Arr","_byteLength","curByte","revLookup","charCodeAt","uint8","extraBytes","parts","maxChunkLength","len2","encodeChunk","lookup","join","code","indexOf","start","end","num","output","init","wasmInit","base64","toByteArray","version","deferred1_0","deferred1_1","vers","reserveMemory","extraBytesCount","extra_bytes_count","reserve_memory"],"mappings":"AAAA,IAAIA,EAEJ,MAAMC,EAAO,IAAIC,MAAM,KAAKC,UAAKC,GAIjC,SAASC,EAAUC,GAAO,OAAOL,EAAKK,EAAO,CAF7CL,EAAKM,UAAKH,EAAW,MAAM,GAAM,GAIjC,IAAII,EAAYP,EAAKQ,OAErB,SAASC,EAAcC,GACfH,IAAcP,EAAKQ,QAAQR,EAAKM,KAAKN,EAAKQ,OAAS,GACvD,MAAMH,EAAME,EAIZ,OAHAA,EAAYP,EAAKK,GAEjBL,EAAKK,GAAOK,EACLL,CACX,CAEA,SAASM,EAAYC,EAAGC,GACpB,IACI,OAAOD,EAAEE,MAAMC,KAAMF,EAGxB,CAFC,MAAOG,GACLjB,EAAKkB,oBAAoBR,EAAcO,GAC1C,CACL,CAEA,MAAME,EAA4C,oBAAhBC,YAA8B,IAAIA,YAAY,QAAS,CAAEC,WAAW,EAAMC,OAAO,IAAU,CAAEC,OAAQ,KAAQ,MAAMC,MAAM,4BAA2B,GAE3J,oBAAhBJ,aAA+BD,EAAkBI,SAE5D,IAAIE,EAA0B,KAS9B,SAASC,EAAmBC,EAAKC,GAE7B,OADAD,KAAc,EACPR,EAAkBI,QARO,OAA5BE,GAA2E,IAAvCA,EAAwBI,aAC5DJ,EAA0B,IAAIK,WAAW9B,EAAK+B,OAAOC,SAElDP,GAKgDQ,SAASN,EAAKA,EAAMC,GAC/E,CAEA,SAASM,EAAWC,GAChB,OAAOA,OACX,CAEA,IAAIC,EAAwB,KAE5B,SAASC,IAIL,OAH8B,OAA1BD,IAA4E,IAA1CA,EAAsBJ,OAAOM,eAAgElC,IAA1CgC,EAAsBJ,OAAOM,UAA0BF,EAAsBJ,SAAWhC,EAAK+B,OAAOC,UACzLI,EAAwB,IAAIG,SAASvC,EAAK+B,OAAOC,SAE9CI,CACX,CAQA,SAASI,EAAWlC,GAChB,MAAMmC,EAAMpC,EAAUC,GAEtB,OATJ,SAAoBA,GACZA,EAAM,MACVL,EAAKK,GAAOE,EACZA,EAAYF,EAChB,CAIIoC,CAAWpC,GACJmC,CACX,CA4BA,SAASE,EAAaC,EAAUC,GAC5B,KAAMD,aAAoBC,GACtB,MAAM,IAAIrB,MAAM,wBAAwBqB,EAAMC,OAEtD,CAEA,IAAIC,EAAgB,IAEpB,SAASC,EAAkBrC,GACvB,GAAqB,GAAjBoC,EAAoB,MAAM,IAAIvB,MAAM,mBAExC,OADAvB,IAAO8C,GAAiBpC,EACjBoC,CACX,CAEA,IAAIE,EAA0B,KAS9B,SAASC,EAAqBvB,EAAKC,GAE/B,OADAD,KAAc,GAPkB,OAA5BsB,GAA2E,IAAvCA,EAAwBpB,aAC5DoB,EAA0B,IAAIE,WAAWnD,EAAK+B,OAAOC,SAElDiB,GAKuBhB,SAASN,EAAM,EAAGA,EAAM,EAAIC,EAC9D,CAEA,IAAIwB,EAA4B,KAEhC,SAASC,IAIL,OAHkC,OAA9BD,GAA+E,IAAzCA,EAA0BvB,aAChEuB,EAA4B,IAAIE,aAAatD,EAAK+B,OAAOC,SAEtDoB,CACX,CAEA,SAASG,EAAqB5B,EAAKC,GAE/B,OADAD,KAAc,EACP0B,IAAyBpB,SAASN,EAAM,EAAGA,EAAM,EAAIC,EAChE,CAEA,IAAI4B,EAA2B,KAE/B,SAASC,IAIL,OAHiC,OAA7BD,GAA6E,IAAxCA,EAAyB3B,aAC9D2B,EAA2B,IAAIE,YAAY1D,EAAK+B,OAAOC,SAEpDwB,CACX,CAOA,IAAIG,EAAkB,EAEtB,SAASC,EAAmBC,EAAKC,GAC7B,MAAMnC,EAAMmC,EAAoB,EAAbD,EAAIpD,OAAY,KAAO,EAG1C,OAFAgD,IAAwBM,IAAIF,EAAKlC,EAAM,GACvCgC,EAAkBE,EAAIpD,OACfkB,CACX,CAEA,SAASqC,EAAoBH,EAAKC,GAC9B,MAAMnC,EAAMmC,EAAoB,EAAbD,EAAIpD,OAAY,KAAO,EAG1C,OAFA4C,IAAyBU,IAAIF,EAAKlC,EAAM,GACxCgC,EAAkBE,EAAIpD,OACfkB,CACX,CAI8BsC,OAAOC,OAAO,CACxCC,OAAQ,EAAG,EAAK,SAChBC,KAAM,EAAG,EAAK,OACdC,QAAS,EAAG,EAAK,YAKd,MAAMC,EAAeL,OAAOC,OAAO,CACtCK,KAAM,EAAG,EAAK,OACdC,KAAM,EAAG,EAAK,OACdC,KAAM,EAAG,EAAK,SAKLC,EAAeT,OAAOC,OAAO,CACtCS,SAAU,EAAG,EAAK,WAClBC,MAAO,EAAG,EAAK,QACfC,UAAW,EAAG,EAAK,YACnBC,KAAM,EAAG,EAAK,OACdC,OAAQ,EAAG,EAAK,SAChBC,QAAS,EAAG,EAAK,YAKQf,OAAOC,OAAO,CACvCe,kBAAmB,EAAG,EAAK,oBAC3BC,WAAY,EAAG,EAAK,eAKQjB,OAAOC,OAAO,CAC1CiB,QAAS,EAAG,EAAK,UACjBP,MAAO,EAAG,EAAK,QACfQ,uBAAwB,EAAG,EAAK,yBAChCC,uBAAwB,EAAG,EAAK,2BAK7B,MAAMC,EAAerB,OAAOC,OAAO,CACtCqB,KAAM,EAAG,EAAK,OACdC,OAAQ,EAAG,EAAK,SAChBC,QAAS,EAAG,EAAK,UACjBC,QAAS,EAAG,EAAK,UACjBC,SAAU,EAAG,EAAK,WAClBC,SAAU,EAAG,EAAK,WAClBC,QAAS,EAAG,EAAK,UACjBC,YAAa,EAAG,EAAK,cACrBC,SAAU,EAAG,EAAK,WAClBC,cAAe,EAAG,EAAK,gBACvBC,YAAa,GAAI,GAAM,cACvBC,cAAe,GAAI,GAAM,gBACzBC,mBAAoB,GAAI,GAAM,qBAC9BC,UAAW,GAAI,GAAM,YACrBC,OAAQ,GAAI,GAAM,WAGhBC,EAA6D,oBAAzBC,qBACpC,CAAEC,SAAU,OAAUC,WAAY,QAClC,IAAIF,sBAAqB5E,GAAO3B,EAAK0G,yBAAyB/E,IAAQ,EAAG,KAExE,MAAMgF,EAETC,cAAcjF,GACVA,KAAc,EACd,MAAMhB,EAAMsD,OAAO4C,OAAOF,EAAcG,WAGxC,OAFAnG,EAAIoG,UAAYpF,EAChB2E,EAA0BE,SAAS7F,EAAKA,EAAIoG,UAAWpG,GAChDA,CACV,CAEDqG,qBACI,MAAMrF,EAAMX,KAAK+F,UAGjB,OAFA/F,KAAK+F,UAAY,EACjBT,EAA0BG,WAAWzF,MAC9BW,CACV,CAEDsF,OACI,MAAMtF,EAAMX,KAAKgG,qBACjBhH,EAAK0G,yBAAyB/E,EAAK,EACtC,CACDuF,cACI,MAAMzE,EAAMzC,EAAKmH,oBAGjB,OAFAnG,KAAK+F,UAAYtE,IAAQ,EACzB6D,EAA0BE,SAASxF,KAAMA,KAAK+F,UAAW/F,MAClDA,IACV,CAgBDoG,QAAQC,EAAcC,EAAQC,EAAWC,EAASC,EAAQC,EAAQC,EAAOC,EAAcC,EAAeC,EAAyBC,EAA2BC,GACtJ,IACIrF,EAAa0E,EAAcY,IAC3BtF,EAAa2E,EAAQY,IACrBvF,EAAa4E,EAAWY,GACxBxF,EAAa6E,EAASY,IACtBzF,EAAa8E,EAAQW,IACrB,MAAM3F,EAAMzC,EAAKqI,sBAAsBrH,KAAK+F,UAAWM,EAAaN,UAAWO,EAAOP,UAAWQ,EAAUR,UAAWS,EAAQT,UAAWU,EAAOV,UAAWW,EAAQC,EAAOC,EAAc1F,EAAW2F,GAAiB,WAAc,IAAoB,GAAI3F,EAAW4F,GAA0B5F,EAAW4F,GAA2B,EAAIA,GAA0B5F,EAAW6F,GAA4B7F,EAAW6F,GAA6B,EAAIA,EAA2B/E,EAAkBgF,IACne,OAAe,IAARvF,OAAYrC,EAAYkI,GAAkBC,OAAO9F,EAG3D,CAFS,QACNxC,EAAK8C,UAAmB3C,CAC3B,CACJ,CAgBDoI,oBAAoBnB,EAAcC,EAAQC,EAAWC,EAASC,EAAQC,EAAQC,EAAOC,EAAcC,EAAeC,EAAyBC,EAA2BC,GAClK,IACIrF,EAAa0E,EAAcY,IAC3BtF,EAAa2E,EAAQY,IACrBvF,EAAa4E,EAAWY,GACxBxF,EAAa6E,EAASY,IACtBzF,EAAa8E,EAAQW,IACrB,MAAM3F,EAAMzC,EAAKyI,kCAAkCzH,KAAK+F,UAAWM,EAAaN,UAAWO,EAAOP,UAAWQ,EAAUR,UAAWS,EAAQT,UAAWU,EAAOV,UAAWW,EAAQC,EAAOC,EAAc1F,EAAW2F,GAAiB,WAAc,IAAoB,GAAI3F,EAAW4F,GAA0B5F,EAAW4F,GAA2B,EAAIA,GAA0B5F,EAAW6F,GAA4B7F,EAAW6F,GAA6B,EAAIA,EAA2B/E,EAAkBgF,IAC/e,OAAe,IAARvF,OAAYrC,EAAYsI,GAA2BH,OAAO9F,EAGpE,CAFS,QACNxC,EAAK8C,UAAmB3C,CAC3B,CACJ,CAgBDuI,qBAAqBtB,EAAcC,EAAQC,EAAWC,EAASC,EAAQC,EAAQC,EAAOiB,EAAUhB,EAAcC,EAAeC,EAAyBC,EAA2BC,GAC7K,IACIrF,EAAa0E,EAAcY,IAC3BtF,EAAa2E,EAAQY,IACrBvF,EAAa4E,EAAWY,GACxBxF,EAAa6E,EAASY,IACtBzF,EAAa8E,EAAQW,IACrBpI,EAAK6I,mCAAmC7H,KAAK+F,UAAWM,EAAaN,UAAWO,EAAOP,UAAWQ,EAAUR,UAAWS,EAAQT,UAAWU,EAAOV,UAAWW,EAAQC,EAAO3E,EAAkB4F,GAAWhB,EAAc1F,EAAW2F,GAAiB,WAAc,IAAoB,GAAI3F,EAAW4F,GAA0B5F,EAAW4F,GAA2B,EAAIA,GAA0B5F,EAAW6F,GAA4B7F,EAAW6F,GAA6B,EAAIA,EAA2B/E,EAAkBgF,GAIpgB,CAHS,QACN/H,EAAK8C,UAAmB3C,EACxBH,EAAK8C,UAAmB3C,CAC3B,CACJ,CAeD0I,sBAAsBzB,EAAcC,EAAQC,EAAWwB,EAAUC,EAAUC,EAAOrB,EAAcC,EAAeC,EAAyBC,EAA2BC,GAC/J,IACI,MAAMkB,EAASlJ,EAAKmJ,iCAAiC,IACrDxG,EAAa0E,EAAcY,IAC3BtF,EAAa2E,EAAQY,IACrBvF,EAAa4E,EAAWY,GACxBxF,EAAaoG,EAAUX,IACvBzF,EAAaqG,EAAUI,IACvBzG,EAAasG,EAAOI,IACpBrJ,EAAKsJ,oCAAoCJ,EAAQlI,KAAK+F,UAAWM,EAAaN,UAAWO,EAAOP,UAAWQ,EAAUR,UAAWgC,EAAShC,UAAWiC,EAASjC,UAAWkC,EAAMlC,UAAWa,EAAc1F,EAAW2F,GAAiB,WAAc,IAAoB,GAAI3F,EAAW4F,GAA0B5F,EAAW4F,GAA2B,EAAIA,GAA0B5F,EAAW6F,GAA4B7F,EAAW6F,GAA6B,EAAIA,EAA2B/E,EAAkBgF,IAClf,IAAIuB,EAAKlH,IAAqBmH,SAASN,EAAS,GAAO,GACnDO,EAAKpH,IAAqBqH,WAAWR,EAAS,GAAO,GACzD,OAAc,IAAPK,OAAWnJ,EAAYqJ,CAIjC,CAHS,QACNzJ,EAAKmJ,gCAAgC,IACrClJ,EAAK8C,UAAmB3C,CAC3B,CACJ,CAcDuJ,aAAatC,EAAcC,EAAQC,EAAWqC,EAAOjC,EAAOC,EAAcC,EAAeC,EAAyBC,EAA2BC,GACzI,IACIrF,EAAa0E,EAAcY,IAC3BtF,EAAa2E,EAAQY,IACrBvF,EAAa4E,EAAWY,GACxBxF,EAAaiH,EAAOxB,IACpB,MAAM3F,EAAMzC,EAAK6J,2BAA2B7I,KAAK+F,UAAWM,EAAaN,UAAWO,EAAOP,UAAWQ,EAAUR,UAAW6C,EAAM7C,UAAWY,EAAOC,EAAc1F,EAAW2F,GAAiB,WAAc,IAAoB,GAAI3F,EAAW4F,GAA0B5F,EAAW4F,GAA2B,EAAIA,GAA0B5F,EAAW6F,GAA4B7F,EAAW6F,GAA6B,EAAIA,EAA2B/E,EAAkBgF,IAC5c,OAAe,IAARvF,OAAYrC,EAAY0J,GAA2BvB,OAAO9F,EAGpE,CAFS,QACNxC,EAAK8C,UAAmB3C,CAC3B,CACJ,CAaD2J,0BAA0B1C,EAAcC,EAAQC,EAAWqC,EAAOhC,EAAcC,EAAeC,EAAyBC,EAA2BC,GAC/I,IACIrF,EAAa0E,EAAcY,IAC3BtF,EAAa2E,EAAQY,IACrBvF,EAAa4E,EAAWY,GACxBxF,EAAaiH,EAAOxB,IACpB,MAAM3F,EAAMzC,EAAKgK,wCAAwChJ,KAAK+F,UAAWM,EAAaN,UAAWO,EAAOP,UAAWQ,EAAUR,UAAW6C,EAAM7C,UAAWa,EAAc1F,EAAW2F,GAAiB,WAAc,IAAoB,GAAI3F,EAAW4F,GAA0B5F,EAAW4F,GAA2B,EAAIA,GAA0B5F,EAAW6F,GAA4B7F,EAAW6F,GAA6B,EAAIA,EAA2B/E,EAAkBgF,IACld,OAAe,IAARvF,OAAYrC,EAAY0J,GAA2BvB,OAAO9F,EAGpE,CAFS,QACNxC,EAAK8C,UAAmB3C,CAC3B,CACJ,CAaD6J,uBAAuB5C,EAAcC,EAAQC,EAAWqC,EAAOhB,EAAUhB,EAAcC,EAAeC,EAAyBC,EAA2BC,GACtJ,IACIrF,EAAa0E,EAAcY,IAC3BtF,EAAa2E,EAAQY,IACrBvF,EAAa4E,EAAWY,GACxBxF,EAAaiH,EAAOxB,IACpBpI,EAAKkK,qCAAqClJ,KAAK+F,UAAWM,EAAaN,UAAWO,EAAOP,UAAWQ,EAAUR,UAAW6C,EAAM7C,UAAW/D,EAAkB4F,GAAWhB,EAAc1F,EAAW2F,GAAiB,WAAc,IAAoB,GAAI3F,EAAW4F,GAA0B5F,EAAW4F,GAA2B,EAAIA,GAA0B5F,EAAW6F,GAA4B7F,EAAW6F,GAA6B,EAAIA,EAA2B/E,EAAkBgF,GAIne,CAHS,QACN/H,EAAK8C,UAAmB3C,EACxBH,EAAK8C,UAAmB3C,CAC3B,CACJ,CAmBD+J,UAAU9C,EAAcC,EAAQC,EAAWwB,EAAUC,EAAUoB,EAAUnB,EAAOoB,EAAiB3C,EAAQ4C,EAAqB1C,EAAcC,EAAeC,EAAyBC,EAA2BC,GAC3M,IACIrF,EAAa0E,EAAcY,IAC3BtF,EAAa2E,EAAQY,IACrBvF,EAAa4E,EAAWY,GACxBxF,EAAaoG,EAAUX,IACvBzF,EAAaqG,EAAUI,IACvBzG,EAAayH,EAAUhC,IACvBzF,EAAasG,EAAOI,IACpB,MAAM5G,EAAMzC,EAAKuK,wBAAwBvJ,KAAK+F,UAAWM,EAAaN,UAAWO,EAAOP,UAAWQ,EAAUR,UAAWgC,EAAShC,UAAWiC,EAASjC,UAAWqD,EAASrD,UAAWkC,EAAMlC,UAAWsD,EAAiB3C,EAAQ4C,EAAqB1C,EAAc1F,EAAW2F,GAAiB,WAAc,IAAoB,GAAI3F,EAAW4F,GAA0B5F,EAAW4F,GAA2B,EAAIA,GAA0B5F,EAAW6F,GAA4B7F,EAAW6F,GAA6B,EAAIA,EAA2B/E,EAAkBgF,IAC5iB,OAAe,IAARvF,OAAYrC,EAAYoK,EAAwBjC,OAAO9F,EAGjE,CAFS,QACNxC,EAAK8C,UAAmB3C,CAC3B,CACJ,CAeDqK,uBAAuBpD,EAAcC,EAAQC,EAAWwB,EAAUC,EAAUC,EAAOL,EAAUhB,EAAcC,EAAeC,EAAyBC,EAA2BC,GAC1K,IACIrF,EAAa0E,EAAcY,IAC3BtF,EAAa2E,EAAQY,IACrBvF,EAAa4E,EAAWY,GACxBxF,EAAaoG,EAAUX,IACvBzF,EAAaqG,EAAUI,IACvBzG,EAAasG,EAAOI,IACpBrJ,EAAK0K,qCAAqC1J,KAAK+F,UAAWM,EAAaN,UAAWO,EAAOP,UAAWQ,EAAUR,UAAWgC,EAAShC,UAAWiC,EAASjC,UAAWkC,EAAMlC,UAAW/D,EAAkB4F,GAAWhB,EAAc1F,EAAW2F,GAAiB,WAAc,IAAoB,GAAI3F,EAAW4F,GAA0B5F,EAAW4F,GAA2B,EAAIA,GAA0B5F,EAAW6F,GAA4B7F,EAAW6F,GAA6B,EAAIA,EAA2B/E,EAAkBgF,GAI3gB,CAHS,QACN/H,EAAK8C,UAAmB3C,EACxBH,EAAK8C,UAAmB3C,CAC3B,CACJ,CASDuK,kCAAkCtD,EAAcC,EAAQC,EAAWqD,EAAYC,EAAiBjC,GAC5F,IACIjG,EAAa0E,EAAcY,IAC3BtF,EAAa2E,EAAQY,IACrBvF,EAAa4E,EAAWY,GACxBxF,EAAaiI,EAAYxC,IACzBzF,EAAakI,EAAiBzC,IAC9BpI,EAAK8K,gDAAgD9J,KAAK+F,UAAWM,EAAaN,UAAWO,EAAOP,UAAWQ,EAAUR,UAAW6D,EAAW7D,UAAW8D,EAAgB9D,UAAW/D,EAAkB4F,GAG1M,CAFS,QACN3I,EAAK8C,UAAmB3C,CAC3B,CACJ,EAGL,MAAM2K,EAA4D,oBAAzBxE,qBACnC,CAAEC,SAAU,OAAUC,WAAY,QAClC,IAAIF,sBAAqB5E,GAAO3B,EAAKgL,wBAAwBrJ,IAAQ,EAAG,KAEvE,MAAMsJ,EAETjE,qBACI,MAAMrF,EAAMX,KAAK+F,UAGjB,OAFA/F,KAAK+F,UAAY,EACjBgE,EAAyBtE,WAAWzF,MAC7BW,CACV,CAEDsF,OACI,MAAMtF,EAAMX,KAAKgG,qBACjBhH,EAAKgL,wBAAwBrJ,EAAK,EACrC,CACDuF,cACI,MAAMzE,EAAMzC,EAAKkL,mBAGjB,OAFAlK,KAAK+F,UAAYtE,IAAQ,EACzBsI,EAAyBvE,SAASxF,KAAMA,KAAK+F,UAAW/F,MACjDA,IACV,EAGL,MAAMmK,EAAqE,oBAAzB5E,qBAC5C,CAAEC,SAAU,OAAUC,WAAY,QAClC,IAAIF,sBAAqB5E,GAAO3B,EAAKoL,iCAAiCzJ,IAAQ,EAAG,KAEhF,MAAM0J,EAETrE,qBACI,MAAMrF,EAAMX,KAAK+F,UAGjB,OAFA/F,KAAK+F,UAAY,EACjBoE,EAAkC1E,WAAWzF,MACtCW,CACV,CAEDsF,OACI,MAAMtF,EAAMX,KAAKgG,qBACjBhH,EAAKoL,iCAAiCzJ,EAAK,EAC9C,CACDuF,cACI,MAAMzE,EAAMzC,EAAKsL,4BAGjB,OAFAtK,KAAK+F,UAAYtE,IAAQ,EACzB0I,EAAkC3E,SAASxF,KAAMA,KAAK+F,UAAW/F,MAC1DA,IACV,CAIDuK,SAEI,OADYvL,EAAKwL,6BAA6BxK,KAAK+F,UAEtD,CAID0E,0BACI,MAAMhJ,EAAMzC,EAAK0L,8CAA8C1K,KAAK+F,WACpE,OAAOqB,GAAUG,OAAO9F,EAC3B,CAIDkJ,4BACI,MAAMlJ,EAAMzC,EAAK4L,gDAAgD5K,KAAK+F,WACtE,OAAOqB,GAAUG,OAAO9F,EAC3B,CAIDoJ,MAEI,OADY7L,EAAK8L,0BAA0B9K,KAAK+F,UAEnD,CAIDgF,gBACI,MAAMtJ,EAAMzC,EAAKgM,oCAAoChL,KAAK+F,WAC1D,OAAOqB,GAAUG,OAAO9F,EAC3B,CAIDwJ,gBACI,MAAMxJ,EAAMzC,EAAKkM,oCAAoClL,KAAK+F,WAC1D,OAAOqB,GAAUG,OAAO9F,EAC3B,CAID0J,eACI,MAAM1J,EAAMzC,EAAKoM,mCAAmCpL,KAAK+F,WACzD,OAAOqB,GAAUG,OAAO9F,EAC3B,CAID4J,eACI,MAAM5J,EAAMzC,EAAKsM,mCAAmCtL,KAAK+F,WACzD,OAAOqB,GAAUG,OAAO9F,EAC3B,EAGL,MAAM8J,EAA8D,oBAAzBhG,qBACrC,CAAEC,SAAU,OAAUC,WAAY,QAClC,IAAIF,sBAAqB5E,GAAO3B,EAAKwM,0BAA0B7K,IAAQ,EAAG,KAEzE,MAAMwG,EAETvB,cAAcjF,GACVA,KAAc,EACd,MAAMhB,EAAMsD,OAAO4C,OAAOsB,EAAerB,WAGzC,OAFAnG,EAAIoG,UAAYpF,EAChB4K,EAA2B/F,SAAS7F,EAAKA,EAAIoG,UAAWpG,GACjDA,CACV,CAEDqG,qBACI,MAAMrF,EAAMX,KAAK+F,UAGjB,OAFA/F,KAAK+F,UAAY,EACjBwF,EAA2B9F,WAAWzF,MAC/BW,CACV,CAEDsF,OACI,MAAMtF,EAAMX,KAAKgG,qBACjBhH,EAAKwM,0BAA0B7K,EAAK,EACvC,CAMD8K,cAAclB,GACV,MAAM9I,EAAMzC,EAAK0M,6BAA6B1L,KAAK+F,UAAWwE,GAC9D,OAAOnD,GAAUG,OAAO9F,EAC3B,CAMDkK,WAAWpB,GACP,MAAM9I,EAAMzC,EAAK4M,0BAA0B5L,KAAK+F,UAAWwE,GAC3D,OAAOnC,GAAYb,OAAO9F,EAC7B,CAQDoK,uBAAuBtB,GACnB,MAAM9I,EAAMzC,EAAK8M,sCAAsC9L,KAAK+F,UAAWwE,GACvE,OAAe,IAAR9I,OAAYrC,EAAYgI,GAAUG,OAAO9F,EACnD,CAQDsK,oBAAoBxB,GAChB,MAAM9I,EAAMzC,EAAKgN,mCAAmChM,KAAK+F,UAAWwE,GACpE,OAAe,IAAR9I,OAAYrC,EAAYgJ,GAAYb,OAAO9F,EACrD,CAaDwK,iBAAiB1B,EAAQpJ,EAAG+K,GACxBlN,EAAKmN,gCAAgCnM,KAAK+F,UAAWwE,EAAQpJ,EAAG+K,EACnE,CAMDE,0BAA0B7B,EAAQpJ,EAAG+K,GACjClN,EAAKqN,yCAAyCrM,KAAK+F,UAAWwE,EAAQpJ,EAAG+K,EAC5E,CAWDI,cAAc/B,EAAQgC,GAClBvN,EAAKwN,6BAA6BxM,KAAK+F,UAAWwE,EAAQgC,EAC7D,CAKDE,uBAAuBlC,EAAQgC,GAC3BvN,EAAK0N,sCAAsC1M,KAAK+F,UAAWwE,EAAQgC,EACtE,CAMDI,WAAWpC,GAEP,OAAe,IADHvL,EAAK4N,0BAA0B5M,KAAK+F,UAAWwE,EAE9D,CAMDsC,YAAYtC,GAER,OADYvL,EAAK8N,2BAA2B9M,KAAK+F,UAAWwE,EAE/D,CAKDwC,kBAAkBxC,GACd,MAAM9I,EAAMzC,EAAKgO,iCAAiChN,KAAK+F,UAAWwE,GAClE,OAAe,IAAR9I,OAAYrC,EAAYgI,GAAUG,OAAO9F,EACnD,CAMDwL,cAAc1C,GACV,MAAM9I,EAAMzC,EAAKkO,6BAA6BlN,KAAK+F,UAAWwE,GAC9D,OAAe,IAAR9I,OAAYrC,EAAYgI,GAAUG,OAAO9F,EACnD,CAMD0L,iBAAiB5C,EAAQ6C,GACrBzL,EAAayL,EAAgBhG,IAC7BpI,EAAKqO,gCAAgCrN,KAAK+F,UAAWwE,EAAQ6C,EAAerH,UAC/E,CAMDuH,SAAS/C,GACL,MAAM9I,EAAMzC,EAAKuO,wBAAwBvN,KAAK+F,UAAWwE,GACzD,OAAe,aAAR9I,OAAsBrC,EAAYqC,CAC5C,CAMD+L,YAAYjD,EAAQkD,GAChBzO,EAAK0O,2BAA2B1N,KAAK+F,UAAWwE,EAAQkD,EAC3D,CAMDE,aAAapD,GACT,MAAM9I,EAAMzC,EAAK4O,4BAA4B5N,KAAK+F,UAAWwE,GAC7D,OAAe,aAAR9I,OAAsBrC,EAAYqC,CAC5C,CAMDoM,gBAAgBtD,EAAQuD,GACpB9O,EAAK+O,+BAA+B/N,KAAK+F,UAAWwE,EAAQuD,EAC/D,CAMDE,cAAczD,GACV,MAAM9I,EAAMzC,EAAKiP,6BAA6BjO,KAAK+F,UAAWwE,GAC9D,OAAe,aAAR9I,OAAsBrC,EAAYqC,CAC5C,CAMDyM,iBAAiB3D,EAAQ4D,GACrBnP,EAAKoP,gCAAgCpO,KAAK+F,UAAWwE,EAAQ4D,EAChE,CAKDE,YAAY9D,GACR,IACI,MAAMrC,EAASlJ,EAAKmJ,iCAAiC,IACrDnJ,EAAKsP,2BAA2BpG,EAAQlI,KAAK+F,UAAWwE,GACxD,IAAIhC,EAAKlH,IAAqBmH,SAASN,EAAS,GAAO,GACnDqG,EAAKlN,IAAqBmH,SAASN,EAAS,GAAO,GACvD,IAAIsG,EAKJ,OAJW,IAAPjG,IACAiG,EAAKtM,EAAqBqG,EAAIgG,GAAIE,QAClCzP,EAAK0P,oBAAoBnG,EAAS,EAALgG,EAAQ,IAElCC,CAGV,CAFS,QACNxP,EAAKmJ,gCAAgC,GACxC,CACJ,CAKDwG,YAAYpE,GACR,MAAM9I,EAAMzC,EAAK4P,2BAA2B5O,KAAK+F,UAAWwE,GAC5D,OAAe,IAAR9I,OAAYrC,EAAYgI,GAAUG,OAAO9F,EACnD,CAODoN,WAAWtE,EAAQuE,EAAIC,EAAIC,GACvBhQ,EAAKiQ,0BAA0BjP,KAAK+F,UAAWwE,EAAQuE,EAAIC,EAAIC,EAClE,CASDE,uBAAuBC,EAASC,EAASN,EAAIC,EAAIM,EAASC,GACtDtQ,EAAKuQ,sCAAsCvP,KAAK+F,UAAWoJ,EAASC,EAASN,EAAIC,EAAIM,EAASC,EACjG,CAODE,qBAAqBL,EAASC,EAASC,EAASC,GAC5CtQ,EAAKyQ,oCAAoCzP,KAAK+F,UAAWoJ,EAASC,EAASC,EAASC,EACvF,CAMDI,WAAWnF,GACP,IACI,MAAMrC,EAASlJ,EAAKmJ,iCAAiC,IACrDnJ,EAAK2Q,0BAA0BzH,EAAQlI,KAAK+F,UAAWwE,GACvD,IAAIhC,EAAKlH,IAAqBmH,SAASN,EAAS,GAAO,GACnDqG,EAAKlN,IAAqBmH,SAASN,EAAS,GAAO,GACvD,IAAIsG,EAKJ,OAJW,IAAPjG,IACAiG,EAAKjM,EAAqBgG,EAAIgG,GAAIE,QAClCzP,EAAK0P,oBAAoBnG,EAAS,EAALgG,EAAQ,IAElCC,CAGV,CAFS,QACNxP,EAAKmJ,gCAAgC,GACxC,CACJ,CAMDyH,UAAUrF,GACN,IACI,MAAMrC,EAASlJ,EAAKmJ,iCAAiC,IACrDnJ,EAAK6Q,yBAAyB3H,EAAQlI,KAAK+F,UAAWwE,GACtD,IAAIhC,EAAKlH,IAAqBmH,SAASN,EAAS,GAAO,GACnDqG,EAAKlN,IAAqBmH,SAASN,EAAS,GAAO,GACvD,IAAIsG,EAKJ,OAJW,IAAPjG,IACAiG,EAnxBhB,SAA8B7N,EAAKC,GAE/B,OADAD,KAAc,EACP8B,IAAwBxB,SAASN,EAAM,EAAGA,EAAM,EAAIC,EAC/D,CAgxBqBkP,CAAqBvH,EAAIgG,GAAIE,QAClCzP,EAAK0P,oBAAoBnG,EAAS,EAALgG,EAAQ,IAElCC,CAGV,CAFS,QACNxP,EAAKmJ,gCAAgC,GACxC,CACJ,CAKD4H,eAAexF,GACX,MAAM9I,EAAMzC,EAAKgR,8BAA8BhQ,KAAK+F,UAAWwE,GAC/D,OAAe,aAAR9I,OAAsBrC,EAAYqC,CAC5C,CAMDwO,qBAAqB1F,GACjB,IACI,MAAMrC,EAASlJ,EAAKmJ,iCAAiC,IACrDnJ,EAAKkR,oCAAoChI,EAAQlI,KAAK+F,UAAWwE,GACjE,IAAIhC,EAAKlH,IAAqBmH,SAASN,EAAS,GAAO,GACnDqG,EAAKlN,IAAqBmH,SAASN,EAAS,GAAO,GACvD,IAAIsG,EAKJ,OAJW,IAAPjG,IACAiG,EAAKjM,EAAqBgG,EAAIgG,GAAIE,QAClCzP,EAAK0P,oBAAoBnG,EAAS,EAALgG,EAAQ,IAElCC,CAGV,CAFS,QACNxP,EAAKmJ,gCAAgC,GACxC,CACJ,CAMDgI,mBAAmB5F,GACf,MAAM9I,EAAMzC,EAAKoR,kCAAkCpQ,KAAK+F,UAAWwE,GACnE,OAAe,IAAR9I,OAAYrC,EAAYgI,GAAUG,OAAO9F,EACnD,CAMD4O,SAAS9F,GACL,IACI,MAAMrC,EAASlJ,EAAKmJ,iCAAiC,IACrDnJ,EAAKsR,wBAAwBpI,EAAQlI,KAAK+F,UAAWwE,GACrD,IAAIhC,EAAKlH,IAAqBmH,SAASN,EAAS,GAAO,GACnDO,EAAKpH,IAAqBqH,WAAWR,EAAS,GAAO,GACzD,OAAc,IAAPK,OAAWnJ,EAAYqJ,CAGjC,CAFS,QACNzJ,EAAKmJ,gCAAgC,GACxC,CACJ,CAKDoI,aAAahG,EAAQiG,GACjBxR,EAAKyR,4BAA4BzQ,KAAK+F,UAAWwE,EAAQiG,EAC5D,CAKDE,YAAYnG,GAER,OAAe,IADHvL,EAAK2R,2BAA2B3Q,KAAK+F,UAAWwE,EAE/D,CAKDqG,iBAAiBrG,EAAQsG,GACrB7R,EAAK8R,gCAAgC9Q,KAAK+F,UAAWwE,EAAQsG,EAChE,CAKDE,cAAcxG,GAEV,OADYvL,EAAKgS,6BAA6BhR,KAAK+F,UAAWwE,EAEjE,CAMD0G,WAAW1G,GAEP,OADYvL,EAAKkS,0BAA0BlR,KAAK+F,UAAWwE,EAE9D,CAMD4G,cAAc5G,GAEV,OADYvL,EAAKoS,6BAA6BpR,KAAK+F,UAAWwE,EAEjE,CAMD8G,UAAU9G,GAEN,OADYvL,EAAKsS,yBAAyBtR,KAAK+F,UAAWwE,EAE7D,CAMDgH,OAAOhH,GAEH,OADYvL,EAAKwS,sBAAsBxR,KAAK+F,UAAWwE,EAE1D,CAMDkH,SAASlH,GAEL,OADYvL,EAAK0S,wBAAwB1R,KAAK+F,UAAWwE,EAE5D,CAMDoH,kBAAkBpH,GAEd,OADYvL,EAAK4S,iCAAiC5R,KAAK+F,UAAWwE,KACnD,CAClB,CAMDsH,eAAetH,GAEX,OADYvL,EAAK8S,8BAA8B9R,KAAK+F,UAAWwE,KAChD,CAClB,CAMDwH,cAAcxH,GAEV,OADYvL,EAAKgT,6BAA6BhS,KAAK+F,UAAWwE,KAC/C,CAClB,CAMD0H,uBAAuB1H,GAEnB,OADYvL,EAAKkT,sCAAsClS,KAAK+F,UAAWwE,EAE1E,CAMD4H,eAAe5H,GAEX,OADYvL,EAAKoT,8BAA8BpS,KAAK+F,UAAWwE,KAChD,CAClB,CAMD8H,6BAA6B9H,GAEzB,OADYvL,EAAKsT,4CAA4CtS,KAAK+F,UAAWwE,EAEhF,CAMDgI,gBAAgBhI,EAAQ3B,GACpBjH,EAAaiH,EAAOxB,IAEpB,OAAe,IADHpI,EAAKwT,+BAA+BxS,KAAK+F,UAAWwE,EAAQ3B,EAAM7C,UAEjF,CAaD0M,YAAYlI,EAAQmI,EAAaC,EAAQC,EAAWC,EAAWC,EAAWzJ,EAAiB3C,EAAQ4C,GAC/F3H,EAAa+Q,EAAatL,IAC1BzF,EAAagR,EAAQtK,IACrB1G,EAAaiR,EAAWxL,IACxBzF,EAAakR,EAAWzK,IACxBzG,EAAamR,EAAW1L,IACxB,MAAM3F,EAAMzC,EAAK+T,2BAA2B/S,KAAK+F,UAAWwE,EAAQmI,EAAY3M,UAAW4M,EAAO5M,UAAW6M,EAAU7M,UAAW8M,EAAU9M,UAAW+M,EAAU/M,UAAWsD,EAAiB3C,EAAQ4C,GACrM,OAAe,IAAR7H,OAAYrC,EAAY4T,GAAgBzL,OAAO9F,EACzD,CAWDwR,eAAe1I,EAAQ2I,EAAcC,EAAiBC,EAAc/J,EAAiBgK,EAAS/J,GAC1F3H,EAAauR,EAAc9L,IAC3BzF,EAAayR,EAAchM,IAC3B,MAAM3F,EAAMzC,EAAKsU,8BAA8BtT,KAAK+F,UAAWwE,EAAQ2I,EAAanN,UAAWoN,EAAiBC,EAAarN,UAAWsD,EAAiBgK,EAAS/J,GAClK,OAAe,IAAR7H,OAAYrC,EAAYoK,EAAwBjC,OAAO9F,EACjE,CAQD8R,kBAAkBhJ,EAAQoI,EAAQa,EAAWC,GACzC9R,EAAagR,EAAQtK,IACrB1G,EAAa6R,EAAWpM,IACxBzF,EAAa8R,EAAWrL,IAExB,OAAe,IADHpJ,EAAK0U,iCAAiC1T,KAAK+F,UAAWwE,EAAQoI,EAAO5M,UAAWyN,EAAUzN,UAAW0N,EAAU1N,UAE9H,CASD4N,eAAepJ,EAAQoI,EAAQa,EAAWC,EAAWG,GACjDjS,EAAagR,EAAQtK,IACrB1G,EAAa6R,EAAWpM,IACxBzF,EAAa8R,EAAWrL,IACxB,MAAM3G,EAAMzC,EAAK6U,8BAA8B7T,KAAK+F,UAAWwE,EAAQoI,EAAO5M,UAAWyN,EAAUzN,UAAW0N,EAAU1N,UAAW6N,GACnI,OAAe,IAARnS,OAAYrC,EAAY0U,GAAgBvM,OAAO9F,EACzD,CAODsS,kBAAkBxJ,EAAQ4I,EAAiBS,GACvC,MAAMnS,EAAMzC,EAAKgV,iCAAiChU,KAAK+F,UAAWwE,EAAQ4I,EAAiBS,GAC3F,OAAe,IAARnS,OAAYrC,EAAY0U,GAAgBvM,OAAO9F,EACzD,CAODwS,eAAe1J,EAAQ3B,EAAOjC,GAC1BhF,EAAaiH,EAAOxB,IACpB,MAAM3F,EAAMzC,EAAKkV,8BAA8BlU,KAAK+F,UAAWwE,EAAQ3B,EAAM7C,UAAWY,GACxF,OAAOwN,GAAmB5M,OAAO9F,EACpC,CAQD2S,gBAAgB7J,EAAQ/D,EAASC,EAAQC,GACrC/E,EAAa6E,EAASY,IACtBzF,EAAa8E,EAAQW,IAErB,OAAe,IADHpI,EAAKqV,+BAA+BrU,KAAK+F,UAAWwE,EAAQ/D,EAAQT,UAAWU,EAAOV,UAAWW,EAEhH,CASD4N,UAAU/J,EAAQ/D,EAASC,EAAQC,EAAQC,GACvChF,EAAa6E,EAASY,IACtBzF,EAAa8E,EAAQW,IAErB,OADYpI,EAAKuV,yBAAyBvU,KAAK+F,UAAWwE,EAAQ/D,EAAQT,UAAWU,EAAOV,UAAWW,EAAQC,EAElH,CASD6N,sBAAsBjK,EAAQ/D,EAASC,EAAQC,EAAQC,GACnDhF,EAAa6E,EAASY,IACtBzF,EAAa8E,EAAQW,IACrB,MAAM3F,EAAMzC,EAAKyV,qCAAqCzU,KAAK+F,UAAWwE,EAAQ/D,EAAQT,UAAWU,EAAOV,UAAWW,EAAQC,GAC3H,OAAe,IAARlF,OAAYrC,EAAYsV,GAAmBnN,OAAO9F,EAC5D,CAKDkT,YAAYpK,EAAQqK,GAChB5V,EAAK6V,2BAA2B7U,KAAK+F,UAAWwE,EAAQqK,EAC3D,CAKDE,iBAAiBvK,EAAQwK,GACrB/V,EAAKgW,gCAAgChV,KAAK+F,UAAWwE,EAAQwK,EAChE,CAKDE,cAAc1K,EAAQ2K,GAClBlW,EAAKmW,6BAA6BnV,KAAK+F,UAAWwE,EAAQ2K,EAC7D,CAKDE,sBAAsB7K,GAElB,OADYvL,EAAKqW,qCAAqCrV,KAAK+F,UAAWwE,KACvD,CAClB,CAKD+K,yBAAyB/K,EAAQgL,GAC7BvW,EAAKwW,wCAAwCxV,KAAK+F,UAAWwE,EAAQgL,EACxE,CAKDE,yBAAyBlL,GAErB,OADYvL,EAAK0W,wCAAwC1V,KAAK+F,UAAWwE,KAC1D,CAClB,CAKDoL,4BAA4BpL,EAAQgL,GAChCvW,EAAK4W,2CAA2C5V,KAAK+F,UAAWwE,EAAQgL,EAC3E,CAKDM,qBAAqBtL,EAAQuL,GACzB9W,EAAK+W,oCAAoC/V,KAAK+F,UAAWwE,EAAQuL,EACpE,CAKDE,kBAAkBzL,EAAQuL,GACtB9W,EAAKiX,iCAAiCjW,KAAK+F,UAAWwE,EAAQuL,EACjE,CAKDI,iBAAiB3L,EAAQ4L,GACrBnX,EAAKoX,gCAAgCpW,KAAK+F,UAAWwE,EAAQ4L,EAChE,CAKDE,kBAAkB9L,EAAQ+L,GACtBtX,EAAKuX,iCAAiCvW,KAAK+F,UAAWwE,EAAQ+L,EACjE,CAKDE,0BAA0BjM,EAAQkM,GAC9BzX,EAAK0X,yCAAyC1W,KAAK+F,UAAWwE,EAAQkM,EACzE,CAKDE,WAAWpM,EAAQtC,GACftG,EAAasG,EAAOI,IACpBrJ,EAAK4X,0BAA0B5W,KAAK+F,UAAWwE,EAAQtC,EAAMlC,UAChE,CAKD8Q,gCAAgCtM,EAAQuM,GACpC9X,EAAK+X,+CAA+C/W,KAAK+F,UAAWwE,EAAQuM,EAC/E,CAKDE,aAAazM,EAAQ0M,GACjBjY,EAAKkY,4BAA4BlX,KAAK+F,UAAWwE,EAAQ0M,EAC5D,CAKDE,UAAU5M,EAAQ6M,GACdpY,EAAKqY,yBAAyBrX,KAAK+F,UAAWwE,EAAQ6M,EACzD,CAODE,oBAAoB/M,EAAQ6M,EAAMG,EAAcC,GAC5C7V,EAAa4V,EAAcnQ,IAC3BpI,EAAKyY,mCAAmCzX,KAAK+F,UAAWwE,EAAQ6M,EAAMG,EAAaxR,UAAWyR,EACjG,CACDtR,cACI,MAAMzE,EAAMzC,EAAK0Y,qBAGjB,OAFA1X,KAAK+F,UAAYtE,IAAQ,EACzB8J,EAA2B/F,SAASxF,KAAMA,KAAK+F,UAAW/F,MACnDA,IACV,CAIDY,MAEI,OADY5B,EAAK2Y,mBAAmB3X,KAAK+F,aAC1B,CAClB,CAKD6R,SAASrN,GAEL,OAAe,IADHvL,EAAK6Y,wBAAwB7X,KAAK+F,UAAWwE,EAE5D,CA4BDuN,eAAetH,EAASvI,EAAO8P,EAAaC,EAAUC,EAAeb,EAAMG,EAAcC,EAAyBP,EAAS/B,EAAUH,EAAamD,EAAqBC,EAAwBC,EAAUC,EAAiBC,EAAcC,EAAsBC,EAAaC,EAAcC,EAA4BC,EAAaC,EAAWC,EAAQvS,GACjV,IACI,MAAM4B,EAASlJ,EAAKmJ,iCAAiC,IACrDxG,EAAasG,EAAOI,IACpB1G,EAAaoW,EAAa3Q,IAC1BzF,EAAaqW,EAAU5P,IACvBzG,EAAa4V,EAAcnQ,IAC3BzF,EAAa2E,EAAQY,IACrBlI,EAAK8Z,8BAA8B5Q,EAAQlI,KAAK+F,UAAWyK,EAASvI,EAAMlC,UAAWgS,EAAYhS,UAAWiS,EAASjS,UAAWkS,EAAeb,EAAMG,EAAaxR,UAAWyR,EAAyBP,EAAS/B,EAAUH,EAAamD,EAAqBC,EAAwBC,EAAUC,EAAiBC,EAAcC,EAAsBC,EAAaC,EAAcC,EAA4BC,EAAaC,EAAWC,EAAQvS,EAAOP,WAChb,IAAIwC,EAAKlH,IAAqBmH,SAASN,EAAS,GAAO,GACnDO,EAAKpH,IAAqBqH,WAAWR,EAAS,GAAO,GACzD,OAAc,IAAPK,OAAWnJ,EAAYqJ,CAGjC,CAFS,QACNzJ,EAAKmJ,gCAAgC,GACxC,CACJ,CAQD4Q,OAAOxO,EAAQyO,EAAS1S,EAAQ2S,GAC5BtX,EAAaqX,EAASE,IACtBvX,EAAa2E,EAAQY,IACrBlI,EAAKma,sBAAsBnZ,KAAK+F,UAAWwE,EAAQyO,EAAQjT,UAAWO,EAAOP,UAAWkT,EAC3F,CAMDG,cAAc7O,GAEV,OAAe,IADHvL,EAAK6Y,wBAAwB7X,KAAK+F,UAAWwE,EAE5D,CAQD8O,sBAAsBxZ,GAClB,IACIb,EAAKsa,qCAAqCtZ,KAAK+F,UAAW/D,EAAkBnC,GAG/E,CAFS,QACNZ,EAAK8C,UAAmB3C,CAC3B,CACJ,EAGL,MAAMma,EAAuE,oBAAzBhU,qBAC9C,CAAEC,SAAU,OAAUC,WAAY,QAClC,IAAIF,sBAAqB5E,GAAO3B,EAAKwa,mCAAmC7Y,IAAQ,EAAG,KAElF,MAAM6I,EAET5D,cAAcjF,GACVA,KAAc,EACd,MAAMhB,EAAMsD,OAAO4C,OAAO2D,EAAwB1D,WAGlD,OAFAnG,EAAIoG,UAAYpF,EAChB4Y,EAAoC/T,SAAS7F,EAAKA,EAAIoG,UAAWpG,GAC1DA,CACV,CAEDqG,qBACI,MAAMrF,EAAMX,KAAK+F,UAGjB,OAFA/F,KAAK+F,UAAY,EACjBwT,EAAoC9T,WAAWzF,MACxCW,CACV,CAEDsF,OACI,MAAMtF,EAAMX,KAAKgG,qBACjBhH,EAAKwa,mCAAmC7Y,EAAK,EAChD,CAID8Y,iBAEI,OADYza,EAAK0a,uCAAuC1Z,KAAK+F,UAEhE,CAID4T,iBAEI,OADY3a,EAAK4a,uCAAuC5Z,KAAK+F,UAEhE,CAID8T,WACI,MAAMpY,EAAMzC,EAAK8a,iCAAiC9Z,KAAK+F,WACvD,OAAOqB,GAAUG,OAAO9F,EAC3B,CAIDsY,WACI,MAAMtY,EAAMzC,EAAKgb,iCAAiCha,KAAK+F,WACvD,OAAOqB,GAAUG,OAAO9F,EAC3B,CAIDwY,UACI,MAAMxY,EAAMzC,EAAKkb,gCAAgCla,KAAK+F,WACtD,OAAOqB,GAAUG,OAAO9F,EAC3B,CAID0Y,UACI,MAAM1Y,EAAMzC,EAAKob,gCAAgCpa,KAAK+F,WACtD,OAAOqB,GAAUG,OAAO9F,EAC3B,EAGL,MAAM4Y,EAAoE,oBAAzB9U,qBAC3C,CAAEC,SAAU,OAAUC,WAAY,QAClC,IAAIF,sBAAqB5E,GAAO3B,EAAKsb,gCAAgC3Z,IAAQ,EAAG,KAE/E,MAAM4Z,EAET3U,cAAcjF,GACVA,KAAc,EACd,MAAMhB,EAAMsD,OAAO4C,OAAO0U,EAAqBzU,WAG/C,OAFAnG,EAAIoG,UAAYpF,EAChB0Z,EAAiC7U,SAAS7F,EAAKA,EAAIoG,UAAWpG,GACvDA,CACV,CAEDqG,qBACI,MAAMrF,EAAMX,KAAK+F,UAGjB,OAFA/F,KAAK+F,UAAY,EACjBsU,EAAiC5U,WAAWzF,MACrCW,CACV,CAEDsF,OACI,MAAMtF,EAAMX,KAAKgG,qBACjBhH,EAAKsb,gCAAgC3Z,EAAK,EAC7C,CAKD6Z,YAEI,OADYxb,EAAK0a,uCAAuC1Z,KAAK+F,UAEhE,CAKD0U,YAEI,OADYzb,EAAK0b,+BAA+B1a,KAAK+F,UAExD,CAKD4U,cACI,MAAMlZ,EAAMzC,EAAK4b,iCAAiC5a,KAAK+F,WACvD,OAAOqB,GAAUG,OAAO9F,EAC3B,CASDoZ,wBAEI,OADY7b,EAAK8b,2CAA2C9a,KAAK+F,UAEpE,CAKDgV,sBACI,MAAMtZ,EAAMzC,EAAK0L,8CAA8C1K,KAAK+F,WACpE,OAAOqB,GAAUG,OAAO9F,EAC3B,CAKDuZ,sBAEI,OADYhc,EAAKic,yCAAyCjb,KAAK+F,UAElE,EAGL,MAAMmV,EAAkE,oBAAzB3V,qBACzC,CAAEC,SAAU,OAAUC,WAAY,QAClC,IAAIF,sBAAqB5E,GAAO3B,EAAKmc,8BAA8Bxa,IAAQ,EAAG,KAE7E,MAAMya,EAETxV,cAAcjF,GACVA,KAAc,EACd,MAAMhB,EAAMsD,OAAO4C,OAAOuV,EAAmBtV,WAG7C,OAFAnG,EAAIoG,UAAYpF,EAChBua,EAA+B1V,SAAS7F,EAAKA,EAAIoG,UAAWpG,GACrDA,CACV,CAEDqG,qBACI,MAAMrF,EAAMX,KAAK+F,UAGjB,OAFA/F,KAAK+F,UAAY,EACjBmV,EAA+BzV,WAAWzF,MACnCW,CACV,CAEDsF,OACI,MAAMtF,EAAMX,KAAKgG,qBACjBhH,EAAKmc,8BAA8Bxa,EAAK,EAC3C,CAID0a,SACI,MAAM5Z,EAAMzC,EAAKsc,0BAA0Btb,KAAK+F,WAChD,OAAOqB,GAAUG,OAAO9F,EAC3B,CAID8Z,WACI,MAAM9Z,EAAMzC,EAAKwc,4BAA4Bxb,KAAK+F,WAClD,OAAOqB,GAAUG,OAAO9F,EAC3B,CAIDga,WACI,MAAMha,EAAMzC,EAAK0c,4BAA4B1b,KAAK+F,WAClD,OAAOqB,GAAUG,OAAO9F,EAC3B,CAIDka,YAEI,OADY3c,EAAK4c,6BAA6B5b,KAAK+F,aACpC,CAClB,CAID8V,YAEI,OADY7c,EAAK8c,6BAA6B9b,KAAK+F,aACpC,CAClB,CAIDgW,eAEI,OADY/c,EAAKgd,gCAAgChc,KAAK+F,aACvC,CAClB,CAKDkW,iBAAiBC,GACb,MAAMza,EAAMzC,EAAKmd,oCAAoCnc,KAAK+F,UAAWmW,GACrE,OAAe,IAARza,OAAYrC,EAAYgI,GAAUG,OAAO9F,EACnD,CAKD2a,iBAAiBF,GACb,MAAMza,EAAMzC,EAAKqd,oCAAoCrc,KAAK+F,UAAWmW,GACrE,OAAe,IAARza,OAAYrC,EAAYgI,GAAUG,OAAO9F,EACnD,CAKD6a,aAAaJ,GAET,OADYld,EAAKud,gCAAgCvc,KAAK+F,UAAWmW,EAEpE,CAKDM,aAAaN,GAET,OADYld,EAAKyd,gCAAgCzc,KAAK+F,UAAWmW,KAClD,CAClB,CAKDQ,aAAaR,GAET,OADYld,EAAK2d,gCAAgC3c,KAAK+F,UAAWmW,KAClD,CAClB,CAKDU,gBAAgBV,GAEZ,OADYld,EAAK6d,mCAAmC7c,KAAK+F,UAAWmW,EAEvE,CAKDY,wBAAwBZ,GAEpB,OADYld,EAAK+d,2CAA2C/c,KAAK+F,UAAWmW,EAE/E,CAIDc,sBAEI,OADYhe,EAAKie,uCAAuCjd,KAAK+F,aAC9C,CAClB,CAKDmX,qBAAqBhB,GACjB,MAAMza,EAAMzC,EAAKme,wCAAwCnd,KAAK+F,UAAWmW,GACzE,OAAe,IAARza,OAAYrC,EAAYgI,GAAUG,OAAO9F,EACnD,CAKD2b,oBAAoBlB,GAEhB,OADYld,EAAKqe,uCAAuCrd,KAAK+F,UAAWmW,EAE3E,CAKDoB,wBAAwBpB,GAEpB,OADYld,EAAKue,2CAA2Cvd,KAAK+F,UAAWmW,EAE/E,CAKDsB,2BAA2BtB,GAEvB,OADYld,EAAKye,8CAA8Czd,KAAK+F,UAAWmW,EAElF,CAKDwB,gCAAgCxB,GAC5B,MAAMza,EAAMzC,EAAK2e,mDAAmD3d,KAAK+F,UAAWmW,GACpF,OAAO9U,GAAUG,OAAO9F,EAC3B,EAGL,MAAMmc,EAA8D,oBAAzBrY,qBACrC,CAAEC,SAAU,OAAUC,WAAY,QAClC,IAAIF,sBAAqB5E,GAAO3B,EAAK6e,0BAA0Bld,IAAQ,EAAG,KAEzE,MAAMmd,EAETlY,cAAcjF,GACVA,KAAc,EACd,MAAMhB,EAAMsD,OAAO4C,OAAOiY,EAAehY,WAGzC,OAFAnG,EAAIoG,UAAYpF,EAChBid,EAA2BpY,SAAS7F,EAAKA,EAAIoG,UAAWpG,GACjDA,CACV,CAEDqG,qBACI,MAAMrF,EAAMX,KAAK+F,UAGjB,OAFA/F,KAAK+F,UAAY,EACjB6X,EAA2BnY,WAAWzF,MAC/BW,CACV,CAEDsF,OACI,MAAMtF,EAAMX,KAAKgG,qBACjBhH,EAAK6e,0BAA0Bld,EAAK,EACvC,CAID6Z,YAEI,OADYxb,EAAK+e,yBAAyB/d,KAAK+F,UAElD,CAID0U,YAEI,OADYzb,EAAKgf,yBAAyBhe,KAAK+F,UAElD,CAIDkY,sBAEI,OADYjf,EAAKkf,mCAAmCle,KAAK+F,aAC1C,CAClB,CAKDoY,gBAAgBjC,GACZ,MAAMza,EAAMzC,EAAKof,+BAA+Bpe,KAAK+F,UAAWmW,GAChE,OAAe,IAARza,OAAYrC,EAAYgc,EAAmB7T,OAAO9F,EAC5D,EAGL,MAAM4c,EAAsE,oBAAzB9Y,qBAC7C,CAAEC,SAAU,OAAUC,WAAY,QAClC,IAAIF,sBAAqB5E,GAAO3B,EAAKsf,kCAAkC3d,IAAQ,EAAG,KAEjF,MAAM4d,EAETvY,qBACI,MAAMrF,EAAMX,KAAK+F,UAGjB,OAFA/F,KAAK+F,UAAY,EACjBsY,EAAmC5Y,WAAWzF,MACvCW,CACV,CAEDsF,OACI,MAAMtF,EAAMX,KAAKgG,qBACjBhH,EAAKsf,kCAAkC3d,EAAK,EAC/C,CACDuF,cACI,MAAMzE,EAAMzC,EAAKwf,6BAGjB,OAFAxe,KAAK+F,UAAYtE,IAAQ,EACzB4c,EAAmC7Y,SAASxF,KAAMA,KAAK+F,UAAW/F,MAC3DA,IACV,CAIDye,WAEI,OAAOjd,EADKxC,EAAK0f,gCAAgC1e,KAAK+F,WAEzD,CAID4Y,SAEI,OAAOnd,EADKxC,EAAK4f,8BAA8B5e,KAAK+F,WAEvD,CAUD8Y,OAAOvY,EAAQC,EAAWuY,EAAgBC,EAAkB1Y,EAAcO,EAAcI,GACpF,IACIrF,EAAa2E,EAAQY,IACrBvF,EAAa4E,EAAWY,GACxBxF,EAAamd,EAAgBE,IAC7Brd,EAAaod,EAAkBE,IAC/Btd,EAAa0E,EAAcY,IAC3BjI,EAAKkgB,8BAA8Blf,KAAK+F,UAAWO,EAAOP,UAAWQ,EAAUR,UAAW+Y,EAAe/Y,UAAWgZ,EAAiBhZ,UAAWM,EAAaN,UAAWa,EAAc5E,EAAkBgF,GAG3M,CAFS,QACN/H,EAAK8C,UAAmB3C,CAC3B,CACJ,EAGL,MAAM+f,EAAoE,oBAAzB5Z,qBAC3C,CAAEC,SAAU,OAAUC,WAAY,QAClC,IAAIF,sBAAqB5E,GAAO3B,EAAKogB,gCAAgCze,IAAQ,EAAG,KAE/E,MAAM0e,EAETzZ,cAAcjF,GACVA,KAAc,EACd,MAAMhB,EAAMsD,OAAO4C,OAAOwZ,EAAqBvZ,WAG/C,OAFAnG,EAAIoG,UAAYpF,EAChBwe,EAAiC3Z,SAAS7F,EAAKA,EAAIoG,UAAWpG,GACvDA,CACV,CAEDqG,qBACI,MAAMrF,EAAMX,KAAK+F,UAGjB,OAFA/F,KAAK+F,UAAY,EACjBoZ,EAAiC1Z,WAAWzF,MACrCW,CACV,CAEDsF,OACI,MAAMtF,EAAMX,KAAKgG,qBACjBhH,EAAKogB,gCAAgCze,EAAK,EAC7C,CAID2e,cACI,MAAM7d,EAAMzC,EAAKugB,iCAAiCvf,KAAK+F,WACvD,OAAe,IAARtE,OAAYrC,EAAYgI,GAAUG,OAAO9F,EACnD,CAID+d,4BACI,MAAM/d,EAAMzC,EAAKygB,+CAA+Czf,KAAK+F,WACrE,OAAe,IAARtE,OAAYrC,EAAYsgB,GAAyBnY,OAAO9F,EAClE,CAIDke,oBACI,MAAMle,EAAMzC,EAAK4gB,uCAAuC5f,KAAK+F,WAC7D,OAAe,IAARtE,OAAYrC,EAAY8Z,GAAiB3R,OAAO9F,EAC1D,CAIDoe,iBACI,MAAMpe,EAAMzC,EAAK8gB,oCAAoC9f,KAAK+F,WAC1D,OAAe,IAARtE,OAAYrC,EAAYuG,EAAc4B,OAAO9F,EACvD,CAIDse,kBACI,MAAMte,EAAMzC,EAAKghB,qCAAqChgB,KAAK+F,WAC3D,OAAe,IAARtE,OAAYrC,EAAY6H,GAAeM,OAAO9F,EACxD,CAIDwe,aACI,MAAMxe,EAAMzC,EAAKkhB,gCAAgClgB,KAAK+F,WACtD,OAAe,IAARtE,OAAYrC,EAAY8H,GAAgBK,OAAO9F,EACzD,CAID0e,gBACI,MAAM1e,EAAMzC,EAAKohB,mCAAmCpgB,KAAK+F,WACzD,OAAe,IAARtE,OAAYrC,EAAY+H,EAAeI,OAAO9F,EACxD,CAID4e,oBACI,MAAM5e,EAAMzC,EAAKshB,uCAAuCtgB,KAAK+F,WAC7D,OAAe,IAARtE,OAAYrC,EAAY4f,GAAmBzX,OAAO9F,EAC5D,CAID8e,sBACI,MAAM9e,EAAMzC,EAAKwhB,yCAAyCxgB,KAAK+F,WAC/D,OAAe,IAARtE,OAAYrC,EAAY6f,GAAqB1X,OAAO9F,EAC9D,EAGL,MAAMgf,EAA6D,oBAAzBlb,qBACpC,CAAEC,SAAU,OAAUC,WAAY,QAClC,IAAIF,sBAAqB5E,GAAO3B,EAAK0hB,yBAAyB/f,IAAQ,EAAG,KAKxE,MAAMggB,EAET3a,qBACI,MAAMrF,EAAMX,KAAK+F,UAGjB,OAFA/F,KAAK+F,UAAY,EACjB0a,EAA0Bhb,WAAWzF,MAC9BW,CACV,CAEDsF,OACI,MAAMtF,EAAMX,KAAKgG,qBACjBhH,EAAK0hB,yBAAyB/f,EAAK,EACtC,CAWDuF,YAAY0a,GACR,MAAMnf,EAAMzC,EAAK6hB,kBAAkBD,GAGnC,OAFA5gB,KAAK+F,UAAYtE,IAAQ,EACzBgf,EAA0Bjb,SAASxF,KAAMA,KAAK+F,UAAW/F,MAClDA,IACV,CAYD8gB,qBAAqBjhB,GACjB,IACIb,EAAK+hB,mCAAmC/gB,KAAK+F,UAAW/D,EAAkBnC,GAG7E,CAFS,QACNZ,EAAK8C,UAAmB3C,CAC3B,CACJ,CAID4hB,wBAAwBnhB,GACpB,IACIb,EAAKiiB,sCAAsCjhB,KAAK+F,UAAW/D,EAAkBnC,GAGhF,CAFS,QACNZ,EAAK8C,UAAmB3C,CAC3B,CACJ,CAID8hB,QACIliB,EAAKmiB,oBAAoBnhB,KAAK+F,UACjC,EAGL,MAAMqb,EAA+D,oBAAzB7b,qBACtC,CAAEC,SAAU,OAAUC,WAAY,QAClC,IAAIF,sBAAqB5E,GAAO3B,EAAKqiB,2BAA2B1gB,IAAQ,EAAG,KAE1E,MAAM2gB,EAET1b,cAAcjF,GACVA,KAAc,EACd,MAAMhB,EAAMsD,OAAO4C,OAAOyb,EAAgBxb,WAG1C,OAFAnG,EAAIoG,UAAYpF,EAChBygB,EAA4B5b,SAAS7F,EAAKA,EAAIoG,UAAWpG,GAClDA,CACV,CAEDqG,qBACI,MAAMrF,EAAMX,KAAK+F,UAGjB,OAFA/F,KAAK+F,UAAY,EACjBqb,EAA4B3b,WAAWzF,MAChCW,CACV,CAEDsF,OACI,MAAMtF,EAAMX,KAAKgG,qBACjBhH,EAAKqiB,2BAA2B1gB,EAAK,EACxC,CASDiF,cAAc2b,EAAaC,EAAWC,EAASC,EAASC,GACpDhgB,EAAa+f,EAASta,IACtBzF,EAAaggB,EAASva,IACtB,MAAM3F,EAAMzC,EAAK4iB,uBAAuBL,EAAaC,EAAWC,EAASC,EAAQ3b,UAAW4b,EAAQ5b,WACpG,OAAOub,EAAgB/Z,OAAO9F,EACjC,CAODmE,YAAYnG,EAAQiiB,EAASC,GACzBhgB,EAAa+f,EAASta,IACtBzF,EAAaggB,EAASva,IACtB,MAAM3F,EAAMzC,EAAK6iB,qBAAqBpiB,EAAQiiB,EAAQ3b,UAAW4b,EAAQ5b,WACzE,OAAOub,EAAgB/Z,OAAO9F,EACjC,CAgBDmE,iBAAiB8b,EAASC,EAASG,EAAMC,EAAeC,EAAWC,GAC/DtgB,EAAa+f,EAASta,IACtBzF,EAAaggB,EAASva,IACtBzF,EAAamgB,EAAM1a,IACnB,MAAM3F,EAAMzC,EAAKkjB,0BAA0BR,EAAQ3b,UAAW4b,EAAQ5b,UAAW+b,EAAK/b,UAAWgc,EAAeC,EAAWC,GAC3H,OAAe,IAARxgB,OAAYrC,EAAYkiB,EAAgB/Z,OAAO9F,EACzD,CAWDmE,aAAa8b,EAASS,EAAOR,EAASS,GAClCzgB,EAAa+f,EAASta,IACtBzF,EAAawgB,EAAO/Z,IACpBzG,EAAaggB,EAASva,IACtBzF,EAAaygB,EAAOha,IACpB,MAAM3G,EAAMzC,EAAKqjB,sBAAsBX,EAAQ3b,UAAWoc,EAAMpc,UAAW4b,EAAQ5b,UAAWqc,EAAMrc,WACpG,OAAOub,EAAgB/Z,OAAO9F,EACjC,CAUDmE,gBAAgB8b,EAASC,GACrBhgB,EAAa+f,EAASta,IACtBzF,EAAaggB,EAASva,IACtB,MAAM3F,EAAMzC,EAAKsjB,yBAAyBZ,EAAQ3b,UAAW4b,EAAQ5b,WACrE,OAAe,IAARtE,OAAYrC,EAAYkiB,EAAgB/Z,OAAO9F,EACzD,EAGL,MAAM8gB,EAAkE,oBAAzBhd,qBACzC,CAAEC,SAAU,OAAUC,WAAY,QAClC,IAAIF,sBAAqB5E,GAAO3B,EAAKwjB,8BAA8B7hB,IAAQ,EAAG,KAE7E,MAAMqe,GAETpZ,cAAcjF,GACVA,KAAc,EACd,MAAMhB,EAAMsD,OAAO4C,OAAOmZ,GAAmBlZ,WAG7C,OAFAnG,EAAIoG,UAAYpF,EAChB4hB,EAA+B/c,SAAS7F,EAAKA,EAAIoG,UAAWpG,GACrDA,CACV,CAEDqG,qBACI,MAAMrF,EAAMX,KAAK+F,UAGjB,OAFA/F,KAAK+F,UAAY,EACjBwc,EAA+B9c,WAAWzF,MACnCW,CACV,CAEDsF,OACI,MAAMtF,EAAMX,KAAKgG,qBACjBhH,EAAKwjB,8BAA8B7hB,EAAK,EAC3C,CAMD8hB,UAAUlY,GAEN,OADYvL,EAAK0jB,6BAA6B1iB,KAAK+F,UAAWwE,EAEjE,CAMDoY,iBAAiBpY,GAEb,OADYvL,EAAK4jB,oCAAoC5iB,KAAK+F,UAAWwE,EAExE,CAMDsY,iBAAiBtY,GAEb,OADYvL,EAAK8jB,oCAAoC9iB,KAAK+F,UAAWwE,EAExE,CAMDwY,aAAaxY,GACT,MAAM9I,EAAMzC,EAAKgkB,gCAAgChjB,KAAK+F,UAAWwE,GACjE,OAAOnC,GAAYb,OAAO9F,EAC7B,CAMDwhB,aAAa1Y,GACT,MAAM9I,EAAMzC,EAAKkkB,gCAAgCljB,KAAK+F,UAAWwE,GACjE,OAAOnC,GAAYb,OAAO9F,EAC7B,CASD0hB,aAAa5Y,GACT,MAAM9I,EAAMzC,EAAKokB,gCAAgCpjB,KAAK+F,UAAWwE,GACjE,OAAOnD,GAAUG,OAAO9F,EAC3B,CASD4hB,aAAa9Y,GACT,MAAM9I,EAAMzC,EAAKskB,gCAAgCtjB,KAAK+F,UAAWwE,GACjE,OAAOnD,GAAUG,OAAO9F,EAC3B,CAMD8hB,gBAAgBhZ,EAAQiZ,GACpB7hB,EAAa6hB,EAAQpc,IACrBpI,EAAKykB,mCAAmCzjB,KAAK+F,UAAWwE,EAAQiZ,EAAOzd,UAC1E,CAMD2d,gBAAgBnZ,EAAQiZ,GACpB7hB,EAAa6hB,EAAQpc,IACrBpI,EAAK2kB,mCAAmC3jB,KAAK+F,UAAWwE,EAAQiZ,EAAOzd,UAC1E,CAMD6d,qBAAqBrZ,GAEjB,OAAe,IADHvL,EAAK6kB,wCAAwC7jB,KAAK+F,UAAWwE,EAE5E,CAMDuZ,wBAAwBvZ,EAAQiG,GAC5BxR,EAAK+kB,2CAA2C/jB,KAAK+F,UAAWwE,EAAQiG,EAC3E,CAODwT,mBAAmBzZ,EAAQuX,GAEvB,OAAe,IADH9iB,EAAKilB,sCAAsCjkB,KAAK+F,UAAWwE,EAAQuX,EAElF,CAODoC,eAAe3Z,EAAQuX,GAEnB,OADY9iB,EAAKmlB,kCAAkCnkB,KAAK+F,UAAWwE,EAAQuX,EAE9E,CAODsC,eAAe7Z,EAAQuX,GAEnB,OADY9iB,EAAKqlB,kCAAkCrkB,KAAK+F,UAAWwE,EAAQuX,EAE9E,CAQDwC,eAAe/Z,EAAQuX,EAAMyC,EAAKC,GAC9BxlB,EAAKylB,kCAAkCzkB,KAAK+F,UAAWwE,EAAQuX,EAAMyC,EAAKC,EAC7E,CAMDE,yBAAyBna,EAAQuX,EAAM6C,GACnC3lB,EAAK4lB,4CAA4C5kB,KAAK+F,UAAWwE,EAAQuX,EAAM6C,EAClF,CAODE,4BAA4Bta,EAAQuX,EAAMgD,EAAWC,GACjD/lB,EAAKgmB,+CAA+ChlB,KAAK+F,UAAWwE,EAAQuX,EAAMgD,EAAWC,EAChG,CAQDE,4BAA4B1a,EAAQuX,EAAMoD,EAAW1D,EAAWC,GAC5DziB,EAAKmmB,+CAA+CnlB,KAAK+F,UAAWwE,EAAQuX,EAAMoD,EAAW1D,EAAWC,EAC3G,CASD2D,oBAAoB7a,EAAQuX,EAAMoD,EAAWJ,EAAWtD,EAAWC,GAC/DziB,EAAKqmB,uCAAuCrlB,KAAK+F,UAAWwE,EAAQuX,EAAMoD,EAAWJ,EAAWtD,EAAWC,EAC9G,CACDvb,cACI,MAAMzE,EAAMzC,EAAKsmB,yBAGjB,OAFAtlB,KAAK+F,UAAYtE,IAAQ,EACzB8gB,EAA+B/c,SAASxF,KAAMA,KAAK+F,UAAW/F,MACvDA,IACV,CAQDulB,YAAYC,EAAQC,EAASC,EAASC,GAClChkB,EAAa6jB,EAAQlE,GAErB,OADYtiB,EAAK4mB,+BAA+B5lB,KAAK+F,UAAWyf,EAAOzf,UAAW0f,EAASC,EAASC,EAEvG,CAKD5M,OAAOxO,EAAQ0O,GACXja,EAAK6mB,0BAA0B7lB,KAAK+F,UAAWwE,EAAQ0O,EAC1D,CAIDrY,MAEI,OADY5B,EAAK8mB,uBAAuB9lB,KAAK+F,aAC9B,CAClB,CAKD6R,SAASrN,GAEL,OAAe,IADHvL,EAAK+mB,4BAA4B/lB,KAAK+F,UAAWwE,EAEhE,CAQDyb,mBAAmBnmB,GACf,IACIb,EAAKinB,sCAAsCjmB,KAAK+F,UAAW/D,EAAkBnC,GAGhF,CAFS,QACNZ,EAAK8C,UAAmB3C,CAC3B,CACJ,CASD8mB,gCAAgCC,EAAMtmB,GAClC,IACIb,EAAKonB,mDAAmDpmB,KAAK+F,UAAWogB,EAAMnkB,EAAkBnC,GAGnG,CAFS,QACNZ,EAAK8C,UAAmB3C,CAC3B,CACJ,EAGL,MAAMinB,GAAwE,oBAAzB9gB,qBAC/C,CAAEC,SAAU,OAAUC,WAAY,QAClC,IAAIF,sBAAqB5E,GAAO3B,EAAKsnB,oCAAoC3lB,IAAQ,EAAG,KAEnF,MAAM+e,GAET9Z,cAAcjF,GACVA,KAAc,EACd,MAAMhB,EAAMsD,OAAO4C,OAAO6Z,GAAyB5Z,WAGnD,OAFAnG,EAAIoG,UAAYpF,EAChB0lB,GAAqC7gB,SAAS7F,EAAKA,EAAIoG,UAAWpG,GAC3DA,CACV,CAEDqG,qBACI,MAAMrF,EAAMX,KAAK+F,UAGjB,OAFA/F,KAAK+F,UAAY,EACjBsgB,GAAqC5gB,WAAWzF,MACzCW,CACV,CAEDsF,OACI,MAAMtF,EAAMX,KAAKgG,qBACjBhH,EAAKsnB,oCAAoC3lB,EAAK,EACjD,CACDuF,cACI,MAAMzE,EAAMzC,EAAKunB,+BAGjB,OAFAvmB,KAAK+F,UAAYtE,IAAQ,EACzB4kB,GAAqC7gB,SAASxF,KAAMA,KAAK+F,UAAW/F,MAC7DA,IACV,CAIGwmB,SAEA,OADYxnB,EAAKynB,4BAA4BzmB,KAAK+F,UAErD,CAIG2gB,kBAEA,OADY1nB,EAAK2nB,qCAAqC3mB,KAAK+F,UAE9D,CAIG6gB,mCAEA,OADY5nB,EAAKic,yCAAyCjb,KAAK+F,UAElE,CAIG8gB,mCAEA,OADY7nB,EAAK8nB,sDAAsD9mB,KAAK+F,UAE/E,CAIGghB,0BAEA,OADY/nB,EAAKgoB,6CAA6ChnB,KAAK+F,aACpD,CAClB,CAIGkhB,sCAEA,OADYjoB,EAAKkoB,yDAAyDlnB,KAAK+F,aAChE,CAClB,CAIGohB,+BAEA,OADYnoB,EAAKooB,kDAAkDpnB,KAAK+F,aACzD,CAClB,CAIGshB,oBAEA,OADYroB,EAAKsoB,uCAAuCtnB,KAAK+F,aAC9C,CAClB,CAIGwhB,qBAEA,OADYvoB,EAAKwoB,wCAAwCxnB,KAAK+F,aAC/C,CAClB,CAIG0hB,iBAEA,OADYzoB,EAAK8b,2CAA2C9a,KAAK+F,UAEpE,CAIGygB,OAAGkB,GACH1oB,EAAK2oB,gCAAgC3nB,KAAK+F,UAAW2hB,EACxD,CAIGE,8BAA0BF,GAC1B1oB,EAAK6oB,uDAAuD7nB,KAAK+F,UAAW2hB,EAC/E,CAIGd,iCAA6Bc,GAC7B1oB,EAAK8oB,0DAA0D9nB,KAAK+F,UAAW2hB,EAClF,CAIGb,iCAA6Ba,GAC7B1oB,EAAK+oB,0DAA0D/nB,KAAK+F,UAAW2hB,EAClF,CAIGX,wBAAoBW,GACpB1oB,EAAKgpB,iDAAiDhoB,KAAK+F,UAAW2hB,EACzE,CAIGT,oCAAgCS,GAChC1oB,EAAKipB,6DAA6DjoB,KAAK+F,UAAW2hB,EACrF,CAIGP,6BAAyBO,GACzB1oB,EAAKkpB,sDAAsDloB,KAAK+F,UAAW2hB,EAC9E,CAIGL,kBAAcK,GACd1oB,EAAKmpB,2CAA2CnoB,KAAK+F,UAAW2hB,EACnE,CAIGH,mBAAeG,GACf1oB,EAAKopB,4CAA4CpoB,KAAK+F,UAAW2hB,EACpE,CAIGD,eAAWC,GACX1oB,EAAKqpB,wCAAwCroB,KAAK+F,UAAW2hB,EAChE,CACDY,4BACItpB,EAAKupB,mDAAmDvoB,KAAK+F,UAChE,CACDyiB,8BACIxpB,EAAKypB,qDAAqDzoB,KAAK+F,UAClE,CACD2iB,8CACI1pB,EAAK2pB,qEAAqE3oB,KAAK+F,UAClF,EAGL,MAAM6iB,GAAgE,oBAAzBrjB,qBACvC,CAAEC,SAAU,OAAUC,WAAY,QAClC,IAAIF,sBAAqB5E,GAAO3B,EAAK6pB,4BAA4BloB,IAAQ,EAAG,KAE3E,MAAMuY,GAETtT,cAAcjF,GACVA,KAAc,EACd,MAAMhB,EAAMsD,OAAO4C,OAAOqT,GAAiBpT,WAG3C,OAFAnG,EAAIoG,UAAYpF,EAChBioB,GAA6BpjB,SAAS7F,EAAKA,EAAIoG,UAAWpG,GACnDA,CACV,CAEDqG,qBACI,MAAMrF,EAAMX,KAAK+F,UAGjB,OAFA/F,KAAK+F,UAAY,EACjB6iB,GAA6BnjB,WAAWzF,MACjCW,CACV,CAEDsF,OACI,MAAMtF,EAAMX,KAAKgG,qBACjBhH,EAAK6pB,4BAA4BloB,EAAK,EACzC,CACDuF,cACI,MAAMzE,EAAMzC,EAAK8pB,uBAGjB,OAFA9oB,KAAK+F,UAAYtE,IAAQ,EACzBmnB,GAA6BpjB,SAASxF,KAAMA,KAAK+F,UAAW/F,MACrDA,IACV,CAcD+oB,6BAA6BlpB,GACzB,IACIb,EAAKgqB,8CAA8ChpB,KAAK+F,UAAW/D,EAAkBnC,GAGxF,CAFS,QACNZ,EAAK8C,UAAmB3C,CAC3B,CACJ,EAGL,MAAM6pB,GAA+E,oBAAzB1jB,qBACtD,CAAEC,SAAU,OAAUC,WAAY,QAClC,IAAIF,sBAAqB5E,GAAO3B,EAAKkqB,2CAA2CvoB,IAAQ,EAAG,KAE1F,MAAMwoB,GAETnjB,qBACI,MAAMrF,EAAMX,KAAK+F,UAGjB,OAFA/F,KAAK+F,UAAY,EACjBkjB,GAA4CxjB,WAAWzF,MAChDW,CACV,CAEDsF,OACI,MAAMtF,EAAMX,KAAKgG,qBACjBhH,EAAKkqB,2CAA2CvoB,EAAK,EACxD,CAIDuF,YAAYkjB,GACR,MAAM3nB,EAAMzC,EAAKqqB,oCAAoCD,GAGrD,OAFAppB,KAAK+F,UAAYtE,IAAQ,EACzBwnB,GAA4CzjB,SAASxF,KAAMA,KAAK+F,UAAW/F,MACpEA,IACV,CAIDspB,KACI,MAAM7nB,EAAMzC,EAAKob,gCAAgCpa,KAAK+F,WACtD,OAAOqB,GAAUG,OAAO9F,EAC3B,CAID8nB,MAAMC,GACF7nB,EAAa6nB,EAAQpiB,IACrBpI,EAAKyqB,sCAAsCzpB,KAAK+F,UAAWyjB,EAAOzjB,UACrE,CAID2jB,oBAEI,OADY1qB,EAAK2qB,kDAAkD3pB,KAAK+F,UAE3E,CAID6jB,qBAAqBlC,GACjB1oB,EAAK6qB,qDAAqD7pB,KAAK+F,UAAW2hB,EAC7E,CAID0B,SAEI,OADYpqB,EAAKynB,4BAA4BzmB,KAAK+F,UAErD,CAID+jB,UAAUpC,GACN1oB,EAAK+qB,0CAA0C/pB,KAAK+F,UAAW2hB,EAClE,CAIDsC,eAEI,OAAe,IADHhrB,EAAKirB,6CAA6CjqB,KAAK+F,UAEtE,CAIDmkB,gBAAgB1Z,GACZxR,EAAKmrB,gDAAgDnqB,KAAK+F,UAAWyK,EACxE,CAID4Z,oBACI,MAAM3oB,EAAMzC,EAAKqrB,kDAAkDrqB,KAAK+F,WACxE,OAAe,aAARtE,OAAsBrC,EAAYqC,CAC5C,CAID6oB,mBACI,MAAM7oB,EAAMzC,EAAKurB,iDAAiDvqB,KAAK+F,WACvE,OAAe,aAARtE,OAAsBrC,EAAYqC,CAC5C,CAID+oB,gCACI,MAAM/oB,EAAMzC,EAAKyrB,8DAA8DzqB,KAAK+F,WACpF,OAAe,WAARtE,OAAmBrC,EAAoB,IAARqC,CACzC,CAIDipB,kBAEI,OAAe,IADH1rB,EAAK2rB,gDAAgD3qB,KAAK+F,UAEzE,CAMD6kB,eAAeC,EAAWC,EAAUC,GAChC/rB,EAAKgsB,+CAA+ChrB,KAAK+F,UAAW8kB,EAAWC,EAAUC,EAC5F,CACDE,kBACIjsB,EAAKksB,gDAAgDlrB,KAAK+F,UAC7D,CAIDolB,qBAEI,OADYnsB,EAAK8nB,sDAAsD9mB,KAAK+F,UAE/E,CAIDqlB,sBAAsB7e,GAClBvN,EAAK+oB,0DAA0D/nB,KAAK+F,UAAWwG,EAClF,CAID8e,qBAEI,OADYrsB,EAAKssB,mDAAmDtrB,KAAK+F,UAE5E,CAIDwlB,sBAAsBhf,GAClBvN,EAAKwsB,sDAAsDxrB,KAAK+F,UAAWwG,EAC9E,CAIDkf,uBACI,MAAMhqB,EAAMzC,EAAK0sB,qDAAqD1rB,KAAK+F,WAC3E,OAAe,aAARtE,OAAsBrC,EAAYqC,CAC5C,CAIDkqB,mBAAmBC,GACf5sB,EAAK6sB,mDAAmD7rB,KAAK+F,UAAW6lB,EAC3E,CACDE,sBACI9sB,EAAK+sB,oDAAoD/rB,KAAK+F,UACjE,CAIDimB,sBAEI,OAAe,IADHhtB,EAAKitB,oDAAoDjsB,KAAK+F,UAE7E,CAeDmmB,wBAAwB1F,EAAI2F,EAAa9lB,EAAcC,EAAQC,EAAW6lB,EAAiBC,EAA2BC,EAAkCC,EAAgB3lB,EAAcC,EAAeG,GACjM,IACIrF,EAAawqB,EAAaxmB,GAC1BhE,EAAa0E,EAAcY,IAC3BtF,EAAa2E,EAAQY,IACrBvF,EAAa4E,EAAWY,GACxBxF,EAAa0qB,EAA2BjlB,IACxCpI,EAAKwtB,wDAAwDxsB,KAAK+F,UAAWygB,EAAI2F,EAAYpmB,UAAWM,EAAaN,UAAWO,EAAOP,UAAWQ,EAAUR,UAAWqmB,EAAiBC,EAA0BtmB,UAAWumB,EAAkCprB,EAAWqrB,GAAkB,WAAcE,KAAKC,OAAOH,GAAiB3lB,EAAc1F,EAAW2F,GAAiB,WAAc,IAAoB,EAAG7E,EAAkBgF,GAG3a,CAFS,QACN/H,EAAK8C,UAAmB3C,CAC3B,CACJ,CAIDutB,mBACI,MAAMlrB,EAAMzC,EAAK4tB,iDAAiD5sB,KAAK+F,WACvE,OAAOqB,GAAUG,OAAO9F,EAC3B,CAIDorB,mBAEI,OAAe,IADH7tB,EAAK8tB,iDAAiD9sB,KAAK+F,UAE1E,CAIDgnB,wBAEI,OADY/tB,EAAKguB,sDAAsDhtB,KAAK+F,aAC7D,CAClB,CAMDknB,kBAAkB/Q,EAAGgR,GACjBvrB,EAAaurB,EAAW7iB,GAExB,OAAe,IADHrL,EAAKmuB,kDAAkDntB,KAAK+F,UAAWmW,EAAGgR,EAAUnnB,UAEnG,EAGL,MAAMqnB,GAAoE,oBAAzB7nB,qBAC3C,CAAEC,SAAU,OAAUC,WAAY,QAClC,IAAIF,sBAAqB5E,GAAO3B,EAAKquB,gCAAgC1sB,IAAQ,EAAG,KAE/E,MAAMse,GAETrZ,cAAcjF,GACVA,KAAc,EACd,MAAMhB,EAAMsD,OAAO4C,OAAOoZ,GAAqBnZ,WAG/C,OAFAnG,EAAIoG,UAAYpF,EAChBysB,GAAiC5nB,SAAS7F,EAAKA,EAAIoG,UAAWpG,GACvDA,CACV,CAEDqG,qBACI,MAAMrF,EAAMX,KAAK+F,UAGjB,OAFA/F,KAAK+F,UAAY,EACjBqnB,GAAiC3nB,WAAWzF,MACrCW,CACV,CAEDsF,OACI,MAAMtF,EAAMX,KAAKgG,qBACjBhH,EAAKquB,gCAAgC1sB,EAAK,EAC7C,CAMD8hB,UAAUlY,GAEN,OADYvL,EAAKsuB,+BAA+BttB,KAAK+F,UAAWwE,EAEnE,CAMDwY,aAAaxY,GACT,MAAM9I,EAAMzC,EAAKuuB,kCAAkCvtB,KAAK+F,UAAWwE,GACnE,OAAOnC,GAAYb,OAAO9F,EAC7B,CAMDwhB,aAAa1Y,GACT,MAAM9I,EAAMzC,EAAKwuB,kCAAkCxtB,KAAK+F,UAAWwE,GACnE,OAAOnC,GAAYb,OAAO9F,EAC7B,CASD0hB,aAAa5Y,GACT,MAAM9I,EAAMzC,EAAKyuB,kCAAkCztB,KAAK+F,UAAWwE,GACnE,OAAOnD,GAAUG,OAAO9F,EAC3B,CASD4hB,aAAa9Y,GACT,MAAM9I,EAAMzC,EAAK0uB,kCAAkC1tB,KAAK+F,UAAWwE,GACnE,OAAOnD,GAAUG,OAAO9F,EAC3B,CAMDmiB,qBAAqBrZ,GAEjB,OAAe,IADHvL,EAAK2uB,0CAA0C3tB,KAAK+F,UAAWwE,EAE9E,CAMDuZ,wBAAwBvZ,EAAQiG,GAC5BxR,EAAK4uB,6CAA6C5tB,KAAK+F,UAAWwE,EAAQiG,EAC7E,CAODwT,mBAAmBzZ,EAAQuX,GAEvB,OAAe,IADH9iB,EAAK6uB,wCAAwC7tB,KAAK+F,UAAWwE,EAAQuX,EAEpF,CAODoC,eAAe3Z,EAAQuX,GAEnB,OADY9iB,EAAK8uB,oCAAoC9tB,KAAK+F,UAAWwE,EAAQuX,EAEhF,CAODsC,eAAe7Z,EAAQuX,GAEnB,OADY9iB,EAAK+uB,oCAAoC/tB,KAAK+F,UAAWwE,EAAQuX,EAEhF,CACD5b,cACI,MAAMzE,EAAMzC,EAAKgvB,2BAGjB,OAFAhuB,KAAK+F,UAAYtE,IAAQ,EACzB2rB,GAAiC5nB,SAASxF,KAAMA,KAAK+F,UAAW/F,MACzDA,IACV,CAQDulB,YAAYC,EAAQC,EAASC,EAASzM,GAClCtX,EAAa6jB,EAAQlE,GAErB,OADYtiB,EAAKivB,iCAAiCjuB,KAAK+F,UAAWyf,EAAOzf,UAAW0f,EAASC,EAASzM,EAEzG,CAKDF,OAAOxO,EAAQ0O,GACXja,EAAKkvB,4BAA4BluB,KAAK+F,UAAWwE,EAAQ0O,EAC5D,CAKDrB,SAASrN,GAEL,OAAe,IADHvL,EAAKmvB,8BAA8BnuB,KAAK+F,UAAWwE,EAElE,CAQDyb,mBAAmBnmB,GACf,IACIb,EAAKovB,wCAAwCpuB,KAAK+F,UAAW/D,EAAkBnC,GAGlF,CAFS,QACNZ,EAAK8C,UAAmB3C,CAC3B,CACJ,CASD8mB,gCAAgCC,EAAMtmB,GAClC,IACIb,EAAKqvB,qDAAqDruB,KAAK+F,UAAWogB,EAAMnkB,EAAkBnC,GAGrG,CAFS,QACNZ,EAAK8C,UAAmB3C,CAC3B,CACJ,EAGL,MAAMkvB,GAA8D,oBAAzB/oB,qBACrC,CAAEC,SAAU,OAAUC,WAAY,QAClC,IAAIF,sBAAqB5E,GAAO3B,EAAKuvB,0BAA0B5tB,IAAQ,EAAG,KAEzE,MAAMsG,GAETrB,cAAcjF,GACVA,KAAc,EACd,MAAMhB,EAAMsD,OAAO4C,OAAOoB,GAAenB,WAGzC,OAFAnG,EAAIoG,UAAYpF,EAChB2tB,GAA2B9oB,SAAS7F,EAAKA,EAAIoG,UAAWpG,GACjDA,CACV,CAEDqG,qBACI,MAAMrF,EAAMX,KAAK+F,UAGjB,OAFA/F,KAAK+F,UAAY,EACjBuoB,GAA2B7oB,WAAWzF,MAC/BW,CACV,CAEDsF,OACI,MAAMtF,EAAMX,KAAKgG,qBACjBhH,EAAKuvB,0BAA0B5tB,EAAK,EACvC,CACDuF,cACI,MAAMzE,EAAMzC,EAAKwvB,qBAGjB,OAFAxuB,KAAK+F,UAAYtE,IAAQ,EACzB6sB,GAA2B9oB,SAASxF,KAAMA,KAAK+F,UAAW/F,MACnDA,IACV,CAKDyuB,mBAAmBtf,EAAStP,GACxBb,EAAK0vB,kCAAkC1uB,KAAK+F,UAAWoJ,EAASzP,EAAcG,GACjF,CAMD8uB,aAAaxf,EAASC,GAClB,MAAM3N,EAAMzC,EAAK4vB,4BAA4B5uB,KAAK+F,UAAWoJ,EAASC,GACtE,OAAe,IAAR3N,OAAYrC,EAAY0e,EAAevW,OAAO9F,EACxD,CAKDotB,wBAAwB1f,EAAStP,GAC7Bb,EAAK8vB,uCAAuC9uB,KAAK+F,UAAWoJ,EAASzP,EAAcG,GACtF,CAMDkvB,kBAAkB5f,EAASC,GAEvB,OAAe,IADHpQ,EAAKgwB,iCAAiChvB,KAAK+F,UAAWoJ,EAASC,EAE9E,EAGL,MAAM6f,GAAkE,oBAAzB1pB,qBACzC,CAAEC,SAAU,OAAUC,WAAY,QAClC,IAAIF,sBAAqB5E,GAAO3B,EAAKkwB,8BAA8BvuB,IAAQ,EAAG,KAE7E,MAAMwuB,GAETnpB,qBACI,MAAMrF,EAAMX,KAAK+F,UAGjB,OAFA/F,KAAK+F,UAAY,EACjBkpB,GAA+BxpB,WAAWzF,MACnCW,CACV,CAEDsF,OACI,MAAMtF,EAAMX,KAAKgG,qBACjBhH,EAAKkwB,8BAA8BvuB,EAAK,EAC3C,CACDuF,cACI,MAAMzE,EAAMzC,EAAKowB,yBAGjB,OAFApvB,KAAK+F,UAAYtE,IAAQ,EACzBwtB,GAA+BzpB,SAASxF,KAAMA,KAAK+F,UAAW/F,MACvDA,IACV,CAIDqvB,qBAAqB7e,GACjBxR,EAAKswB,wCAAwCtvB,KAAK+F,UAAWyK,EAChE,CAID+e,sBAEI,OAAe,IADHvwB,EAAKwwB,uCAAuCxvB,KAAK+F,UAEhE,CAID0pB,cAEI,OADYzwB,EAAK0wB,+BAA+B1vB,KAAK+F,UAExD,CAID4pB,6BAEI,OADY3wB,EAAK4wB,8CAA8C5vB,KAAK+F,UAEvE,CAID8pB,qBAEI,OADY7wB,EAAK8wB,sCAAsC9vB,KAAK+F,UAE/D,CAIDgqB,sBAEI,OADY/wB,EAAKgxB,uCAAuChwB,KAAK+F,UAEhE,CAIDkqB,gBAEI,OADYjxB,EAAKkxB,iCAAiClwB,KAAK+F,UAE1D,CAIDoqB,2BAEI,OADYnxB,EAAKoxB,4CAA4CpwB,KAAK+F,UAErE,CAIDsqB,6BAEI,OADYrxB,EAAKsxB,8CAA8CtwB,KAAK+F,UAEvE,CAIDwqB,yBAEI,OADYvxB,EAAKwxB,0CAA0CxwB,KAAK+F,UAEnE,CAID0qB,4BAEI,OADYzxB,EAAK0xB,6CAA6C1wB,KAAK+F,UAEtE,CAID4qB,aAEI,OADY3xB,EAAK4xB,8BAA8B5wB,KAAK+F,UAEvD,CAID8qB,6BAEI,OADY7xB,EAAK8xB,8CAA8C9wB,KAAK+F,UAEvE,CAIDgrB,yBAEI,OADY/xB,EAAKgyB,0CAA0ChxB,KAAK+F,UAEnE,CAIDkrB,0BAEI,OADYjyB,EAAKkyB,2CAA2ClxB,KAAK+F,UAEpE,CAIDorB,oBAEI,OADYnyB,EAAKoyB,qCAAqCpxB,KAAK+F,UAE9D,CAIDsrB,6BAEI,OADYryB,EAAKsyB,8CAA8CtxB,KAAK+F,UAEvE,CAIDwrB,sBAEI,OADYvyB,EAAKwyB,uCAAuCxxB,KAAK+F,UAEhE,CAaD0rB,KAAKC,EAASC,EAAuB3Y,EAAS4Y,EAAYC,EAAavrB,EAAQC,EAAWurB,EAAQC,EAAeC,GAC7GrwB,EAAa+vB,EAAStqB,IACtBzF,EAAagwB,EAAuBjS,IACpC/d,EAAaqX,EAASE,IACtBvX,EAAaiwB,EAAYjsB,GACzBhE,EAAakwB,EAAa5qB,IAC1BtF,EAAa2E,EAAQY,IACrBvF,EAAa4E,EAAWY,GACxBxF,EAAamwB,EAAQ9S,IACrBrd,EAAaowB,EAAe9S,IAC5Btd,EAAaqwB,EAAY/nB,GACzBjL,EAAKizB,wBAAwBjyB,KAAK+F,UAAW2rB,EAAQ3rB,UAAW4rB,EAAsB5rB,UAAWiT,EAAQjT,UAAW6rB,EAAW7rB,UAAW8rB,EAAY9rB,UAAWO,EAAOP,UAAWQ,EAAUR,UAAW+rB,EAAO/rB,UAAWgsB,EAAchsB,UAAWisB,EAAWjsB,UACjQ,CAiBDmsB,eAAeR,EAASC,EAAuB3Y,EAAS4Y,EAAYC,EAAavrB,EAAQC,EAAWurB,EAAQC,EAAeC,EAAYG,EAAYC,EAAYC,EAAuBC,GAClL3wB,EAAa+vB,EAAStqB,IACtBzF,EAAagwB,EAAuBjS,IACpC/d,EAAaqX,EAASE,IACtBvX,EAAaiwB,EAAYjsB,GACzBhE,EAAakwB,EAAa5qB,IAC1BtF,EAAa2E,EAAQY,IACrBvF,EAAa4E,EAAWY,GACxBxF,EAAamwB,EAAQ9S,IACrBrd,EAAaowB,EAAe9S,IAC5Btd,EAAaqwB,EAAY/nB,GACzBtI,EAAawwB,EAAYxR,GACzB3hB,EAAKuzB,kCAAkCvyB,KAAK+F,UAAW2rB,EAAQ3rB,UAAW4rB,EAAsB5rB,UAAWiT,EAAQjT,UAAW6rB,EAAW7rB,UAAW8rB,EAAY9rB,UAAWO,EAAOP,UAAWQ,EAAUR,UAAW+rB,EAAO/rB,UAAWgsB,EAAchsB,UAAWisB,EAAWjsB,UAAWosB,EAAWpsB,UAAWrG,EAAc0yB,GAAa1yB,EAAc2yB,GAAwB3yB,EAAc4yB,GAC3X,EAGL,MAAME,GAAgE,oBAAzBjtB,qBACvC,CAAEC,SAAU,OAAUC,WAAY,QAClC,IAAIF,sBAAqB5E,GAAO3B,EAAKyzB,4BAA4B9xB,IAAQ,EAAG,KAE3E,MAAM+xB,GAET1sB,qBACI,MAAMrF,EAAMX,KAAK+F,UAGjB,OAFA/F,KAAK+F,UAAY,EACjBysB,GAA6B/sB,WAAWzF,MACjCW,CACV,CAEDsF,OACI,MAAMtF,EAAMX,KAAKgG,qBACjBhH,EAAKyzB,4BAA4B9xB,EAAK,EACzC,CAODuF,YAAYysB,EAAIC,EAAIC,EAAIC,GACpB,MAAMrxB,EAAMzC,EAAK+zB,qBAAqBJ,EAAIC,EAAIC,EAAIC,GAGlD,OAFA9yB,KAAK+F,UAAYtE,IAAQ,EACzB+wB,GAA6BhtB,SAASxF,KAAMA,KAAK+F,UAAW/F,MACrDA,IACV,CAKDgzB,OAAOL,EAAIM,GACPj0B,EAAKk0B,wBAAwBlzB,KAAK+F,UAAW4sB,EAAIM,EACpD,CAKDE,OAAOP,EAAIK,GACPj0B,EAAKo0B,wBAAwBpzB,KAAK+F,UAAW6sB,EAAIK,EACpD,CAKDI,OAAOR,EAAII,GACPj0B,EAAKs0B,wBAAwBtzB,KAAK+F,UAAW8sB,EAAII,EACpD,CAIDM,cAAcT,GACV9zB,EAAKw0B,+BAA+BxzB,KAAK+F,UAAW+sB,EACvD,CACDW,kBACIz0B,EAAK00B,iCAAiC1zB,KAAK+F,UAC9C,CAQD4tB,wBAAwBnN,EAAIlgB,EAAQstB,EAAWC,EAAoBC,GAC/DnyB,EAAa2E,EAAQY,IACrBvF,EAAakyB,EAAoBzsB,IACjCzF,EAAamyB,EAAe1sB,IAC5BpI,EAAK+0B,yCAAyC/zB,KAAK+F,UAAWygB,EAAIlgB,EAAOP,UAAW6tB,EAAWC,EAAmB9tB,UAAW+tB,EAAc/tB,UAC9I,CAQDiuB,yBAAyBxN,EAAIlgB,EAAQstB,EAAWK,EAAiBC,GAC7DvyB,EAAa2E,EAAQY,IACrBlI,EAAKm1B,0CAA0Cn0B,KAAK+F,UAAWygB,EAAIlgB,EAAOP,UAAW6tB,EAAWK,EAAiBC,EACpH,CASDE,kBAAkB5N,EAAIlgB,EAAQstB,EAAWC,EAAoBC,GACzDnyB,EAAa2E,EAAQY,IACrBvF,EAAakyB,EAAoBzsB,IACjCzF,EAAamyB,EAAe1sB,IAC5B,MAAM3F,EAAMzC,EAAKq1B,mCAAmCr0B,KAAK+F,UAAWygB,EAAIlgB,EAAOP,UAAW6tB,EAAWC,EAAmB9tB,UAAW+tB,EAAc/tB,WACjJ,OAAOqB,GAAUG,OAAO9F,EAC3B,CASD6yB,mBAAmB9N,EAAIlgB,EAAQstB,EAAWK,EAAiBC,GACvDvyB,EAAa2E,EAAQY,IAErB,OADYlI,EAAKu1B,oCAAoCv0B,KAAK+F,UAAWygB,EAAIlgB,EAAOP,UAAW6tB,EAAWK,EAAiBC,EAE1H,EAGL,MAAMM,GAA0E,oBAAzBjvB,qBACjD,CAAEC,SAAU,OAAUC,WAAY,QAClC,IAAIF,sBAAqB5E,GAAO3B,EAAKy1B,sCAAsC9zB,IAAQ,EAAG,KAErF,MAAMmI,GAETlD,cAAcjF,GACVA,KAAc,EACd,MAAMhB,EAAMsD,OAAO4C,OAAOiD,GAA2BhD,WAGrD,OAFAnG,EAAIoG,UAAYpF,EAChB6zB,GAAuChvB,SAAS7F,EAAKA,EAAIoG,UAAWpG,GAC7DA,CACV,CAEDqG,qBACI,MAAMrF,EAAMX,KAAK+F,UAGjB,OAFA/F,KAAK+F,UAAY,EACjByuB,GAAuC/uB,WAAWzF,MAC3CW,CACV,CAEDsF,OACI,MAAMtF,EAAMX,KAAKgG,qBACjBhH,EAAKy1B,sCAAsC9zB,EAAK,EACnD,CAID8Y,iBAEI,OADYza,EAAK01B,0CAA0C10B,KAAK+F,UAEnE,CAID6C,QACI,MAAMnH,EAAMzC,EAAK21B,iCAAiC30B,KAAK+F,WACvD,OAAOqB,GAAUG,OAAO9F,EAC3B,CAIDmzB,WAEI,OAAe,IADH51B,EAAK61B,oCAAoC70B,KAAK+F,UAE7D,CAID+uB,cAEI,OADY91B,EAAK+1B,uCAAuC/0B,KAAK+F,UAEhE,CAIDivB,YACI,MAAMvzB,EAAMzC,EAAKi2B,qCAAqCj1B,KAAK+F,WAC3D,OAAe,aAARtE,OAAsBrC,EAAYqC,CAC5C,EAGL,MAAMyzB,GAAkE,oBAAzB3vB,qBACzC,CAAEC,SAAU,OAAUC,WAAY,QAClC,IAAIF,sBAAqB5E,GAAO3B,EAAKm2B,8BAA8Bx0B,IAAQ,EAAG,KAE7E,MAAMwT,GAETvO,cAAcjF,GACVA,KAAc,EACd,MAAMhB,EAAMsD,OAAO4C,OAAOsO,GAAmBrO,WAG7C,OAFAnG,EAAIoG,UAAYpF,EAChBu0B,GAA+B1vB,SAAS7F,EAAKA,EAAIoG,UAAWpG,GACrDA,CACV,CAEDqG,qBACI,MAAMrF,EAAMX,KAAK+F,UAGjB,OAFA/F,KAAK+F,UAAY,EACjBmvB,GAA+BzvB,WAAWzF,MACnCW,CACV,CAEDsF,OACI,MAAMtF,EAAMX,KAAKgG,qBACjBhH,EAAKm2B,8BAA8Bx0B,EAAK,EAC3C,CAIDiI,QACI,MAAMnH,EAAMzC,EAAKo2B,yBAAyBp1B,KAAK+F,WAC/C,OAAOqB,GAAUG,OAAO9F,EAC3B,CAIDmzB,WAEI,OAAe,IADH51B,EAAKq2B,4BAA4Br1B,KAAK+F,UAErD,EAGL,MAAMuvB,GAAiE,oBAAzB/vB,qBACxC,CAAEC,SAAU,OAAUC,WAAY,QAClC,IAAIF,sBAAqB5E,GAAO3B,EAAKu2B,6BAA6B50B,IAAQ,EAAG,KAE5E,MAAM2G,GAET1B,cAAcjF,GACVA,KAAc,EACd,MAAMhB,EAAMsD,OAAO4C,OAAOyB,GAAkBxB,WAG5C,OAFAnG,EAAIoG,UAAYpF,EAChB20B,GAA8B9vB,SAAS7F,EAAKA,EAAIoG,UAAWpG,GACpDA,CACV,CAEDqG,qBACI,MAAMrF,EAAMX,KAAK+F,UAGjB,OAFA/F,KAAK+F,UAAY,EACjBuvB,GAA8B7vB,WAAWzF,MAClCW,CACV,CAEDsF,OACI,MAAMtF,EAAMX,KAAKgG,qBACjBhH,EAAKu2B,6BAA6B50B,EAAK,EAC1C,CAID8Y,iBAEI,OADYza,EAAK0a,uCAAuC1Z,KAAK+F,UAEhE,CAIDyvB,eAEI,OADYx2B,EAAK4a,uCAAuC5Z,KAAK+F,UAEhE,EAGL,MAAM0vB,GAA0E,oBAAzBlwB,qBACjD,CAAEC,SAAU,OAAUC,WAAY,QAClC,IAAIF,sBAAqB5E,GAAO3B,EAAK02B,sCAAsC/0B,IAAQ,EAAG,KAErF,MAAM+G,GAET9B,cAAcjF,GACVA,KAAc,EACd,MAAMhB,EAAMsD,OAAO4C,OAAO6B,GAA2B5B,WAGrD,OAFAnG,EAAIoG,UAAYpF,EAChB80B,GAAuCjwB,SAAS7F,EAAKA,EAAIoG,UAAWpG,GAC7DA,CACV,CAEDqG,qBACI,MAAMrF,EAAMX,KAAK+F,UAGjB,OAFA/F,KAAK+F,UAAY,EACjB0vB,GAAuChwB,WAAWzF,MAC3CW,CACV,CAEDsF,OACI,MAAMtF,EAAMX,KAAKgG,qBACjBhH,EAAK02B,sCAAsC/0B,EAAK,EACnD,CAID8Y,iBAEI,OADYza,EAAK01B,0CAA0C10B,KAAK+F,UAEnE,CAIDsV,SACI,MAAM5Z,EAAMzC,EAAK8a,iCAAiC9Z,KAAK+F,WACvD,OAAOqB,GAAUG,OAAO9F,EAC3B,CAIDkY,iBAEI,OADY3a,EAAK4a,uCAAuC5Z,KAAK+F,UAEhE,CAID+uB,cAEI,OADY91B,EAAK+1B,uCAAuC/0B,KAAK+F,UAEhE,CAIDivB,YACI,MAAMvzB,EAAMzC,EAAKi2B,qCAAqCj1B,KAAK+F,WAC3D,OAAe,aAARtE,OAAsBrC,EAAYqC,CAC5C,EAGL,MAAMk0B,GAAkE,oBAAzBpwB,qBACzC,CAAEC,SAAU,OAAUC,WAAY,QAClC,IAAIF,sBAAqB5E,GAAO3B,EAAK42B,8BAA8Bj1B,IAAQ,EAAG,KAE7E,MAAM+T,GAET9O,cAAcjF,GACVA,KAAc,EACd,MAAMhB,EAAMsD,OAAO4C,OAAO6O,GAAmB5O,WAG7C,OAFAnG,EAAIoG,UAAYpF,EAChBg1B,GAA+BnwB,SAAS7F,EAAKA,EAAIoG,UAAWpG,GACrDA,CACV,CAEDqG,qBACI,MAAMrF,EAAMX,KAAK+F,UAGjB,OAFA/F,KAAK+F,UAAY,EACjB4vB,GAA+BlwB,WAAWzF,MACnCW,CACV,CAEDsF,OACI,MAAMtF,EAAMX,KAAKgG,qBACjBhH,EAAK42B,8BAA8Bj1B,EAAK,EAC3C,CAID0a,SACI,MAAM5Z,EAAMzC,EAAK8a,iCAAiC9Z,KAAK+F,WACvD,OAAOqB,GAAUG,OAAO9F,EAC3B,CAIDkY,iBAEI,OADY3a,EAAK4a,uCAAuC5Z,KAAK+F,UAEhE,CAID+uB,cAEI,OADY91B,EAAK+1B,uCAAuC/0B,KAAK+F,UAEhE,CAIDivB,YACI,MAAMvzB,EAAMzC,EAAKi2B,qCAAqCj1B,KAAK+F,WAC3D,OAAe,aAARtE,OAAsBrC,EAAYqC,CAC5C,EAGL,MAAMo0B,GAA+D,oBAAzBtwB,qBACtC,CAAEC,SAAU,OAAUC,WAAY,QAClC,IAAIF,sBAAqB5E,GAAO3B,EAAK82B,2BAA2Bn1B,IAAQ,EAAG,KAE1E,MAAMuG,GAETtB,cAAcjF,GACVA,KAAc,EACd,MAAMhB,EAAMsD,OAAO4C,OAAOqB,GAAgBpB,WAG1C,OAFAnG,EAAIoG,UAAYpF,EAChBk1B,GAA4BrwB,SAAS7F,EAAKA,EAAIoG,UAAWpG,GAClDA,CACV,CAEDqG,qBACI,MAAMrF,EAAMX,KAAK+F,UAGjB,OAFA/F,KAAK+F,UAAY,EACjB8vB,GAA4BpwB,WAAWzF,MAChCW,CACV,CAEDsF,OACI,MAAMtF,EAAMX,KAAKgG,qBACjBhH,EAAK82B,2BAA2Bn1B,EAAK,EACxC,CAMDo1B,cAAcxrB,GACV,MAAM9I,EAAMzC,EAAKg3B,8BAA8Bh2B,KAAK+F,UAAWwE,GAC/D,OAAOnD,GAAUG,OAAO9F,EAC3B,CAMDw0B,WAAW1rB,GACP,MAAM9I,EAAMzC,EAAKk3B,2BAA2Bl2B,KAAK+F,UAAWwE,GAC5D,OAAOnC,GAAYb,OAAO9F,EAC7B,CAKD00B,QAAQ5rB,GACJvL,EAAKo3B,wBAAwBp2B,KAAK+F,UAAWwE,EAChD,CAMD8rB,aAAa9rB,GAET,OAAe,IADHvL,EAAKs3B,6BAA6Bt2B,KAAK+F,UAAWwE,EAEjE,CAMDgsB,WAAWhsB,GAEP,OAAe,IADHvL,EAAKw3B,2BAA2Bx2B,KAAK+F,UAAWwE,EAE/D,CAUDksB,kBAAkBlsB,GACd,MAAM9I,EAAMzC,EAAK03B,kCAAkC12B,KAAK+F,UAAWwE,GACnE,OAAOnD,GAAUG,OAAO9F,EAC3B,CAUDk1B,eAAepsB,GACX,MAAM9I,EAAMzC,EAAK43B,+BAA+B52B,KAAK+F,UAAWwE,GAChE,OAAOnC,GAAYb,OAAO9F,EAC7B,CAcDo1B,iBAAiBtsB,EAAQpJ,EAAG+K,EAAG+M,GAC3Bja,EAAK83B,iCAAiC92B,KAAK+F,UAAWwE,EAAQpJ,EAAG+K,EAAG+M,EACvE,CAYD8d,cAAcxsB,EAAQgC,EAAO0M,GACzBja,EAAKg4B,8BAA8Bh3B,KAAK+F,UAAWwE,EAAQgC,EAAO0M,EACrE,CAODge,YAAY1sB,EAAQ2sB,EAAQje,GACxBtX,EAAau1B,EAAQ9vB,IACrBpI,EAAKm4B,4BAA4Bn3B,KAAK+F,UAAWwE,EAAQ2sB,EAAOnxB,UAAWkT,EAC9E,CAODme,YAAY7sB,EAAQ8sB,EAAQpe,GACxBja,EAAKs4B,4BAA4Bt3B,KAAK+F,UAAWwE,EAAQ8sB,EAAQpe,EACpE,CAiBDse,8BAA8BhtB,EAAQpJ,EAAG+K,GACrClN,EAAKw4B,8CAA8Cx3B,KAAK+F,UAAWwE,EAAQpJ,EAAG+K,EACjF,CAeDurB,2BAA2BltB,EAAQgC,GAC/BvN,EAAK04B,2CAA2C13B,KAAK+F,UAAWwE,EAAQgC,EAC3E,CAKDorB,uCAAuCptB,EAAQhE,GAC3C5E,EAAa4E,EAAWY,GACxBnI,EAAK44B,uDAAuD53B,KAAK+F,UAAWwE,EAAQhE,EAAUR,UACjG,CAMD8xB,oBAAoBttB,EAAQ6M,EAAMuO,GAC9B3mB,EAAK84B,oCAAoC93B,KAAK+F,UAAWwE,EAAQ6M,EAAMuO,EAC1E,CAQDoS,8BAA8BxtB,EAAQ6M,EAAMG,EAAcC,EAAyBmO,GAC/EhkB,EAAa4V,EAAcnQ,IAC3BpI,EAAKg5B,8CAA8Ch4B,KAAK+F,UAAWwE,EAAQ6M,EAAMG,EAAaxR,UAAWyR,EAAyBmO,EACrI,CAMDsS,SAAS1tB,GACL,MAAM9I,EAAMzC,EAAKk5B,yBAAyBl4B,KAAK+F,UAAWwE,GAC1D,OAAOnD,GAAUG,OAAO9F,EAC3B,CAMD02B,SAAS5tB,GAEL,OADYvL,EAAKo5B,yBAAyBp4B,KAAK+F,UAAWwE,EAE7D,CAOD8tB,kBAAkB9tB,EAAQ3B,GACtBjH,EAAaiH,EAAOxB,IACpB,MAAM3F,EAAMzC,EAAKs5B,kCAAkCt4B,KAAK+F,UAAWwE,EAAQ3B,EAAM7C,WACjF,OAAOqB,GAAUG,OAAO9F,EAC3B,CAMD82B,mBAAmBhuB,EAAQiuB,EAAQ7S,GAC/B3mB,EAAKy5B,mCAAmCz4B,KAAK+F,UAAWwE,EAAQiuB,EAAQ7S,EAC3E,CAOD+S,yBAAyBnuB,EAAQouB,EAASC,EAASjT,GAC/C3mB,EAAK65B,yCAAyC74B,KAAK+F,UAAWwE,EAAQouB,EAASC,EAASjT,EAC3F,CAMDmT,gBAAgBvuB,EAAQiuB,EAAQ7S,GAC5B3mB,EAAK+5B,gCAAgC/4B,KAAK+F,UAAWwE,EAAQiuB,EAAQ7S,EACxE,CAKDqT,iBAAiBzuB,GAEb,OADYvL,EAAKi6B,iCAAiCj5B,KAAK+F,UAAWwE,EAErE,CAKD2uB,oBAAoB3uB,EAAQ4uB,GACxBn6B,EAAKo6B,oCAAoCp5B,KAAK+F,UAAWwE,EAAQ4uB,EACpE,CAKDE,YAAY9uB,EAAQiG,GAChBxR,EAAKs6B,4BAA4Bt5B,KAAK+F,UAAWwE,EAAQiG,EAC5D,CAKD+oB,uBAAuBhvB,EAAQqJ,GAC3B5U,EAAKw6B,uCAAuCx5B,KAAK+F,UAAWwE,EAAQqJ,EACvE,CAMD6lB,OAAOlvB,GAEH,OADYvL,EAAK06B,uBAAuB15B,KAAK+F,UAAWwE,EAE3D,CAQDovB,UAAUpvB,GAEN,OADYvL,EAAK46B,0BAA0B55B,KAAK+F,UAAWwE,EAE9D,CAMDsvB,mBAAmBtvB,GACf,MAAM9I,EAAMzC,EAAK86B,mCAAmC95B,KAAK+F,UAAWwE,GACpE,OAAOnD,GAAUG,OAAO9F,EAC3B,CAMDs4B,WAAWxvB,GACP,MAAM9I,EAAMzC,EAAKg7B,2BAA2Bh6B,KAAK+F,UAAWwE,GAC5D,OAAOnD,GAAUG,OAAO9F,EAC3B,CAMDw4B,WAAW1vB,GACP,MAAM9I,EAAMzC,EAAKk7B,2BAA2Bl6B,KAAK+F,UAAWwE,GAC5D,OAAOnD,GAAUG,OAAO9F,EAC3B,CAQD04B,0BAA0B5vB,GAEtB,OADYvL,EAAKo7B,0CAA0Cp6B,KAAK+F,UAAWwE,EAE9E,CAMD8vB,mBAAmB9vB,GAEf,OADYvL,EAAKs7B,mCAAmCt6B,KAAK+F,UAAWwE,EAEvE,CAODgwB,+BAA+BhwB,GAE3B,OADYvL,EAAKw7B,+CAA+Cx6B,KAAK+F,UAAWwE,EAEnF,CAODkwB,0BAA0BlwB,GAEtB,OADYvL,EAAK07B,0CAA0C16B,KAAK+F,UAAWwE,EAE9E,CAWDowB,SAASpwB,GACLvL,EAAK47B,yBAAyB56B,KAAK+F,UAAWwE,EACjD,CAMDswB,eAAetwB,GAEX,OAAe,IADHvL,EAAK87B,+BAA+B96B,KAAK+F,UAAWwE,EAEnE,CAKDwwB,oBAAoBxwB,GAEhB,OADYvL,EAAKg8B,oCAAoCh7B,KAAK+F,UAAWwE,EAExE,CAMD0wB,eAAe1wB,GAEX,OADYvL,EAAKk8B,+BAA+Bl7B,KAAK+F,UAAWwE,KACjD,CAClB,CAWD4wB,WAAW5wB,EAAQ6wB,GAEf,OADYp8B,EAAKq8B,2BAA2Br7B,KAAK+F,UAAWwE,EAAQ6wB,EAEvE,CAMDE,WAAW/wB,GAEP,OADYvL,EAAKu8B,2BAA2Bv7B,KAAK+F,UAAWwE,EAE/D,CAODixB,cAAcjxB,EAAQkxB,EAAQ9V,GAC1B3mB,EAAK08B,8BAA8B17B,KAAK+F,UAAWwE,EAAQkxB,EAAQ9V,EACtE,CAMDgW,UAAUpxB,GAEN,OAAe,IADHvL,EAAK48B,0BAA0B57B,KAAK+F,UAAWwE,EAE9D,CAMDsxB,cAActxB,GAEV,OAAe,IADHvL,EAAK88B,8BAA8B97B,KAAK+F,UAAWwE,EAElE,CAMDwxB,YAAYxxB,GAER,OAAe,IADHvL,EAAKg9B,4BAA4Bh8B,KAAK+F,UAAWwE,EAEhE,CAMD0xB,gBAAgB1xB,GAEZ,OADYvL,EAAKk9B,gCAAgCl8B,KAAK+F,UAAWwE,EAEpE,CAMD4xB,iBAAiB5xB,GAEb,OADYvL,EAAKo9B,iCAAiCp8B,KAAK+F,UAAWwE,EAErE,CAKD8xB,mBAAmB9xB,EAAQwa,GACvB/lB,EAAKs9B,mCAAmCt8B,KAAK+F,UAAWwE,EAAQwa,EACnE,CAKDwX,oBAAoBhyB,EAAQwa,GACxB/lB,EAAKw9B,oCAAoCx8B,KAAK+F,UAAWwE,EAAQwa,EACpE,CAKD0X,aAAalyB,EAAQiG,GACjBxR,EAAK09B,6BAA6B18B,KAAK+F,UAAWwE,EAAQiG,EAC7D,CAKDmsB,YAAYpyB,GAER,OAAe,IADHvL,EAAK49B,4BAA4B58B,KAAK+F,UAAWwE,EAEhE,CAKDsyB,eAAetyB,GAEX,OADYvL,EAAK89B,+BAA+B98B,KAAK+F,UAAWwE,EAEnE,CAMDwyB,kBAAkBxyB,EAAQwa,EAAQ9L,GAC9Bja,EAAKg+B,kCAAkCh9B,KAAK+F,UAAWwE,EAAQwa,EAAQ9L,EAC1E,CAMDgkB,cAAc1yB,EAAQ0O,GAClBja,EAAKk+B,8BAA8Bl9B,KAAK+F,UAAWwE,EAAQ0O,EAC9D,CAMDkkB,eAAe5yB,EAAQ0O,GACnBja,EAAKo+B,+BAA+Bp9B,KAAK+F,UAAWwE,EAAQ0O,EAC/D,CAWDokB,WAAW9yB,EAAQ+yB,EAAOrkB,GACtBtX,EAAa27B,EAAOl2B,IACpBpI,EAAKu+B,2BAA2Bv9B,KAAK+F,UAAWwE,EAAQ+yB,EAAMv3B,UAAWkT,EAC5E,CAWDukB,eAAejzB,EAAQkzB,EAASxkB,GAC5BtX,EAAa87B,EAASr2B,IACtBpI,EAAK0+B,+BAA+B19B,KAAK+F,UAAWwE,EAAQkzB,EAAQ13B,UAAWkT,EAClF,CAWD0kB,YAAYpzB,EAAQqzB,EAAQ3kB,GACxBja,EAAK6+B,4BAA4B79B,KAAK+F,UAAWwE,EAAQqzB,EAAQ3kB,EACpE,CAWD6kB,qBAAqBvzB,EAAQwzB,EAAgB9kB,GACzCja,EAAKg/B,qCAAqCh+B,KAAK+F,UAAWwE,EAAQwzB,EAAgB9kB,EACrF,CAaDglB,kBAAkB1zB,EAAQ+yB,EAAO10B,EAAOqQ,GACpCtX,EAAa27B,EAAOl2B,IACpBzF,EAAaiH,EAAOxB,IACpBpI,EAAKk/B,kCAAkCl+B,KAAK+F,UAAWwE,EAAQ+yB,EAAMv3B,UAAW6C,EAAM7C,UAAWkT,EACpG,CAaDklB,sBAAsB5zB,EAAQkzB,EAAS70B,EAAOqQ,GAC1CtX,EAAa87B,EAASr2B,IACtBzF,EAAaiH,EAAOxB,IACpBpI,EAAKo/B,sCAAsCp+B,KAAK+F,UAAWwE,EAAQkzB,EAAQ13B,UAAW6C,EAAM7C,UAAWkT,EAC1G,CAKDolB,6BAA6B9zB,GAEzB,OADYvL,EAAKs/B,6CAA6Ct+B,KAAK+F,UAAWwE,KAC/D,CAClB,CAKDg0B,gCAAgCh0B,EAAQi0B,GACpCx/B,EAAKy/B,gDAAgDz+B,KAAK+F,UAAWwE,EAAQi0B,EAChF,CAMDE,WAAWn0B,GAEP,OADYvL,EAAK2/B,2BAA2B3+B,KAAK+F,UAAWwE,KAC7C,CAClB,CASDq0B,cAAcr0B,EAAQs0B,GAClB7/B,EAAK8/B,8BAA8B9+B,KAAK+F,UAAWwE,EAAQs0B,EAC9D,CAODE,YAAYx0B,GACR,MAAM9I,EAAMzC,EAAKggC,4BAA4Bh/B,KAAK+F,UAAWwE,GAC7D,OAAOnD,GAAUG,OAAO9F,EAC3B,CAODw9B,aAAa10B,GAET,OADYvL,EAAKkgC,6BAA6Bl/B,KAAK+F,UAAWwE,EAEjE,CACDrE,cACI,MAAMzE,EAAMzC,EAAKmgC,sBAGjB,OAFAn/B,KAAK+F,UAAYtE,IAAQ,EACzBo0B,GAA4BrwB,SAASxF,KAAMA,KAAK+F,UAAW/F,MACpDA,IACV,CA0BDo/B,gBAAgB5uB,EAASuH,EAAaC,EAAUqnB,EAAcjoB,EAAMkoB,EAAU/nB,EAAc2f,EAAQG,EAAQ7f,EAAyB+nB,EAAqBC,EAAqBC,EAAkBC,EAAeC,EAAgBC,EAASC,EAAUC,EAAUC,EAAmBC,EAAYC,EAAgBC,GACxSv+B,EAAaoW,EAAa3Q,IAC1BzF,EAAaqW,EAAU5P,IACvBzG,EAAa4V,EAAcnQ,IAC3BzF,EAAau1B,EAAQ9vB,IAErB,OADYpI,EAAKmhC,gCAAgCngC,KAAK+F,UAAWyK,EAASuH,EAAYhS,UAAWiS,EAASjS,UAAWs5B,EAAcjoB,EAAMkoB,EAAU/nB,EAAaxR,UAAWmxB,EAAOnxB,UAAWsxB,EAAQ7f,EAAyB+nB,EAAqBC,EAAqBC,EAAkBC,EAAeC,EAAgBC,EAASC,EAAUC,EAAUC,EAAmBC,EAAYC,EAAgBC,EAExY,CAQDnnB,OAAOxO,EAAQyO,EAASzS,EAAWurB,EAAQC,GACvCpwB,EAAaqX,EAASE,IACtBvX,EAAa4E,EAAWY,GACxBxF,EAAamwB,EAAQ9S,IACrBrd,EAAaowB,EAAe9S,IAC5BjgB,EAAKohC,uBAAuBpgC,KAAK+F,UAAWwE,EAAQyO,EAAQjT,UAAWQ,EAAUR,UAAW+rB,EAAO/rB,UAAWgsB,EAAchsB,UAC/H,CAKDnF,MAEI,OADY5B,EAAK2Y,mBAAmB3X,KAAK+F,aAC1B,CAClB,CAMD6R,SAASrN,GAEL,OAAe,IADHvL,EAAKqhC,yBAAyBrgC,KAAK+F,UAAWwE,EAE7D,CAQD+1B,uBAAuBzgC,GACnB,IACIb,EAAKuhC,uCAAuCvgC,KAAK+F,UAAW/D,EAAkBnC,GAGjF,CAFS,QACNZ,EAAK8C,UAAmB3C,CAC3B,CACJ,CAIDohC,0CAA0Cj6B,GACtC5E,EAAa4E,EAAWY,GACxBnI,EAAKyhC,0DAA0DzgC,KAAK+F,UAAWQ,EAAUR,UAC5F,EAGL,MAAM26B,GAA2D,oBAAzBn7B,qBAClC,CAAEC,SAAU,OAAUC,WAAY,QAClC,IAAIF,sBAAqB5E,GAAO3B,EAAK2hC,uBAAuBhgC,IAAQ,EAAG,KAItE,MAAMyH,GAETxC,cAAcjF,GACVA,KAAc,EACd,MAAMhB,EAAMsD,OAAO4C,OAAOuC,GAAYtC,WAGtC,OAFAnG,EAAIoG,UAAYpF,EAChB+/B,GAAwBl7B,SAAS7F,EAAKA,EAAIoG,UAAWpG,GAC9CA,CACV,CAEDqG,qBACI,MAAMrF,EAAMX,KAAK+F,UAGjB,OAFA/F,KAAK+F,UAAY,EACjB26B,GAAwBj7B,WAAWzF,MAC5BW,CACV,CAEDsF,OACI,MAAMtF,EAAMX,KAAKgG,qBACjBhH,EAAK2hC,uBAAuBhgC,EAAK,EACpC,CAKDiF,kBACI,MAAMnE,EAAMzC,EAAK4hC,uBACjB,OAAOx4B,GAAYb,OAAO9F,EAC7B,CAMDmE,iBAAiB2G,GACb,MAAM9K,EAAMzC,EAAK6hC,sBAAsBt0B,GACvC,OAAOnE,GAAYb,OAAO9F,EAC7B,CAKGq/B,SAEA,OADY9hC,EAAKynB,4BAA4BzmB,KAAK+F,UAErD,CAKGg7B,SAEA,OADY/hC,EAAKgiC,eAAehhC,KAAK+F,UAExC,CAKGwG,YAEA,OADYvN,EAAKiiC,kBAAkBjhC,KAAK+F,UAE3C,EAGL,MAAMm7B,GAAwE,oBAAzB37B,qBAC/C,CAAEC,SAAU,OAAUC,WAAY,QAClC,IAAIF,sBAAqB5E,GAAO3B,EAAKmiC,oCAAoCxgC,IAAQ,EAAG,KAEnF,MAAMygC,GAETp7B,qBACI,MAAMrF,EAAMX,KAAK+F,UAGjB,OAFA/F,KAAK+F,UAAY,EACjBm7B,GAAqCz7B,WAAWzF,MACzCW,CACV,CAEDsF,OACI,MAAMtF,EAAMX,KAAKgG,qBACjBhH,EAAKmiC,oCAAoCxgC,EAAK,EACjD,CACDuF,cACI,MAAMzE,EAAMzC,EAAKkL,mBAGjB,OAFAlK,KAAK+F,UAAYtE,IAAQ,EACzBy/B,GAAqC17B,SAASxF,KAAMA,KAAK+F,UAAW/F,MAC7DA,IACV,CAaDqhC,aAAa3P,EAASC,EAAuB3Y,EAAS4Y,EAAYC,EAAavrB,EAAQC,EAAWuY,EAAgBC,GAC9Gpd,EAAa+vB,EAAStqB,IACtBzF,EAAagwB,EAAuBjS,IACpC/d,EAAaqX,EAASE,IACtBvX,EAAaiwB,EAAYjsB,GACzBhE,EAAakwB,EAAa5qB,IAC1BtF,EAAa2E,EAAQY,IACrBvF,EAAa4E,EAAWY,GACxBxF,EAAamd,EAAgBE,IAC7Brd,EAAaod,EAAkBE,IAE/B,OAAOzd,EADKxC,EAAKsiC,sCAAsCthC,KAAK+F,UAAW2rB,EAAQ3rB,UAAW4rB,EAAsB5rB,UAAWiT,EAAQjT,UAAW6rB,EAAW7rB,UAAW8rB,EAAY9rB,UAAWO,EAAOP,UAAWQ,EAAUR,UAAW+Y,EAAe/Y,UAAWgZ,EAAiBhZ,WAEhR,CAKDw7B,eAAe1C,GACX,MAAMp9B,EAAMzC,EAAKwiC,wCAAwCxhC,KAAK+F,UAAWrG,EAAcm/B,IACvF,OAAe,IAARp9B,OAAYrC,EAAYigB,EAAqB9X,OAAO9F,EAC9D,EAGL,MAAMggC,GAAwD,oBAAzBl8B,qBAC/B,CAAEC,SAAU,OAAUC,WAAY,QAClC,IAAIF,sBAAqB5E,GAAO3B,EAAK0iC,oBAAoB/gC,IAAQ,EAAG,KAEnE,MAAM0H,GAETzC,cAAcjF,GACVA,KAAc,EACd,MAAMhB,EAAMsD,OAAO4C,OAAOwC,GAASvC,WAGnC,OAFAnG,EAAIoG,UAAYpF,EAChB8gC,GAAqBj8B,SAAS7F,EAAKA,EAAIoG,UAAWpG,GAC3CA,CACV,CAEDqG,qBACI,MAAMrF,EAAMX,KAAK+F,UAGjB,OAFA/F,KAAK+F,UAAY,EACjB07B,GAAqBh8B,WAAWzF,MACzBW,CACV,CAEDsF,OACI,MAAMtF,EAAMX,KAAKgG,qBACjBhH,EAAK0iC,oBAAoB/gC,EAAK,EACjC,CAMDiF,cAAc+7B,EAAIC,GACd,MAAMngC,EAAMzC,EAAK6iC,gBAAgBF,EAAIC,GACrC,OAAOv5B,GAASd,OAAO9F,EAC1B,CAODmE,mBAAmB+7B,EAAIC,EAAIE,GACvB,MAAMrgC,EAAMzC,EAAK+iC,qBAAqBJ,EAAIC,EAAIE,GAC9C,OAAOz5B,GAASd,OAAO9F,EAC1B,CAKDmE,YAAYo8B,GACR,MAAMvgC,EAAMzC,EAAKijC,cAAcD,GAC/B,OAAO35B,GAASd,OAAO9F,EAC1B,CAKDmE,iBAAiByV,GACb1Z,EAAa0Z,EAAQjU,IACrB,MAAM3F,EAAMzC,EAAKkjC,mBAAmB7mB,EAAOtV,WAC3C,OAAOsC,GAASd,OAAO9F,EAC1B,CAMDmE,eAAeu8B,EAAYH,GACvB,MAAMvgC,EAAMzC,EAAKojC,iBAAiBD,EAAYH,GAC9C,OAAO35B,GAASd,OAAO9F,EAC1B,CAMDmE,cAAcy8B,EAAYC,GACtB3gC,EAAa0gC,EAAYj7B,IACzB,MAAMm7B,EAAO3/B,EAAmB0/B,EAAatjC,EAAKwjC,qBAC5CC,EAAO9/B,EACPlB,EAAMzC,EAAK0jC,gBAAgBL,EAAWt8B,UAAWw8B,EAAME,GAC7D,OAAOp6B,GAASd,OAAO9F,EAC1B,CAMDmE,wBAAwBy8B,EAAYM,GAChChhC,EAAa0gC,EAAYj7B,IACzB,MAAMm7B,EAAOv/B,EAAoB2/B,EAAQ3jC,EAAKwjC,qBACxCC,EAAO9/B,EACPlB,EAAMzC,EAAK4jC,0BAA0BP,EAAWt8B,UAAWw8B,EAAME,GACvE,OAAOp6B,GAASd,OAAO9F,EAC1B,CAMDmE,gBAAgB6Y,EAAUokB,GACtB,MAAMN,EAAOv/B,EAAoByb,EAAUzf,EAAKwjC,qBAC1CC,EAAO9/B,EACPmgC,EAAOlgC,EAAmBigC,EAAS7jC,EAAKwjC,qBACxCO,EAAOpgC,EACPlB,EAAMzC,EAAKgkC,kBAAkBT,EAAME,EAAMK,EAAMC,GACrD,OAAO16B,GAASd,OAAO9F,EAC1B,CAODmE,eAAe6Y,EAAUokB,EAASI,GAC9B,MAAMV,EAAOv/B,EAAoByb,EAAUzf,EAAKwjC,qBAC1CC,EAAO9/B,EACPmgC,EAAOlgC,EAAmBigC,EAAS7jC,EAAKwjC,qBACxCO,EAAOpgC,EACPlB,EAAMzC,EAAKkkC,iBAAiBX,EAAME,EAAMK,EAAMC,EAAME,GAC1D,OAAe,IAARxhC,OAAYrC,EAAYiJ,GAASd,OAAO9F,EAClD,CAMDmE,mBAAmBu9B,EAASC,GACxB,MAAMb,EAAOv/B,EAAoBmgC,EAASnkC,EAAKwjC,qBACzCC,EAAO9/B,EACbhB,EAAayhC,EAAOh8B,IACpB,MAAM3F,EAAMzC,EAAKqkC,qBAAqBd,EAAME,EAAMW,EAAMr9B,WACxD,OAAOsC,GAASd,OAAO9F,EAC1B,CAMDmE,eAAe09B,EAAIC,GACf5hC,EAAa2hC,EAAIl8B,IACjBzF,EAAa4hC,EAAIn8B,IACjB,MAAM3F,EAAMzC,EAAKwkC,iBAAiBF,EAAGv9B,UAAWw9B,EAAGx9B,WACnD,OAAOsC,GAASd,OAAO9F,EAC1B,CAODmE,gBAAgB09B,EAAIC,EAAIE,GACpB9hC,EAAa2hC,EAAIl8B,IACjBzF,EAAa4hC,EAAIn8B,IACjBzF,EAAa8hC,EAAIr8B,IACjB,MAAM3F,EAAMzC,EAAK0kC,kBAAkBJ,EAAGv9B,UAAWw9B,EAAGx9B,UAAW09B,EAAG19B,WAClE,OAAOsC,GAASd,OAAO9F,EAC1B,CAQDmE,qBAAqB09B,EAAIC,EAAIE,EAAI3B,GAC7BngC,EAAa2hC,EAAIl8B,IACjBzF,EAAa4hC,EAAIn8B,IACjBzF,EAAa8hC,EAAIr8B,IACjB,MAAM3F,EAAMzC,EAAK2kC,uBAAuBL,EAAGv9B,UAAWw9B,EAAGx9B,UAAW09B,EAAG19B,UAAW+7B,GAClF,OAAOz5B,GAASd,OAAO9F,EAC1B,CAKDmE,kBAAkB+8B,GACd,MAAMJ,EAAOv/B,EAAoB2/B,EAAQ3jC,EAAKwjC,qBACxCC,EAAO9/B,EACPlB,EAAMzC,EAAK4kC,oBAAoBrB,EAAME,GAC3C,OAAe,IAARhhC,OAAYrC,EAAYiJ,GAASd,OAAO9F,EAClD,CAMDmE,uBAAuB+8B,EAAQb,GAC3B,MAAMS,EAAOv/B,EAAoB2/B,EAAQ3jC,EAAKwjC,qBACxCC,EAAO9/B,EACPlB,EAAMzC,EAAK6kC,yBAAyBtB,EAAME,EAAMX,GACtD,OAAe,IAARrgC,OAAYrC,EAAYiJ,GAASd,OAAO9F,EAClD,CAKDmE,sBAAsB6Y,GAClB,MAAM8jB,EAAOv/B,EAAoByb,EAAUzf,EAAKwjC,qBAC1CC,EAAO9/B,EACPlB,EAAMzC,EAAK8kC,wBAAwBvB,EAAME,GAC/C,OAAe,IAARhhC,OAAYrC,EAAYiJ,GAASd,OAAO9F,EAClD,CAMDmE,2BAA2B6Y,EAAUqjB,GACjC,MAAMS,EAAOv/B,EAAoByb,EAAUzf,EAAKwjC,qBAC1CC,EAAO9/B,EACPlB,EAAMzC,EAAK+kC,6BAA6BxB,EAAME,EAAMX,GAC1D,OAAe,IAARrgC,OAAYrC,EAAYiJ,GAASd,OAAO9F,EAClD,CAcD0H,UAAU66B,EAAWC,EAAWC,EAAWvxB,EAAQa,EAAWC,EAAW0wB,EAAW96B,EAAiB3C,EAAQ4C,GACzG3H,EAAaqiC,EAAW58B,IACxBzF,EAAasiC,EAAW77B,IACxBzG,EAAauiC,EAAW98B,IACxBzF,EAAagR,EAAQtK,IACrB1G,EAAa6R,EAAWpM,IACxBzF,EAAa8R,EAAWrL,IACxBzG,EAAawiC,EAAW/8B,IACxB,MAAM3F,EAAMzC,EAAKolC,mBAAmBpkC,KAAK+F,UAAWi+B,EAAUj+B,UAAWk+B,EAAUl+B,UAAWm+B,EAAUn+B,UAAW4M,EAAO5M,UAAWyN,EAAUzN,UAAW0N,EAAU1N,UAAWo+B,EAAUp+B,UAAWsD,EAAiB3C,EAAQ4C,GAC7N,OAAe,IAAR7H,OAAYrC,EAAY4T,GAAgBzL,OAAO9F,EACzD,CASD4iC,gBAAgBL,EAAWC,EAAWtxB,EAAQa,EAAWC,GACrD9R,EAAaqiC,EAAW58B,IACxBzF,EAAasiC,EAAW77B,IACxBzG,EAAagR,EAAQtK,IACrB1G,EAAa6R,EAAWpM,IACxBzF,EAAa8R,EAAWrL,IAExB,OAAe,IADHpJ,EAAKslC,yBAAyBtkC,KAAK+F,UAAWi+B,EAAUj+B,UAAWk+B,EAAUl+B,UAAW4M,EAAO5M,UAAWyN,EAAUzN,UAAW0N,EAAU1N,UAExJ,CAUDw+B,aAAaP,EAAWC,EAAWtxB,EAAQa,EAAWC,EAAWG,GAC7DjS,EAAaqiC,EAAW58B,IACxBzF,EAAasiC,EAAW77B,IACxBzG,EAAagR,EAAQtK,IACrB1G,EAAa6R,EAAWpM,IACxBzF,EAAa8R,EAAWrL,IACxB,MAAM3G,EAAMzC,EAAKwlC,sBAAsBxkC,KAAK+F,UAAWi+B,EAAUj+B,UAAWk+B,EAAUl+B,UAAW4M,EAAO5M,UAAWyN,EAAUzN,UAAW0N,EAAU1N,UAAW6N,GAC7J,OAAe,IAARnS,OAAYrC,EAAY0U,GAAgBvM,OAAO9F,EACzD,CAODgjC,cAAc18B,EAAUC,EAAUY,GAC9BjH,EAAaoG,EAAUX,IACvBzF,EAAaqG,EAAUI,IACvBzG,EAAaiH,EAAOxB,IAEpB,OAAe,IADHpI,EAAK0lC,uBAAuB1kC,KAAK+F,UAAWgC,EAAShC,UAAWiC,EAASjC,UAAW6C,EAAM7C,UAEzG,CAQD4C,aAAaZ,EAAUC,EAAUY,EAAOjC,GACpChF,EAAaoG,EAAUX,IACvBzF,EAAaqG,EAAUI,IACvBzG,EAAaiH,EAAOxB,IACpB,MAAM3F,EAAMzC,EAAK2lC,sBAAsB3kC,KAAK+F,UAAWgC,EAAShC,UAAWiC,EAASjC,UAAW6C,EAAM7C,UAAWY,GAChH,OAAOwN,GAAmB5M,OAAO9F,EACpC,CASDmjC,cAAc78B,EAAUC,EAAUxB,EAASC,EAAQC,GAC/C/E,EAAaoG,EAAUX,IACvBzF,EAAaqG,EAAUI,IACvBzG,EAAa6E,EAASY,IACtBzF,EAAa8E,EAAQW,IAErB,OAAe,IADHpI,EAAK6lC,uBAAuB7kC,KAAK+F,UAAWgC,EAAShC,UAAWiC,EAASjC,UAAWS,EAAQT,UAAWU,EAAOV,UAAWW,EAExI,CAUDN,QAAQ2B,EAAUC,EAAUxB,EAASC,EAAQC,EAAQC,GACjDhF,EAAaoG,EAAUX,IACvBzF,EAAaqG,EAAUI,IACvBzG,EAAa6E,EAASY,IACtBzF,EAAa8E,EAAQW,IAErB,OADYpI,EAAK8lC,iBAAiB9kC,KAAK+F,UAAWgC,EAAShC,UAAWiC,EAASjC,UAAWS,EAAQT,UAAWU,EAAOV,UAAWW,EAAQC,EAE1I,CAUDa,oBAAoBO,EAAUC,EAAUxB,EAASC,EAAQC,EAAQC,GAC7DhF,EAAaoG,EAAUX,IACvBzF,EAAaqG,EAAUI,IACvBzG,EAAa6E,EAASY,IACtBzF,EAAa8E,EAAQW,IACrB,MAAM3F,EAAMzC,EAAK+lC,6BAA6B/kC,KAAK+F,UAAWgC,EAAShC,UAAWiC,EAASjC,UAAWS,EAAQT,UAAWU,EAAOV,UAAWW,EAAQC,GACnJ,OAAe,IAARlF,OAAYrC,EAAYsV,GAAmBnN,OAAO9F,EAC5D,EAGL,MAAMujC,GAA+D,oBAAzBz/B,qBACtC,CAAEC,SAAU,OAAUC,WAAY,QAClC,IAAIF,sBAAqB5E,GAAO3B,EAAKimC,2BAA2BtkC,IAAQ,EAAG,KAE1E,MAAMqS,GAETpN,cAAcjF,GACVA,KAAc,EACd,MAAMhB,EAAMsD,OAAO4C,OAAOmN,GAAgBlN,WAG1C,OAFAnG,EAAIoG,UAAYpF,EAChBqkC,GAA4Bx/B,SAAS7F,EAAKA,EAAIoG,UAAWpG,GAClDA,CACV,CAEDqG,qBACI,MAAMrF,EAAMX,KAAK+F,UAGjB,OAFA/F,KAAK+F,UAAY,EACjBi/B,GAA4Bv/B,WAAWzF,MAChCW,CACV,CAEDsF,OACI,MAAMtF,EAAMX,KAAKgG,qBACjBhH,EAAKimC,2BAA2BtkC,EAAK,EACxC,CAIDgZ,iBAEI,OADY3a,EAAKgiC,eAAehhC,KAAK+F,UAExC,CAID8T,WACI,MAAMpY,EAAMzC,EAAKkmC,yBAAyBllC,KAAK+F,WAC/C,OAAOqB,GAAUG,OAAO9F,EAC3B,CAIDsY,WACI,MAAMtY,EAAMzC,EAAK8a,iCAAiC9Z,KAAK+F,WACvD,OAAOqB,GAAUG,OAAO9F,EAC3B,CAIDwY,UACI,MAAMxY,EAAMzC,EAAKgb,iCAAiCha,KAAK+F,WACvD,OAAOqB,GAAUG,OAAO9F,EAC3B,CAID0Y,UACI,MAAM1Y,EAAMzC,EAAKkb,gCAAgCla,KAAK+F,WACtD,OAAOqB,GAAUG,OAAO9F,EAC3B,EAGL,MAAM0jC,GAA+D,oBAAzB5/B,qBACtC,CAAEC,SAAU,OAAUC,WAAY,QAClC,IAAIF,sBAAqB5E,GAAO3B,EAAKomC,2BAA2BzkC,IAAQ,EAAG,KAE1E,MAAMmT,GAETlO,cAAcjF,GACVA,KAAc,EACd,MAAMhB,EAAMsD,OAAO4C,OAAOiO,GAAgBhO,WAG1C,OAFAnG,EAAIoG,UAAYpF,EAChBwkC,GAA4B3/B,SAAS7F,EAAKA,EAAIoG,UAAWpG,GAClDA,CACV,CAEDqG,qBACI,MAAMrF,EAAMX,KAAK+F,UAGjB,OAFA/F,KAAK+F,UAAY,EACjBo/B,GAA4B1/B,WAAWzF,MAChCW,CACV,CAEDsF,OACI,MAAMtF,EAAMX,KAAKgG,qBACjBhH,EAAKomC,2BAA2BzkC,EAAK,EACxC,CAIDirB,WAEI,OADY5sB,EAAK8b,2CAA2C9a,KAAK+F,UAEpE,CAIDs/B,SACI,MAAM5jC,EAAMzC,EAAKo2B,yBAAyBp1B,KAAK+F,WAC/C,OAAOqB,GAAUG,OAAO9F,EAC3B,CAID6jC,SACI,MAAM7jC,EAAMzC,EAAK21B,iCAAiC30B,KAAK+F,WACvD,OAAOqB,GAAUG,OAAO9F,EAC3B,CAIDwY,UACI,MAAMxY,EAAMzC,EAAK4b,iCAAiC5a,KAAK+F,WACvD,OAAOqB,GAAUG,OAAO9F,EAC3B,CAID0Y,UACI,MAAM1Y,EAAMzC,EAAK0L,8CAA8C1K,KAAK+F,WACpE,OAAOqB,GAAUG,OAAO9F,EAC3B,EAGL,MAAM8jC,GAAyD,oBAAzBhgC,qBAChC,CAAEC,SAAU,OAAUC,WAAY,QAClC,IAAIF,sBAAqB5E,GAAO3B,EAAKwmC,qBAAqB7kC,IAAQ,EAAG,KAIpE,MAAMyG,GAETxB,cAAcjF,GACVA,KAAc,EACd,MAAMhB,EAAMsD,OAAO4C,OAAOuB,GAAUtB,WAGpC,OAFAnG,EAAIoG,UAAYpF,EAChB4kC,GAAsB//B,SAAS7F,EAAKA,EAAIoG,UAAWpG,GAC5CA,CACV,CAEDqG,qBACI,MAAMrF,EAAMX,KAAK+F,UAGjB,OAFA/F,KAAK+F,UAAY,EACjBw/B,GAAsB9/B,WAAWzF,MAC1BW,CACV,CAEDsF,OACI,MAAMtF,EAAMX,KAAKgG,qBACjBhH,EAAKwmC,qBAAqB7kC,EAAK,EAClC,CAKDiF,cACI,MAAMnE,EAAMzC,EAAKymC,iBACjB,OAAOr+B,GAAUG,OAAO9F,EAC3B,CAUDyE,YAAY/E,EAAG+K,GACX,MAAMzK,EAAMzC,EAAK0mC,cAAcvkC,EAAG+K,GAGlC,OAFAlM,KAAK+F,UAAYtE,IAAQ,EACzB8jC,GAAsB//B,SAASxF,KAAMA,KAAK+F,UAAW/F,MAC9CA,IACV,CAKGmB,QAEA,OADYnC,EAAKgiC,eAAehhC,KAAK+F,UAExC,CAKG5E,MAAEA,GACFnC,EAAK2mC,gBAAgB3lC,KAAK+F,UAAW5E,EACxC,CAKG+K,QAEA,OADYlN,EAAKynB,4BAA4BzmB,KAAK+F,UAErD,CAKGmG,MAAEA,GACFlN,EAAK2oB,gCAAgC3nB,KAAK+F,UAAWmG,EACxD,CAKD05B,KACI,MAAMnkC,EAAMzC,EAAK6mC,aAAa7lC,KAAK+F,WACnC,OAAOqB,GAAUG,OAAO9F,EAC3B,CAKDqkC,KACI,MAAMrkC,EAAMzC,EAAK+mC,aAAa/lC,KAAK+F,WACnC,OAAOqB,GAAUG,OAAO9F,EAC3B,EAmNLukC,eAAeC,GAAWC,GACtB,QAAa9mC,IAATJ,EAAoB,OAAOA,OAGD,IAAnBknC,IACHjjC,OAAOkjC,eAAeD,KAAoBjjC,OAAO6C,YAC/CogC,kBAAkBA,GAEpBE,QAAQC,KAAK,mGAIS,IAAnBH,IACPA,EAAiB,IAAII,IAAI,wBAAyB,cAEtD,MAAMC,EAhMV,WACI,MAAMA,EAAU,CAChBA,IAAc,IAiId,OAhIAA,EAAQC,IAAIC,4BAA8B,SAASC,EAAMC,EAAMC,EAAMC,GAEjE,OAAOnnC,EADKL,EAAUqnC,GAAMI,KAAKznC,EAAUsnC,GAAOtnC,EAAUunC,GAAOvnC,EAAUwnC,IAErF,EACIN,EAAQC,IAAIO,8BAAgC,SAASL,GAEjD,OAAOhnC,EADKL,EAAUqnC,GAAM1lC,OAEpC,EACIulC,EAAQC,IAAIQ,4BAA8B,WAAa,OAAOpnC,GAAY,SAAU8mC,EAAMC,GAEtF,OAAOjnC,EADKL,EAAUqnC,GAAMO,KAAK5nC,EAAUsnC,IAEnD,GAAOO,UAAU,EACbX,EAAQC,IAAIW,4BAA8B,WAAa,OAAOvnC,GAAY,SAAU8mC,EAAMC,EAAMC,GAE5F,OAAOlnC,EADKL,EAAUqnC,GAAMO,KAAK5nC,EAAUsnC,GAAOtnC,EAAUunC,IAEpE,GAAOM,UAAU,EACbX,EAAQC,IAAIY,4BAA8B,WAAa,OAAOxnC,GAAY,SAAU8mC,EAAMC,EAAMC,EAAMC,GAElG,OAAOnnC,EADKL,EAAUqnC,GAAMO,KAAK5nC,EAAUsnC,GAAOtnC,EAAUunC,GAAOvnC,EAAUwnC,IAErF,GAAOK,UAAU,EACbX,EAAQC,IAAIa,4BAA8B,WAAa,OAAOznC,GAAY,SAAU8mC,EAAMC,EAAMC,EAAMC,EAAMS,GAExG,OAAO5nC,EADKL,EAAUqnC,GAAMO,KAAK5nC,EAAUsnC,GAAOtnC,EAAUunC,GAAOvnC,EAAUwnC,GAAOxnC,EAAUioC,IAEtG,GAAOJ,UAAU,EACbX,EAAQC,IAAIe,8BAAgC,SAASb,GAEjD,OADYrnC,EAAUqnC,GAAMjnC,MAEpC,EACI8mC,EAAQC,IAAIgB,8BAAgC,SAASd,GAEjD,OADYrnC,EAAUqnC,GAAMjnC,MAEpC,EACI8mC,EAAQC,IAAIiB,2BAA6B,SAASf,GAE9C,OAAOhnC,EADK,IAAIoB,WAAWzB,EAAUqnC,IAE7C,EACIH,EAAQC,IAAIkB,iCAAmC,SAAShB,EAAMC,GAE1D,OAAOjnC,EADK,IAAIioC,SAASjnC,EAAmBgmC,EAAMC,IAE1D,EACIJ,EAAQC,IAAIoB,kDAAoD,SAASlB,EAAMC,EAAMC,GAEjF,OAAOlnC,EADK,IAAIoB,WAAWzB,EAAUqnC,GAAOC,IAAS,EAAGC,IAAS,GAEzE,EACIL,EAAQC,IAAIqB,kDAAoD,SAASnB,EAAMC,EAAMC,GAEjF,OAAOlnC,EADK,IAAI4C,aAAajD,EAAUqnC,GAAOC,IAAS,EAAGC,IAAS,GAE3E,EACIL,EAAQC,IAAIsB,qCAAuC,SAASpB,GAExD,OAAOhnC,EADK,IAAI4C,aAAaokC,IAAS,GAE9C,EACIH,EAAQC,IAAIuB,2BAA6B,SAASrB,GAE9C,OADYrnC,EAAUqnC,GAAMsB,KAEpC,EACIzB,EAAQC,IAAIyB,mCAAqC,SAASvB,GAEtD,OAAOhnC,EADKL,EAAUqnC,GAAMwB,YAEpC,EACI3B,EAAQC,IAAI2B,+BAAiC,SAASzB,GAElD,OAAOhnC,EADK6a,EAAqBhT,OAAOm/B,GAEhD,EACIH,EAAQC,IAAI4B,qCAAuC,SAAS1B,GAExD,OAAOhnC,EADKgI,GAA2BH,OAAOm/B,GAEtD,EACIH,EAAQC,IAAI6B,2BAA6B,SAAS3B,EAAMC,EAAMC,GAC1DvnC,EAAUqnC,GAAM3jC,IAAI1D,EAAUsnC,GAAOC,IAAS,EACtD,EACIL,EAAQC,IAAI8B,2BAA6B,SAAS5B,EAAMC,EAAMC,GAC1DvnC,EAAUqnC,GAAM3jC,IAAI1D,EAAUsnC,GAAOC,IAAS,EACtD,EACIL,EAAQC,IAAI+B,8CAAgD,WACxD,MAAM9mC,EAAwB,oBAAX+mC,OAAyB,KAAOA,OACnD,OAAOtnC,EAAWO,GAAO,EAAI/B,EAAc+B,EACnD,EACI8kC,EAAQC,IAAIiC,mDAAqD,WAC7D,MAAMhnC,EAA4B,oBAAfinC,WAA6B,KAAOA,WACvD,OAAOxnC,EAAWO,GAAO,EAAI/B,EAAc+B,EACnD,EACI8kC,EAAQC,IAAImC,4CAA8C,WACtD,MAAMlnC,EAAsB,oBAATmnC,KAAuB,KAAOA,KACjD,OAAO1nC,EAAWO,GAAO,EAAI/B,EAAc+B,EACnD,EACI8kC,EAAQC,IAAIqC,8CAAgD,WACxD,MAAMpnC,EAAwB,oBAAXqnC,OAAyB,KAAOA,OACnD,OAAO5nC,EAAWO,GAAO,EAAI/B,EAAc+B,EACnD,EACI8kC,EAAQC,IAAIuC,uBAAyB,SAASrC,GAC1C,MAAMsC,EAAI3pC,EAAUqnC,GAEpB,MAD0B,kBAAP,EAAoBsC,EAAI,EAAI,EAAK,CAE5D,EACIzC,EAAQC,IAAIyC,uBAAyB,SAASvC,GAE1C,MADwC,mBAArBrnC,EAAUqnC,EAErC,EACIH,EAAQC,IAAI0C,wBAA0B,SAASxC,GAE3C,YADgCtnC,IAApBC,EAAUqnC,EAE9B,EACIH,EAAQC,IAAI2C,kBAAoB,WAE5B,OAAOzpC,EADKV,EAAK+B,OAEzB,EACIwlC,EAAQC,IAAI4C,sBAAwB,SAAS1C,EAAMC,GAC/C,MAAMhnC,EAAMN,EAAUsnC,GAChBllC,EAAsB,iBAAhB,EAA2B9B,OAAMP,EAC7CiC,IAAqBgoC,WAAW3C,EAAO,EAAOxlC,EAAWO,GAAO,EAAIA,GAAK,GACzEJ,IAAqBioC,SAAS5C,EAAO,GAAQxlC,EAAWO,IAAM,EACtE,EACI8kC,EAAQC,IAAI+C,sBAAwB,SAAS7C,GAEzC,OAAOhnC,EADKgnC,EAEpB,EACIH,EAAQC,IAAIgD,4BAA8B,SAAS9C,GAE/C,OAAOhnC,EADKL,EAAUqnC,GAE9B,EACIH,EAAQC,IAAIiD,2BAA6B,SAAS/C,GAC9CllC,EAAWklC,EACnB,EACIH,EAAQC,IAAIkD,iBAAmB,SAAShD,EAAMC,GAC1C,MAAM,IAAInmC,MAAME,EAAmBgmC,EAAMC,GACjD,EAEWJ,CACX,CA4DoBoD,IAEc,iBAAnBzD,GAAmD,mBAAZ0D,SAA0B1D,aAA0B0D,SAA4B,mBAARtD,KAAsBJ,aAA0BI,OACtKJ,EAAiB2D,MAAM3D,IAK3B,MAAMtkC,SAAEA,EAAQkoC,OAAEA,SAvOtB9D,eAA0B8D,EAAQvD,GAC9B,GAAwB,mBAAbwD,UAA2BD,aAAkBC,SAAU,CAC9D,GAAgD,mBAArCC,YAAYC,qBACnB,IACI,aAAaD,YAAYC,qBAAqBH,EAAQvD,EASzD,CAPC,MAAOtmC,GACL,GAA0C,oBAAtC6pC,EAAOI,QAAQC,IAAI,gBAInB,MAAMlqC,EAHNmmC,QAAQC,KAAK,oMAAqMpmC,EAKzN,CAGL,MAAMmqC,QAAcN,EAAOO,cAC3B,aAAaL,YAAYM,YAAYF,EAAO7D,EAEpD,CAAW,CACH,MAAM3kC,QAAiBooC,YAAYM,YAAYR,EAAQvD,GAEvD,OAAI3kC,aAAoBooC,YAAYO,SACzB,CAAE3oC,WAAUkoC,UAGZloC,CAEd,CACL,CA0MuC4oC,OAAiBtE,EAAgBK,GAEpE,OAhEJ,SAA6B3kC,EAAUkoC,GAWnC,OAVA9qC,EAAO4C,EAAS6oC,QAChBxE,GAAWyE,uBAAyBZ,EACpC1oC,EAAwB,KACxBgB,EAA4B,KAC5BH,EAA0B,KAC1BO,EAA2B,KAC3B/B,EAA0B,KAInBzB,CACX,CAoDW2rC,CAAoB/oC,EAAUkoC,EACzC,OC51Kac,GAIT1kC,YAAY/E,EAAW+K,GACnBlM,KAAKmB,EAAIA,EACTnB,KAAKkM,EAAIA,CACZ,QAGQ2+B,GACFjlC,WAAWzE,EAAW+K,GACzB,OAAO,IAAI0+B,GAAQzpC,EAAG+K,EACzB,CAEMtG,eACH,OAAOilC,GAAUC,IAAI,EAAK,EAC7B,CAGMllC,eAAemlC,GAClB,IAAKA,EAAK,OAAO,KAEjB,IAAIC,EAAMH,GAAUC,IAAIC,EAAI5pC,EAAG4pC,EAAI7+B,GAEnC,OADA6+B,EAAI9kC,OACG+kC,CACV,CAEMplC,eAAeojC,GAClB,OAAO,IAAI5hC,GAAU4hC,EAAE7nC,EAAG6nC,EAAE98B,EAC/B,CAEMtG,YAAYqlC,EAAaC,GAC5BD,EAAI9pC,EAAI+pC,EAAM/pC,EACd8pC,EAAI/+B,EAAIg/B,EAAMh/B,CACjB,QAQQi/B,GACFvlC,kBACH,OAAO,CACV,CAEMA,eAAemlC,GAClB,IAAKA,EAAK,OAAO,KAEjB,IAAIC,EAAMD,EAAIx+B,MAEd,OADAw+B,EAAI9kC,OACG+kC,CACV,CAEMplC,eAAe2G,GAClB,OAAOnE,GAAYgjC,UAAU7+B,EAChC,MCxDO8+B,GCeAC,GAQAC,GAoBAC,GCjDAC,GCNAC,GCwbAC,GA0BAC,GC7bAC,GCdAC,GCLAC,GAOAC,GCSAC,GCsBAC,GAmiCAC,IT/jCZ,SAAYd,GAIRA,EAAAA,EAAA,QAAA,GAAA,UAIAA,EAAAA,EAAA,MAAA,GAAA,QASAA,EAAAA,EAAA,uBAAA,GAAA,yBASAA,EAAAA,EAAA,uBAAA,GAAA,wBACH,CA3BD,CAAYA,KAAAA,GA2BX,CAAA,UAKYe,GAUTlmC,YACImmC,EACAC,EACA/hC,GAEAvK,KAAKqsC,OAASA,EACdrsC,KAAKssC,YAAcA,EACnBtsC,KAAKuK,OAASA,CACjB,CAGMgiC,wBAAwBD,GAC3BtsC,KAAKssC,YAAcA,CACtB,CAMME,UACH,OAAOxsC,KAAKqsC,OAAOz0B,SAAS5X,KAAKuK,OACpC,CAQMkiC,iBAAiBjU,EAAiBvf,GACrC,OAAOjZ,KAAKqsC,OAAO9T,mBAAmBv4B,KAAKuK,OAAQiuB,EAAQvf,EAC9D,CAQMyzB,cAAclU,EAAiBvf,GAClC,OAAOjZ,KAAKqsC,OAAOvT,gBAAgB94B,KAAKuK,OAAQiuB,EAAQvf,EAC3D,CAUM0zB,uBACHC,EACAC,EACA5zB,GAEA,OAAOjZ,KAAKqsC,OAAO3T,yBACf14B,KAAKuK,OACLqiC,EACAC,EACA5zB,EAEP,CAUM6zB,qBACHF,EACAC,EACA5zB,GAEAjZ,KAAK2sC,uBAAuBC,EAASA,EAAS3zB,EACjD,CAOMgnB,iBACH,OAAOjgC,KAAKqsC,OAAOrT,iBAAiBh5B,KAAKuK,OAC5C,CAOMwiC,kBAAkB5T,GACrBn5B,KAAKqsC,OAAOnT,oBAAoBl5B,KAAKuK,OAAQ4uB,EAChD,CAOM6T,6BACH,OAAOhtC,KAAKqsC,OAAOhO,6BAA6Br+B,KAAKuK,OACxD,CAaM0iC,8BAA8BzO,GACjCx+B,KAAKqsC,OAAO9N,gCAAgCv+B,KAAKuK,OAAQi0B,EAC5D,CAOM0O,UAAU18B,GACbxQ,KAAKqsC,OAAOhT,YAAYr5B,KAAKuK,OAAQiG,EACxC,CAQM28B,qBAAqBvhB,GACxB5rB,KAAKqsC,OAAO9S,uBAAuBv5B,KAAKuK,OAAQqhB,EACnD,CAQMwhB,oBACH,OAAOptC,KAAKqsC,OAAOtR,oBAAoB/6B,KAAKuK,OAC/C,CAKMwN,cACH,IAAIizB,EAAMhrC,KAAKqsC,OAAOtW,cAAc/1B,KAAKuK,QACzC,OAAOsgC,GAAUwC,QAAQrC,EAC5B,CAKMhzB,WACH,IAAIgzB,EAAMhrC,KAAKqsC,OAAOpW,WAAWj2B,KAAKuK,QACtC,OAAO4gC,GAAYkC,QAAQrC,EAC9B,CASMsC,kBACH,IAAItC,EAAMhrC,KAAKqsC,OAAO5V,kBAAkBz2B,KAAKuK,QAC7C,OAAOsgC,GAAUwC,QAAQrC,EAC5B,CASMuC,eACH,IAAIvC,EAAMhrC,KAAKqsC,OAAO1V,eAAe32B,KAAKuK,QAC1C,OAAO4gC,GAAYkC,QAAQrC,EAC9B,CASMwC,eAAeC,EAAax0B,GAE/BjZ,KAAKqsC,OAAOxV,iBAAiB72B,KAAKuK,OAAQkjC,EAAItsC,EAAGssC,EAAIvhC,EAAG+M,EAE3D,CAQMy0B,UAAUC,EAAa10B,GAC1B,IAAI20B,EAAS/C,GAAUgD,QAAQF,GAC/B3tC,KAAKqsC,OAAOpV,YAAYj3B,KAAKuK,OAAQqjC,EAAQ30B,GAC7C20B,EAAO3nC,MACV,CAMMo5B,eACH,OAAOr/B,KAAKqsC,OAAOxP,eAAe78B,KAAKuK,OAC1C,CAUMujC,gBAAgB/oB,EAAgB9L,GACnCjZ,KAAKqsC,OAAOtP,kBAAkB/8B,KAAKuK,OAAQwa,EAAQ9L,EACtD,CAWM80B,YAAYxhC,EAAe0M,GAC9BjZ,KAAKqsC,OAAOtV,cAAc/2B,KAAKuK,OAAQgC,EAAO0M,EACjD,CAQM+0B,UAAUL,EAAa10B,GAC1BjZ,KAAKqsC,OAAOjV,YAAYp3B,KAAKuK,OAAQojC,EAAK10B,EAC7C,CAeMg1B,4BAA4BC,GAE/BluC,KAAKqsC,OAAO9U,8BAA8Bv3B,KAAKuK,OAAQ2jC,EAAE/sC,EAAG+sC,EAAEhiC,EAEjE,CAeMiiC,yBAAyB5hC,GAC5BvM,KAAKqsC,OAAO5U,2BAA2Bz3B,KAAKuK,OAAQgC,EACvD,CAOM2qB,SACH,OAAO2T,GAAUwC,QAAQrtC,KAAKqsC,OAAOpU,SAASj4B,KAAKuK,QACtD,CAKM6jC,gBAAgBxlC,GACnB,MAAMylC,EAAWxD,GAAUgD,QAAQjlC,GACnC,IAAI0lC,EAASzD,GAAUwC,QACnBrtC,KAAKqsC,OAAOhU,kBAAkBr4B,KAAKuK,OAAQ8jC,IAG/C,OADAA,EAASpoC,OACFqoC,CACV,CAOMjX,SACH,OAAOr3B,KAAKqsC,OAAOlU,SAASn4B,KAAKuK,OACpC,CAOM6M,OACH,OAAOpX,KAAKqsC,OAAO5S,OAAOz5B,KAAKuK,OAClC,CAKMgkC,mBACH,OAAO1D,GAAUwC,QAAQrtC,KAAKqsC,OAAOxS,mBAAmB75B,KAAKuK,QAChE,CAOMikC,UACH,OAAOxuC,KAAKqsC,OAAO1S,UAAU35B,KAAKuK,OACrC,CAKMkkC,WACH,OAAO5D,GAAUwC,QAAQrtC,KAAKqsC,OAAOtS,WAAW/5B,KAAKuK,QACxD,CAKMmkC,WACH,OAAO7D,GAAUwC,QAAQrtC,KAAKqsC,OAAOpS,WAAWj6B,KAAKuK,QACxD,CAQMokC,0BACH,OAAO3uC,KAAKqsC,OAAOlS,0BAA0Bn6B,KAAKuK,OACrD,CASMqkC,mBACH,OAAO5uC,KAAKqsC,OAAOhS,mBAAmBr6B,KAAKuK,OAC9C,CAWMskC,+BACH,OAAO7uC,KAAKqsC,OAAO9R,+BAA+Bv6B,KAAKuK,OAC1D,CAUMukC,0BACH,OAAO9uC,KAAKqsC,OAAO5R,0BAA0Bz6B,KAAKuK,OACrD,CAYMwkC,QACH/uC,KAAKqsC,OAAOlW,QAAQn2B,KAAKuK,OAC5B,CAWM0O,SACHjZ,KAAKqsC,OAAO1R,SAAS36B,KAAKuK,OAC7B,CAKMykC,eACH,OAAOhvC,KAAKqsC,OAAOxR,eAAe76B,KAAKuK,OAC1C,CAKM0kC,eACH,OAAOjvC,KAAKqsC,OAAOpR,eAAej7B,KAAKuK,OAC1C,CAQM2kC,SAAShzB,GACZ,OAAOlc,KAAKssC,YAAYnC,IAAInqC,KAAKqsC,OAAOlR,WAAWn7B,KAAKuK,OAAQ2R,GACnE,CAOMizB,WAAW3+B,GACdxQ,KAAKqsC,OAAO5P,aAAaz8B,KAAKuK,OAAQiG,EACzC,CAKM4+B,YACH,OAAOpvC,KAAKqsC,OAAO1P,YAAY38B,KAAKuK,OACvC,CAKM8kC,WACH,OAAOrvC,KAAKqsC,OAAO/Q,WAAWt7B,KAAKuK,OACtC,CAKM+kC,YAAYC,EAAqBt2B,GACpC,OAAOjZ,KAAKqsC,OAAO7Q,cACfx7B,KAAKuK,OACLglC,EACAt2B,EAEP,CAKMu2B,aACH,OAAOxvC,KAAKqsC,OAAOhW,aAAar2B,KAAKuK,OACxC,CAKMklC,WACH,OAAOzvC,KAAKqsC,OAAO9V,WAAWv2B,KAAKuK,OACtC,CAKMmlC,UACH,OAAO1vC,KAAKqsC,OAAO1Q,UAAU37B,KAAKuK,OACrC,CAKMolC,cACH,OAAO3vC,KAAKqsC,OAAOxQ,cAAc77B,KAAKuK,OACzC,CAKMqlC,YACH,OAAO5vC,KAAKqsC,OAAOtQ,YAAY/7B,KAAKuK,OACvC,CAKMm1B,gBACH,OAAO1/B,KAAKqsC,OAAOpQ,gBAAgBj8B,KAAKuK,OAC3C,CAKMo1B,iBACH,OAAO3/B,KAAKqsC,OAAOlQ,iBAAiBn8B,KAAKuK,OAC5C,CAOMslC,iBAAiB9qB,GACpB/kB,KAAKqsC,OAAOhQ,mBAAmBr8B,KAAKuK,OAAQwa,EAC/C,CAKM+qB,uCACH9vC,KAAKqsC,OAAO1U,uCACR33B,KAAKuK,OACLvK,KAAKssC,YAAYvB,IAExB,CAqBMgF,kBAAkB34B,EAAc6B,GACnCjZ,KAAKqsC,OAAOxU,oBAAoB73B,KAAKuK,OAAQ6M,EAAM6B,EACtD,CAoBM+2B,4BACH54B,EACAG,EACAC,EACAyB,GAEA,IAAIg3B,EAASpF,GAAUgD,QAAQt2B,GAC/BvX,KAAKqsC,OAAOtU,8BACR/3B,KAAKuK,OACL6M,EACA64B,EACAz4B,EACAyB,GAEJg3B,EAAOhqC,MACV,CASMiqC,kBAAkBnrB,GACrB/kB,KAAKqsC,OAAO9P,oBAAoBv8B,KAAKuK,OAAQwa,EAChD,CAOMorB,YAAYl3B,GACfjZ,KAAKqsC,OAAOpP,cAAcj9B,KAAKuK,OAAQ0O,EAC1C,CAOMm3B,aAAan3B,GAChBjZ,KAAKqsC,OAAOlP,eAAen9B,KAAKuK,OAAQ0O,EAC3C,CAQMo3B,SAAS/S,EAAerkB,GAC3B,MAAMq3B,EAAWzF,GAAUgD,QAAQvQ,GACnCt9B,KAAKqsC,OAAOhP,WAAWr9B,KAAKuK,OAAQ+lC,EAAUr3B,GAC9Cq3B,EAASrqC,MACZ,CAQMsqC,aAAa9S,EAAiBxkB,GACjC,MAAMu3B,EAAa3F,GAAUgD,QAAQpQ,GACrCz9B,KAAKqsC,OAAO7O,eAAex9B,KAAKuK,OAAQimC,EAAYv3B,GACpDu3B,EAAWvqC,MACd,CASMwqC,UAAU7S,EAAgB3kB,GAC7BjZ,KAAKqsC,OAAO1O,YAAY39B,KAAKuK,OAAQqzB,EAAQ3kB,EAChD,CAYMy3B,mBAAmBC,EAAuB13B,GAC7CjZ,KAAKqsC,OAAOvO,qBAAqB99B,KAAKuK,OAAQomC,EAAe13B,EAChE,CAYM23B,gBAAgBtT,EAAe10B,EAAeqQ,GACjD,MAAMq3B,EAAWzF,GAAUgD,QAAQvQ,GAC7B+Q,EAAWxD,GAAUgD,QAAQjlC,GACnC5I,KAAKqsC,OAAOpO,kBAAkBj+B,KAAKuK,OAAQ+lC,EAAUjC,EAAUp1B,GAC/Dq3B,EAASrqC,OACTooC,EAASpoC,MACZ,CASM4qC,oBACHpT,EACA70B,EACAqQ,GAEA,MAAMu3B,EAAa3F,GAAUgD,QAAQpQ,GAC/B4Q,EAAWxD,GAAUgD,QAAQjlC,GACnC5I,KAAKqsC,OAAOlO,sBACRn+B,KAAKuK,OACLimC,EACAnC,EACAp1B,GAEJu3B,EAAWvqC,OACXooC,EAASpoC,MACZ,CAMM6qC,YACH,OAAOjG,GAAUwC,QAAQrtC,KAAKqsC,OAAOtN,YAAY/+B,KAAKuK,QACzD,CAOMwmC,aACH,OAAO/wC,KAAKqsC,OAAOpN,aAAaj/B,KAAKuK,OACxC,QAKQymC,GA2BT9qC,YAAYu1B,GACRz7B,KAAKwQ,SAAU,EACfxQ,KAAKy7B,OAASA,EACdz7B,KAAK+X,YAAc8yB,GAAUoG,QAC7BjxC,KAAKgY,SAAWmzB,GAAY+F,WAC5BlxC,KAAKq/B,aAAe,EACpBr/B,KAAKk3B,OAAS2T,GAAUoG,QACxBjxC,KAAKoX,KAAO,EACZpX,KAAKs/B,UAAW,EAChBt/B,KAAKuX,aAAeszB,GAAUoG,QAC9BjxC,KAAKmxC,sBAAuB,EAC5BnxC,KAAKoxC,sBAAuB,EAE5BpxC,KAAKq3B,OAAS,EACdr3B,KAAKwX,wBAA0B,EAC/BxX,KAAKy/B,kBAAmB,EAExBz/B,KAAK0/B,cAAgB,EACrB1/B,KAAK2/B,eAAiB,EACtB3/B,KAAK6/B,UAAW,EAChB7/B,KAAK8/B,UAAW,EAChB9/B,KAAKggC,YAAa,EAClBhgC,KAAKotC,kBAAoB,EACzBptC,KAAKigC,eAAiB,EACtBjgC,KAAKgtC,2BAA6B,CACrC,CAKMpnC,iBACH,OAAO,IAAIorC,GAAc3F,GAAclnC,QAC1C,CAKMyB,gCACH,OAAO,IAAIorC,GAAc3F,GAAcjnC,uBAC1C,CAKMwB,gCACH,OAAO,IAAIorC,GAAc3F,GAAchnC,uBAC1C,CAKMuB,eACH,OAAO,IAAIorC,GAAc3F,GAAcznC,MAC1C,CAOMgC,oBACH,OAAO,IAAIorC,GAAc3F,GAAclnC,QAC1C,CAOMyB,mCACH,OAAO,IAAIorC,GAAc3F,GAAcjnC,uBAC1C,CAOMwB,mCACH,OAAO,IAAIorC,GAAc3F,GAAchnC,uBAC1C,CAOMuB,mBACH,OAAO,IAAIorC,GAAc3F,GAAcznC,MAC1C,CAEMmpC,kBAAkB5T,GAErB,OADAn5B,KAAKigC,eAAiB9G,EACfn5B,IACV,CAaMitC,8BAA8BzO,GAEjC,OADAx+B,KAAKgtC,2BAA6BxO,EAC3Bx+B,IACV,CAMMmvC,WAAW3+B,GAEd,OADAxQ,KAAKwQ,QAAUA,EACRxQ,IACV,CAMMwtC,eAAersC,EAAW+K,GAC7B,GAAgB,iBAAL/K,GAA6B,iBAAL+K,EAC/B,MAAMmlC,UAAU,+CAGpB,OADArxC,KAAK+X,YAAc,CAAC5W,EAAGA,EAAG+K,EAAGA,GACtBlM,IACV,CAUM+tC,YAAYuD,GAIf,OAFAtxC,KAAKgY,SAAWs5B,EAETtxC,IACV,CASM8tC,gBAAgB1K,GAEnB,OADApjC,KAAKq/B,aAAe+D,EACbpjC,IACV,CAOM+vC,kBAAkB34B,GAGrB,OAFApX,KAAKoX,KAAOA,EACZpX,KAAKs/B,UAAW,EACTt/B,IACV,CASM0tC,UAAUvsC,EAAW+K,GACxB,GAAgB,iBAAL/K,GAA6B,iBAAL+K,EAC/B,MAAMmlC,UAAU,0CAGpB,OADArxC,KAAKk3B,OAAS,CAAC/1B,EAAGA,EAAG+K,EAAGA,GACjBlM,IACV,CAOMguC,UAAUL,GAEb,OADA3tC,KAAKq3B,OAASsW,EACP3tC,IACV,CAkBMgwC,4BACH54B,EACAG,EACAC,GAMA,OAJAxX,KAAKoX,KAAOA,EACZyzB,GAAU0G,KAAKvxC,KAAKuX,aAAcA,GAClCvX,KAAKwX,wBAA0BA,EAC/BxX,KAAKs/B,UAAW,EACTt/B,IACV,CAOMwxC,oBACHL,EACAC,GAIA,OAFApxC,KAAKmxC,qBAAuBA,EAC5BnxC,KAAKoxC,qBAAuBA,EACrBpxC,IACV,CAQM8sC,qBACHqE,EACAC,GAEA,OAAOpxC,KAAKwxC,oBACRL,EACAC,EAEP,CAMM3E,mBACH,OAAOzsC,KAAK8sC,sBAAqB,GAAO,EAC3C,CAMMJ,gBAEH,OADA1sC,KAAKy/B,kBAAmB,EACjBz/B,IACV,CAaM6vC,iBAAiBpuB,GAEpB,OADAzhB,KAAK0/B,cAAgBje,EACdzhB,IACV,CAUMkwC,kBAAkBzuB,GAErB,OADAzhB,KAAK2/B,eAAiBle,EACfzhB,IACV,CAOMyxC,YAAYC,GAEf,OADA1xC,KAAK6/B,SAAW6R,EACT1xC,IACV,CAOD2xC,YAAY7R,GAER,OADA9/B,KAAK8/B,SAAWA,EACT9/B,IACV,CAOM4xC,cAAcphC,GAEjB,OADAxQ,KAAKggC,WAAaxvB,EACXxQ,IACV,CAcMmtC,qBAAqBvhB,GAExB,OADA5rB,KAAKotC,kBAAoBxhB,EAClB5rB,IACV,CAOM6xC,YAAYhT,GAEf,OADA7+B,KAAK8xC,SAAWjT,EACT7+B,IACV,QU9qCQ+xC,GAMT7rC,cACIlG,KAAKgyC,MAAQ,IAAIC,aAAa,GAC9BjyC,KAAKkyC,MAAQ,IAAIxvC,YAAY1C,KAAKgyC,MAAMhxC,QACxChB,KAAK6+B,KAAO,IAAI3/B,MAChBc,KAAKmyC,KAAO,CACf,CAEMpvC,IAAIwH,EAAgBs0B,GACvB,IAAI3iB,EAAIlc,KAAKoyC,MAAM7nC,GACnB,KAAOvK,KAAK6+B,KAAKp/B,QAAUyc,GACvBlc,KAAK6+B,KAAKt/B,KAAK,MAGC,MAAhBS,KAAK6+B,KAAK3iB,KAAYlc,KAAKmyC,MAAQ,GACvCnyC,KAAK6+B,KAAK3iB,GAAK2iB,CAClB,CAEMj+B,MACH,OAAOZ,KAAKmyC,IACf,CAEME,OAAO9nC,GACV,IAAI2R,EAAIlc,KAAKoyC,MAAM7nC,GACf2R,EAAIlc,KAAK6+B,KAAKp/B,SACM,MAAhBO,KAAK6+B,KAAK3iB,KAAYlc,KAAKmyC,MAAQ,GACvCnyC,KAAK6+B,KAAK3iB,GAAK,KAEtB,CAEMgF,QACHlhB,KAAK6+B,KAAO,IAAI3/B,KACnB,CAEMirC,IAAI5/B,GACP,IAAI2R,EAAIlc,KAAKoyC,MAAM7nC,GACnB,OAAI2R,EAAIlc,KAAK6+B,KAAKp/B,OACPO,KAAK6+B,KAAK3iB,GAEV,IAEd,CAEMo2B,QAAQzyC,GACX,IAAK,MAAM0yC,KAAOvyC,KAAK6+B,KACR,MAAP0T,GAAa1yC,EAAE0yC,EAE1B,CAEMC,SACH,OAAOxyC,KAAK6+B,KAAK4T,QAAQF,GAAe,MAAPA,GACpC,CAEOH,MAAM7nC,GASV,OADAvK,KAAKgyC,MAAM,GAAKznC,EACTvK,KAAKkyC,MAAM,EACrB,QChDQQ,GAmBTxsC,YAAY6kC,GACR/qC,KAAK+qC,IAAMA,GAAO,IAAI7jC,GACtBlH,KAAK2yC,IAAM,IAAIZ,GAEXhH,GACAA,EAAIzK,wBAAwB/1B,IACxBvK,KAAK2yC,IAAI5vC,IAAIwH,EAAQ,IAAI6hC,GAAUrB,EAAK,KAAMxgC,GAAQ,GAGjE,CArBMtE,OACGjG,KAAK+qC,KACP/qC,KAAK+qC,IAAI9kC,OAEbjG,KAAK+qC,SAAM3rC,EAELY,KAAK2yC,KACP3yC,KAAK2yC,IAAIzxB,QAEblhB,KAAK2yC,SAAMvzC,CACd,CAgBMmtC,wBAAwBD,GAC3BtsC,KAAK2yC,IAAIL,SAASM,GAAOA,EAAGrG,wBAAwBD,IACvD,CAOMlN,gBACHkN,EACAuG,GAEA,IAAIC,EAASjI,GAAUgD,QAAQgF,EAAK96B,aAChCg7B,EAAS5H,GAAY0C,QAAQgF,EAAK76B,UAClCg7B,EAAQnI,GAAUgD,QAAQgF,EAAK3b,QAC/B+Y,EAASpF,GAAUgD,QAAQgF,EAAKt7B,cAGhChN,EAASvK,KAAK+qC,IAAI3L,gBAClByT,EAAKriC,QACLsiC,EACAC,EACAF,EAAKxT,aACLwT,EAAKz7B,KACLy7B,EAAKvT,SACL2Q,EACA+C,EAEAH,EAAKxb,OACLwb,EAAKr7B,wBACLq7B,EAAK1B,qBACL0B,EAAKzB,qBACLyB,EAAKpT,iBAELoT,EAAKnT,cACLmT,EAAKlT,eACLkT,EAAKpX,OACLoX,EAAKhT,SACLgT,EAAK/S,SACL+S,EAAKzF,kBACLyF,EAAK7S,WACL6S,EAAK5S,eACL4S,EAAK7F,4BAGT8F,EAAO7sC,OACP8sC,EAAO9sC,OACP+sC,EAAM/sC,OACNgqC,EAAOhqC,OAGP,MAAMkgB,EAAO,IAAIimB,GAAUpsC,KAAK+qC,IAAKuB,EAAa/hC,GAKlD,OAJA4b,EAAK2rB,SAAWe,EAAKf,SAErB9xC,KAAK2yC,IAAI5vC,IAAIwH,EAAQ4b,GAEdA,CACV,CAYMpN,OACHxO,EACAyO,EACAzS,EACA0sC,EACAC,GAGA,IAAK,IAAIh3B,EAAI,EAAGA,EAAIlc,KAAK+qC,IAAI9P,eAAe1wB,GAAS2R,GAAK,EACtD3V,EAAU4sC,MAAMnzC,KAAK+qC,IAAI5P,WAAW5wB,EAAQ2R,IAGhD+2B,EAAcG,sCAAsC7oC,GAASA,GACzD0oC,EAAcE,MAAM5oC,KAExB2oC,EAAgBE,sCACZ7oC,GACCA,GAAW2oC,EAAgBC,MAAM5oC,KAItCvK,KAAK+qC,IAAIhyB,OACLxO,EACAyO,EAAQ+xB,IACRxkC,EAAUwkC,IACVkI,EAAclI,IACdmI,EAAgBnI,KAEpB/qC,KAAK2yC,IAAIN,OAAO9nC,EACnB,CAKM3J,MACH,OAAOZ,KAAK2yC,IAAI/xC,KACnB,CAOMgX,SAASrN,GACZ,OAA2B,MAApBvK,KAAKmqC,IAAI5/B,EACnB,CAOM4/B,IAAI5/B,GACP,OAAOvK,KAAK2yC,IAAIxI,IAAI5/B,EACvB,CAOM+nC,QAAQzyC,GACXG,KAAK2yC,IAAIL,QAAQzyC,EACpB,CASMwzC,uBACHr6B,EACAnZ,GAEAmZ,EAAQ+P,8BAA8Bxe,IAClC1K,EAAEG,KAAKmqC,IAAI5/B,GAAQ,GAE1B,CAOMioC,SACH,OAAOxyC,KAAK2yC,IAAIH,QACnB,QCjNQc,GAGTptC,YAAY6kC,GACR/qC,KAAK+qC,IAAMA,GAAO,IAAIrrB,EACzB,CAKMzZ,OACGjG,KAAK+qC,KACP/qC,KAAK+qC,IAAI9kC,OAEbjG,KAAK+qC,SAAM3rC,CACd,CAKGonB,SACA,OAAOxmB,KAAK+qC,IAAIvkB,EACnB,CAMGE,kBACA,OAAO1mB,KAAK+qC,IAAIrkB,WACnB,CAEGe,iBACA,OAAOznB,KAAK+qC,IAAItjB,UACnB,CAOGb,mCACA,OAAO5mB,KAAK+qC,IAAInkB,4BACnB,CAOGC,mCACA,OAAO7mB,KAAK+qC,IAAIlkB,4BACnB,CAKGE,0BACA,OAAO/mB,KAAK+qC,IAAIhkB,mBACnB,CAKGE,sCACA,OAAOjnB,KAAK+qC,IAAI9jB,+BACnB,CAKGE,+BACA,OAAOnnB,KAAK+qC,IAAI5jB,wBACnB,CAKGE,oBACA,OAAOrnB,KAAK+qC,IAAI1jB,aACnB,CAKGE,qBACA,OAAOvnB,KAAK+qC,IAAIxjB,cACnB,CAEGf,OAAGkB,GACH1nB,KAAK+qC,IAAIvkB,GAAKkB,CACjB,CAEGE,8BAA0BF,GAC1B1nB,KAAK+qC,IAAInjB,0BAA4BF,CACxC,CAEGD,eAAWC,GACX1nB,KAAK+qC,IAAItjB,WAAaC,CACzB,CAEGd,iCAA6Bc,GAC7B1nB,KAAK+qC,IAAInkB,6BAA+Bc,CAC3C,CAEGb,iCAA6Ba,GAC7B1nB,KAAK+qC,IAAIlkB,6BAA+Ba,CAC3C,CAKGX,wBAAoBW,GACpB1nB,KAAK+qC,IAAIhkB,oBAAsBW,CAClC,CAKGT,oCAAgCS,GAChC1nB,KAAK+qC,IAAI9jB,gCAAkCS,CAC9C,CAKGP,6BAAyBO,GACzB1nB,KAAK+qC,IAAI5jB,yBAA2BO,CACvC,CAEGL,kBAAcK,GACd1nB,KAAK+qC,IAAI1jB,cAAgBK,CAC5B,CAEGH,mBAAeG,GACf1nB,KAAK+qC,IAAIxjB,eAAiBG,CAC7B,CAEMY,4BACHtoB,KAAK+qC,IAAIziB,2BACZ,CAEME,8BACHxoB,KAAK+qC,IAAIviB,6BACZ,CAEME,8CACH1oB,KAAK+qC,IAAIriB,6CACZ,GX1HL,SAAY4iB,GACRA,EAAAA,EAAA,SAAA,GAAA,WACAA,EAAAA,EAAA,MAAA,GAAA,QACAA,EAAAA,EAAA,UAAA,GAAA,YACAA,EAAAA,EAAA,KAAA,GAAA,OACAA,EAAAA,EAAA,OAAA,GAAA,QACH,CAND,CAAYA,KAAAA,GAMX,CAAA,IAED,SAAYC,GACRA,EAAAA,EAAA,kBAAA,GAAA,oBACAA,EAAAA,EAAA,WAAA,GAAA,YACH,CAHD,CAAYA,KAAAA,GAGX,CAAA,IAiBD,SAAYC,GACRA,EAAAA,EAAA,KAAA,GAAA,OACAA,EAAAA,EAAA,KAAA,GAAA,OACAA,EAAAA,EAAA,KAAA,GAAA,OACAA,EAAAA,EAAA,KAAA,GAAA,OACAA,EAAAA,EAAA,KAAA,IAAA,OACAA,EAAAA,EAAA,KAAA,IAAA,MACH,CAPD,CAAYA,KAAAA,GAOX,CAAA,UAEY+H,GAKTrtC,YACImmC,EACAmH,EACAjpC,GAEAvK,KAAKqsC,OAASA,EACdrsC,KAAKwzC,QAAUA,EACfxzC,KAAKuK,OAASA,CACjB,CAEM3E,gBACHymC,EACAmH,EACAjpC,GAEA,OAAQ8hC,EAAO5pB,UAAUlY,IACrB,KAAK7G,EAAaC,SACd,OAAO,IAAI8vC,GAAqBpH,EAAQmH,EAASjpC,GACrD,KAAK7G,EAAaG,UACd,OAAO,IAAI6vC,GAAsBrH,EAAQmH,EAASjpC,GACtD,KAAK7G,EAAaE,MACd,OAAO,IAAI+vC,GAAkBtH,EAAQmH,EAASjpC,GAClD,KAAK7G,EAAaK,OACd,OAAO,IAAI6vC,GAAmBvH,EAAQmH,EAASjpC,GACnD,KAAK7G,EAAaI,KACd,OAAO,IAAI+vC,GAAiBxH,EAAQmH,EAASjpC,GACjD,QACI,OAAO,IAAIgpC,GAAalH,EAAQmH,EAASjpC,GAEpD,CAGMgiC,wBAAwBiH,GAC3BxzC,KAAKwzC,QAAUA,CAClB,CAMMhH,UACH,OAAOxsC,KAAKqsC,OAAOz0B,SAAS5X,KAAKuK,OACpC,CAKMupC,QACH,OAAO9zC,KAAKwzC,QAAQrJ,IAAInqC,KAAKqsC,OAAO1pB,iBAAiB3iB,KAAKuK,QAC7D,CAKMwpC,QACH,OAAO/zC,KAAKwzC,QAAQrJ,IAAInqC,KAAKqsC,OAAOxpB,iBAAiB7iB,KAAKuK,QAC7D,CAKMglC,OACH,OAAOvvC,KAAKqsC,OAAO5pB,UAAUziB,KAAKuK,OACrC,CAUMmX,UACH,OAAOmpB,GAAUwC,QAAQrtC,KAAKqsC,OAAOlpB,aAAanjB,KAAKuK,QAC1D,CAQMoX,UACH,OAAOkpB,GAAUwC,QAAQrtC,KAAKqsC,OAAOhpB,aAAarjB,KAAKuK,QAC1D,CAQMypC,WAAWxwB,GACd,MAAM6qB,EAAWxD,GAAUgD,QAAQrqB,GACnCxjB,KAAKqsC,OAAO9oB,gBAAgBvjB,KAAKuK,OAAQ8jC,GACzCA,EAASpoC,MACZ,CAQMguC,WAAWzwB,GACd,MAAM6qB,EAAWxD,GAAUgD,QAAQrqB,GACnCxjB,KAAKqsC,OAAO3oB,gBAAgB1jB,KAAKuK,OAAQ8jC,GACzCA,EAASpoC,MACZ,CAMMiuC,mBAAmB1jC,GACtBxQ,KAAKqsC,OAAOvoB,wBAAwB9jB,KAAKuK,OAAQiG,EACpD,CAMM2jC,kBACH,OAAOn0C,KAAKqsC,OAAOzoB,qBAAqB5jB,KAAKuK,OAChD,EAGC,MAAO6pC,WAAyBb,GAS3BxxB,gBACH,OAAO/hB,KAAKqsC,OAAOroB,mBAAmBhkB,KAAKuK,OAAQvK,KAAKq0C,UAC3D,CAKMryB,YACH,OAAOhiB,KAAKqsC,OAAOnoB,eAAelkB,KAAKuK,OAAQvK,KAAKq0C,UACvD,CAKMpyB,YACH,OAAOjiB,KAAKqsC,OAAOjoB,eAAepkB,KAAKuK,OAAQvK,KAAKq0C,UACvD,CAQMC,UAAU/vB,EAAaC,GAC1BxkB,KAAKqsC,OAAO/nB,eAAetkB,KAAKuK,OAAQvK,KAAKq0C,UAAW9vB,EAAKC,EAChE,CAEM+vB,oBAAoB5vB,GACvB3kB,KAAKqsC,OAAO3nB,yBACR1kB,KAAKuK,OACLvK,KAAKq0C,UACL1vB,EAEP,CAEM6vB,uBAAuB1vB,EAAmBC,GAC7C/kB,KAAKqsC,OAAOxnB,4BACR7kB,KAAKuK,OACLvK,KAAKq0C,UACLvvB,EACAC,EAEP,CAEM0vB,uBACHvvB,EACA1D,EACAC,GAEAzhB,KAAKqsC,OAAOpnB,4BACRjlB,KAAKuK,OACLvK,KAAKq0C,UACLnvB,EACA1D,EACAC,EAEP,CAEMizB,eACHxvB,EACAJ,EACAtD,EACAC,GAEAzhB,KAAKqsC,OAAOjnB,oBACRplB,KAAKuK,OACLvK,KAAKq0C,UACLnvB,EACAJ,EACAtD,EACAC,EAEP,EAGC,MAAOkyB,WAA0BJ,IAEjC,MAAOM,WAAyBN,IAEhC,MAAOK,WAA2BL,IAElC,MAAOG,WAA8BU,GAChCC,UACH,OAAO/wC,EAAaC,IACvB,EAGC,MAAOkwC,WAA6BW,GAC/BC,UACH,OAAO/wC,EAAaG,IACvB,QAIQkxC,GAcTzuC,cAAwB,CAejBN,aACH8b,EACAkzB,EACAjzB,EACAkzB,GAEA,IAAI7J,EAAM,IAAI2J,GAMd,OALA3J,EAAItpB,QAAUA,EACdspB,EAAIrpB,QAAUA,EACdqpB,EAAI4J,OAASA,EACb5J,EAAI6J,OAASA,EACb7J,EAAIvoB,UAAY6oB,GAAU1nC,MACnBonC,CACV,CAEMplC,cACH2b,EACAC,EACAC,EACAC,EACAC,GAEA,IAAIqpB,EAAM,IAAI2J,GAOd,OANA3J,EAAItpB,QAAUA,EACdspB,EAAIrpB,QAAUA,EACdqpB,EAAIvrC,OAAS8hB,EACbypB,EAAIxpB,UAAYA,EAChBwpB,EAAIvpB,QAAUA,EACdupB,EAAIvoB,UAAY6oB,GAAUvnC,OACnBinC,CACV,CAEMplC,YACHnG,EACAiiB,EACAC,GAEA,IAAIqpB,EAAM,IAAI2J,GAKd,OAJA3J,EAAItpB,QAAUA,EACdspB,EAAIrpB,QAAUA,EACdqpB,EAAIvrC,OAASA,EACburC,EAAIvoB,UAAY6oB,GAAUxnC,KACnBknC,CACV,CAgBMplC,gBAAgB8b,EAAiBC,GACpC,IAAIqpB,EAAM,IAAI2J,GAId,OAHA3J,EAAItpB,QAAUA,EACdspB,EAAIrpB,QAAUA,EACdqpB,EAAIvoB,UAAY6oB,GAAU3nC,SACnBqnC,CACV,CAcMplC,iBACH8b,EACAC,EACAG,GAEA,IAAIkpB,EAAM,IAAI2J,GAKd,OAJA3J,EAAItpB,QAAUA,EACdspB,EAAIrpB,QAAUA,EACdqpB,EAAIlpB,KAAOA,EACXkpB,EAAIvoB,UAAY6oB,GAAUznC,UACnBmnC,CACV,CAKM6C,UACH,IAEIiH,EACAxG,EAHAyG,EAAQlK,GAAUgD,QAAQ7tC,KAAK0hB,SAC/BszB,EAAQnK,GAAUgD,QAAQ7tC,KAAK2hB,SAG/BI,GAAgB,EAChBC,EAAY,EACZC,EAAY,EAEhB,OAAQjiB,KAAKyiB,WACT,KAAK6oB,GAAU1nC,MACX,IAAIqxC,EAAU9J,GAAY0C,QAAQ7tC,KAAK40C,QACnCM,EAAU/J,GAAY0C,QAAQ7tC,KAAK60C,QACvCvG,EAAShtB,EAAgB6zB,MAAMJ,EAAOE,EAASD,EAAOE,GACtDD,EAAQhvC,OACRivC,EAAQjvC,OACR,MACJ,KAAKqlC,GAAUvnC,OACXuqC,EAAShtB,EAAgB8zB,OACrBp1C,KAAKP,OACLO,KAAKwhB,UACLxhB,KAAKyhB,QACLszB,EACAC,GAEJ,MACJ,KAAK1J,GAAUxnC,KACXwqC,EAAShtB,EAAgB+zB,KAAKr1C,KAAKP,OAAQs1C,EAAOC,GAClD,MACJ,KAAK1J,GAAUznC,UACXixC,EAAQjK,GAAUgD,QAAQ7tC,KAAK8hB,MAEzB9hB,KAAK+hB,gBACPA,GAAgB,EAChBC,EAAYhiB,KAAKs1C,OAAO,GACxBrzB,EAAYjiB,KAAKs1C,OAAO,IAI5BhH,EAAShtB,EAAgBi0B,UACrBR,EACAC,EACAF,EACA/yB,EACAC,EACAC,GAKJ6yB,EAAM7uC,OACN,MAEJ,KAAKqlC,GAAU3nC,SACX2qC,EAAShtB,EAAgBk0B,SAAST,EAAOC,GAQjD,OAHAD,EAAM9uC,OACN+uC,EAAM/uC,OAECqoC,CACV,QYndQmH,GAmBTvvC,YAAY6kC,GACR/qC,KAAK+qC,IAAMA,GAAO,IAAI/rB,GACtBhf,KAAK2yC,IAAM,IAAIZ,GAEXhH,GACAA,EAAI/kB,oBAAoBzb,IACpBvK,KAAK2yC,IAAI5vC,IAAIwH,EAAQgpC,GAAamC,SAAS3K,EAAK,KAAMxgC,GAAQ,GAGzE,CArBMtE,OACGjG,KAAK+qC,KACP/qC,KAAK+qC,IAAI9kC,OAEbjG,KAAK+qC,SAAM3rC,EAELY,KAAK2yC,KACP3yC,KAAK2yC,IAAIzxB,QAEblhB,KAAK2yC,SAAMvzC,CACd,CAcMmtC,wBAAwBjmC,GAC3BtG,KAAK2yC,IAAIL,SAASqD,GAAUA,EAAMpJ,wBAAwBjmC,IAC7D,CAWMif,YACHjf,EACAusC,EACAptB,EACAC,EACAzM,GAEA,MAAM28B,EAAY/C,EAAKhF,UACjBtjC,EAASvK,KAAK+qC,IAAIxlB,YACpBqwB,EACAnwB,EACAC,EACAzM,GAEJ28B,EAAU3vC,OACV,IAAI0vC,EAAQpC,GAAamC,SAAS11C,KAAK+qC,IAAKzkC,EAAQiE,GAEpD,OADAvK,KAAK2yC,IAAI5vC,IAAIwH,EAAQorC,GACdA,CACV,CAQM58B,OAAOxO,EAA4B0O,GACtCjZ,KAAK+qC,IAAIhyB,OAAOxO,EAAQ0O,GACxBjZ,KAAKmzC,MAAM5oC,EACd,CAOM6oC,sCACH7oC,EACA1K,GAEAG,KAAK+qC,IAAI7kB,gCAAgC3b,EAAQ1K,EACpD,CAMMszC,MAAM5oC,GACTvK,KAAK2yC,IAAIN,OAAO9nC,EACnB,CAKM3J,MACH,OAAOZ,KAAK2yC,IAAI/xC,KACnB,CAOMgX,SAASrN,GACZ,OAA2B,MAApBvK,KAAKmqC,IAAI5/B,EACnB,CASM4/B,IAAI5/B,GACP,OAAOvK,KAAK2yC,IAAIxI,IAAI5/B,EACvB,CAOM+nC,QAAQzyC,GACXG,KAAK2yC,IAAIL,QAAQzyC,EACpB,CAOM2yC,SACH,OAAOxyC,KAAK2yC,IAAIH,QACnB,QC3IQqD,GAIT3vC,YAAYmmC,EAA8B9hC,GACtCvK,KAAKqsC,OAASA,EACdrsC,KAAKuK,OAASA,CACjB,CAEM3E,gBACHymC,EACA9hC,GAEA,OAAQ8hC,EAAO5pB,UAAUlY,IACrB,KAAK7G,EAAaC,SACd,OAAO,IAAImyC,GAAuBzJ,EAAQ9hC,GAC9C,KAAK7G,EAAaG,UACd,OAAO,IAAIkyC,GAAwB1J,EAAQ9hC,GAC/C,KAAK7G,EAAaE,MACd,OAAO,IAAIoyC,GAAoB3J,EAAQ9hC,GAC3C,QACI,OAAO,IAAIsrC,GAAexJ,EAAQ9hC,GAE7C,CAMMiiC,UACH,OAAOxsC,KAAKqsC,OAAOz0B,SAAS5X,KAAKuK,OACpC,CAiDM2pC,mBAAmB1jC,GACtBxQ,KAAKqsC,OAAOvoB,wBAAwB9jB,KAAKuK,OAAQiG,EACpD,CAMM2jC,kBACH,OAAOn0C,KAAKqsC,OAAOzoB,qBAAqB5jB,KAAKuK,OAChD,EAGC,MAAO0rC,WAA2BJ,IA4ClC,MAAOG,WAA4BH,IAEnC,MAAOE,WAAgCE,GAClC5B,UACH,OAAO/wC,EAAaC,IACvB,EAGC,MAAOuyC,WAA+BG,GACjC5B,UACH,OAAO/wC,EAAaG,IACvB,QCpJQyyC,GAmBThwC,YAAY6kC,GACR/qC,KAAK+qC,IAAMA,GAAO,IAAI9rB,GACtBjf,KAAK2yC,IAAM,IAAIZ,GAEXhH,GACAA,EAAI/kB,oBAAoBzb,IACpBvK,KAAK2yC,IAAI5vC,IAAIwH,EAAQsrC,GAAeH,SAAS11C,KAAK+qC,IAAKxgC,GAAQ,GAG1E,CArBMtE,OACGjG,KAAK+qC,KACP/qC,KAAK+qC,IAAI9kC,OAEbjG,KAAK+qC,SAAM3rC,EAELY,KAAK2yC,KACP3yC,KAAK2yC,IAAIzxB,QAEblhB,KAAK2yC,SAAMvzC,CACd,CAqBMmmB,YACHstB,EACAptB,EACAC,EACAzM,GAEA,MAAM28B,EAAY/C,EAAKhF,UACjBtjC,EAASvK,KAAK+qC,IAAIxlB,YACpBqwB,EACAnwB,EACAC,EACAzM,GAEJ28B,EAAU3vC,OACV,IAAI0vC,EAAQE,GAAeH,SAAS11C,KAAK+qC,IAAKxgC,GAE9C,OADAvK,KAAK2yC,IAAI5vC,IAAIwH,EAAQorC,GACdA,CACV,CAQM58B,OAAOxO,EAA8Bob,GACxC3lB,KAAK+qC,IAAIhyB,OAAOxO,EAAQob,GACxB3lB,KAAK2yC,IAAIN,OAAO9nC,EACnB,CAMM4oC,MAAM5oC,GACTvK,KAAK2yC,IAAIN,OAAO9nC,EACnB,CAKM3J,MACH,OAAOZ,KAAK2yC,IAAI/xC,KACnB,CAOMgX,SAASrN,GACZ,OAA2B,MAApBvK,KAAKmqC,IAAI5/B,EACnB,CASM4/B,IAAI5/B,GACP,OAAOvK,KAAK2yC,IAAIxI,IAAI5/B,EACvB,CAOM+nC,QAAQzyC,GACXG,KAAK2yC,IAAIL,QAAQzyC,EACpB,CAOMuzC,sCACH7oC,EACA1K,GAEAG,KAAK+qC,IAAI7kB,gCAAgC3b,EAAQ1K,EACpD,CAOM2yC,SACH,OAAOxyC,KAAK2yC,IAAIH,QACnB,GbjJL,SAAY/G,GACRA,EAAAA,EAAA,QAAA,GAAA,UACAA,EAAAA,EAAA,IAAA,GAAA,MACAA,EAAAA,EAAA,SAAA,GAAA,WACAA,EAAAA,EAAA,IAAA,GAAA,KACH,CALD,CAAYA,KAAAA,GAKX,CAAA,UcJY0K,GAaTjwC,YAAY6kC,GACR/qC,KAAK+qC,IAAMA,GAAO,IAAI9gC,CACzB,CATMhE,OACGjG,KAAK+qC,KACP/qC,KAAK+qC,IAAI9kC,OAEbjG,KAAK+qC,SAAM3rC,CACd,QCVQg3C,GAaTlwC,YAAY6kC,GACR/qC,KAAK+qC,IAAMA,GAAO,IAAI7xB,EACzB,CATMjT,OACGjG,KAAK+qC,KACP/qC,KAAK+qC,IAAI9kC,OAEbjG,KAAK+qC,SAAM3rC,CACd,CAaM2pB,6BAA6BlpB,GAChCG,KAAK+qC,IAAIhiB,6BAA6BlpB,EACzC,GdlCL,SAAY6rC,GACRA,EAAAA,EAAA,OAAA,GAAA,SACAA,EAAAA,EAAA,KAAA,GAAA,OACAA,EAAAA,EAAA,QAAA,GAAA,SACH,CAJD,CAAYA,KAAAA,GAIX,CAAA,UeSY2K,GAgBTnwC,YAAYowC,EAAgBC,GACxBv2C,KAAKs2C,OAASA,EACdt2C,KAAKu2C,IAAMA,CACd,CAEMC,QAAQtI,GACX,MAAO,CACH/sC,EAAGnB,KAAKs2C,OAAOn1C,EAAInB,KAAKu2C,IAAIp1C,EAAI+sC,EAChChiC,EAAGlM,KAAKs2C,OAAOpqC,EAAIlM,KAAKu2C,IAAIrqC,EAAIgiC,EAEvC,QAMQuI,GAsBTvwC,YACIsvB,EACAna,EACAyZ,EACAE,GAXJh1B,KAAA80B,YAAc4W,GAAYroC,QAK1BrD,KAASg1B,eAAuB51B,EAQ5BY,KAAKw1B,aAAeA,EACpBx1B,KAAKqb,OAASA,OACIjc,IAAd41B,IAAyBh1B,KAAKg1B,UAAYA,QAC1B51B,IAAhB01B,IAA2B90B,KAAK80B,YAAcA,EACrD,CAEMlvB,eAAemlC,GAClB,IAAKA,EAAK,OAAO,KAEjB,MAAMuD,EAAS,IAAImI,GACf1L,EAAIpxB,iBACJkxB,GAAUwC,QAAQtC,EAAI1vB,UACtB0vB,EAAIjW,cACJiW,EAAI/V,aAGR,OADA+V,EAAI9kC,OACGqoC,CACV,QAMQoI,GA0BTxwC,YACIgpC,EACA1Z,EACAna,EACAyZ,EACAE,GAZJh1B,KAAA80B,YAAc4W,GAAYroC,QAK1BrD,KAASg1B,eAAuB51B,EAS5BY,KAAKkvC,SAAWA,EAChBlvC,KAAKw1B,aAAeA,EACpBx1B,KAAKqb,OAASA,OACIjc,IAAd41B,IAAyBh1B,KAAKg1B,UAAYA,QAC1B51B,IAAhB01B,IAA2B90B,KAAK80B,YAAcA,EACrD,CAEMlvB,eACH0mC,EACAvB,GAEA,IAAKA,EAAK,OAAO,KAEjB,MAAMuD,EAAS,IAAIoI,GACfpK,EAAYnC,IAAIY,EAAItxB,kBACpBsxB,EAAIpxB,iBACJkxB,GAAUwC,QAAQtC,EAAI1vB,UACtB0vB,EAAIjW,cACJiW,EAAI/V,aAGR,OADA+V,EAAI9kC,OACGqoC,CACV,QAMQqI,GAYTzwC,YAAYgpC,EAAoB1Z,GAC5Bx1B,KAAKkvC,SAAWA,EAChBlvC,KAAKw1B,aAAeA,CACvB,CAEM5vB,eACH0mC,EACAvB,GAEA,IAAKA,EAAK,OAAO,KAEjB,MAAMuD,EAAS,IAAIqI,GACfrK,EAAYnC,IAAIY,EAAItxB,kBACpBsxB,EAAIvV,gBAGR,OADAuV,EAAI9kC,OACGqoC,CACV,QC9KQsI,GAUT1wC,YAAY0C,EAAegsB,GACvB50B,KAAK4I,MAAQA,EACb5I,KAAK40B,SAAWA,CACnB,CAEMhvB,eAAemlC,GAClB,IAAKA,EAAK,OAAO,KAEjB,MAAMuD,EAAS,IAAIsI,GACf/L,GAAUwC,QAAQtC,EAAIniC,SACtBmiC,EAAInW,YAGR,OADAmW,EAAI9kC,OACGqoC,CACV,QAMQuI,GAwBT3wC,YACIgpC,EACAtmC,EACAgsB,EACAE,EACAE,GAZJh1B,KAAA80B,YAAc4W,GAAYroC,QAK1BrD,KAASg1B,eAAuB51B,EAS5BY,KAAKkvC,SAAWA,EAChBlvC,KAAK4I,MAAQA,EACb5I,KAAK40B,SAAWA,OACEx1B,IAAd41B,IAAyBh1B,KAAKg1B,UAAYA,QAC1B51B,IAAhB01B,IAA2B90B,KAAK80B,YAAcA,EACrD,CAEMlvB,eACH0mC,EACAvB,GAEA,IAAKA,EAAK,OAAO,KAEjB,MAAMuD,EAAS,IAAIuI,GACfvK,EAAYnC,IAAIY,EAAItxB,kBACpBoxB,GAAUwC,QAAQtC,EAAIniC,SACtBmiC,EAAInW,WACJmW,EAAIjW,cACJiW,EAAI/V,aAGR,OADA+V,EAAI9kC,OACGqoC,CACV,QCxFQwI,GA0BT5wC,YACIyT,EACAE,EACAE,EACAE,EACAE,GAEAna,KAAK2Z,eAAiBA,EACtB3Z,KAAK6Z,SAAWA,EAChB7Z,KAAK+Z,SAAWA,EAChB/Z,KAAKia,QAAUA,EACfja,KAAKma,QAAUA,CAClB,CAEMvU,eACH0mC,EACAvB,GAEA,IAAKA,EAAK,OAAO,KAEjB,MAAMuD,EAAS,IAAIwI,GACf/L,EAAIpxB,iBACJkxB,GAAUwC,QAAQtC,EAAIlxB,YACtBgxB,GAAUwC,QAAQtC,EAAIhxB,YACtB8wB,GAAUwC,QAAQtC,EAAI9wB,WACtB4wB,GAAUwC,QAAQtC,EAAI5wB,YAG1B,OADA4wB,EAAI9kC,OACGqoC,CACV,EAMC,MAAOyI,WAA6BD,GAMtC5wC,YACIgpC,EACAv1B,EACAE,EACAE,EACAE,EACAE,GAEA68B,MAAMr9B,EAAgBE,EAAUE,EAAUE,EAASE,GACnDna,KAAKkvC,SAAWA,CACnB,CAEMtpC,eACH0mC,EACAvB,GAEA,IAAKA,EAAK,OAAO,KAEjB,MAAMuD,EAAS,IAAIyI,GACfzK,EAAYnC,IAAIY,EAAItxB,kBACpBsxB,EAAIpxB,iBACJkxB,GAAUwC,QAAQtC,EAAIlxB,YACtBgxB,GAAUwC,QAAQtC,EAAIhxB,YACtB8wB,GAAUwC,QAAQtC,EAAI9wB,WACtB4wB,GAAUwC,QAAQtC,EAAI5wB,YAG1B,OADA4wB,EAAI9kC,OACGqoC,CACV,QCpFQ2I,GAaT/wC,YAAY6kC,GACR/qC,KAAK+qC,IAAMA,GAAO,IAAIplC,CACzB,CATMM,OACGjG,KAAK+qC,KACP/qC,KAAK+qC,IAAI9kC,OAEbjG,KAAK+qC,SAAM3rC,CACd,CAmBMgH,QACHyrB,EACAvrB,EACAC,EACA2wC,EACAxwC,EACAC,EACAwwC,EACAC,EACAC,EACAC,EACAC,GAEA,IAAIC,EAAU3M,GAAUgD,QAAQqJ,EAAIZ,QAChCmB,EAAS5M,GAAUgD,QAAQqJ,EAAIX,KAC/BjI,EAASqI,GAAetJ,QACxB9mC,EACAvG,KAAK+qC,IAAI3kC,QACLyrB,EAAYkZ,IACZzkC,EAAOykC,IACPxkC,EAAUwkC,IACVyM,EACAC,EACA/wC,EACAC,EACAwwC,EACAC,EACAC,EACAC,EACAC,IAOR,OAHAC,EAAQvxC,OACRwxC,EAAOxxC,OAEAqoC,CACV,CAeM9mC,oBACHqqB,EACAvrB,EACAC,EACA2wC,EACAxwC,EACAC,EACAwwC,EACAC,EACAC,EACAC,EACAC,GAEA,IAAIC,EAAU3M,GAAUgD,QAAQqJ,EAAIZ,QAChCmB,EAAS5M,GAAUgD,QAAQqJ,EAAIX,KAC/BjI,EAASoI,GAAwBrJ,QACjC9mC,EACAvG,KAAK+qC,IAAIvjC,oBACLqqB,EAAYkZ,IACZzkC,EAAOykC,IACPxkC,EAAUwkC,IACVyM,EACAC,EACA/wC,EACAC,EACAwwC,EACAC,EACAC,EACAC,EACAC,IAOR,OAHAC,EAAQvxC,OACRwxC,EAAOxxC,OAEAqoC,CACV,CAgBM3mC,qBACHkqB,EACAvrB,EACAC,EACA2wC,EACAxwC,EACAC,EACAiB,EACAuvC,EACAC,EACAC,EACAC,EACAC,GAEA,IAAIC,EAAU3M,GAAUgD,QAAQqJ,EAAIZ,QAChCmB,EAAS5M,GAAUgD,QAAQqJ,EAAIX,KAOnCv2C,KAAK+qC,IAAIpjC,qBACLkqB,EAAYkZ,IACZzkC,EAAOykC,IACPxkC,EAAUwkC,IACVyM,EACAC,EACA/wC,EACAC,GAbe+wC,GACR9vC,EACH8uC,GAAwBrJ,QAAQ9mC,EAAWmxC,KAa/CP,EACAC,EACAC,EACAC,EACAC,GAGJC,EAAQvxC,OACRwxC,EAAOxxC,MACV,CAYM6B,sBACH+pB,EACAvrB,EACAC,EACAwB,EACAC,EACAC,EACAkvC,EACAC,EACAC,EACAC,EACAC,GAEA,IAAII,EAAS9M,GAAUgD,QAAQ9lC,GAC3BgrC,EAAS5H,GAAY0C,QAAQ7lC,GAC7B4vC,EAAW3vC,EAAM4lC,UACjBS,EAAStuC,KAAK+qC,IAAIjjC,sBAClB+pB,EAAYkZ,IACZzkC,EAAOykC,IACPxkC,EAAUwkC,IACV4M,EACA5E,EACA6E,EACAT,EACAC,EACAC,EACAC,EACAC,GAOJ,OAJAI,EAAO1xC,OACP8sC,EAAO9sC,OACP2xC,EAAS3xC,OAEFqoC,CACV,CAeM3lC,aACHkpB,EACAvrB,EACAC,EACAqC,EACAjC,EACAwwC,EACAC,EACAC,EACAC,EACAC,GAEA,IAAIlJ,EAAWxD,GAAUgD,QAAQjlC,GAC7B0lC,EAASuI,GAAwBxJ,QACjC9mC,EACAvG,KAAK+qC,IAAIpiC,aACLkpB,EAAYkZ,IACZzkC,EAAOykC,IACPxkC,EAAUwkC,IACVsD,EACA1nC,EACAwwC,EACAC,EACAC,EACAC,EACAC,IAMR,OAFAlJ,EAASpoC,OAEFqoC,CACV,CAUMvlC,0BACH8oB,EACAvrB,EACAC,EACAqC,EACAuuC,EACAC,EACAC,EACAC,EACAC,GAEA,IAAIlJ,EAAWxD,GAAUgD,QAAQjlC,GAC7B0lC,EAASuI,GAAwBxJ,QACjC9mC,EACAvG,KAAK+qC,IAAIhiC,0BACL8oB,EAAYkZ,IACZzkC,EAAOykC,IACPxkC,EAAUwkC,IACVsD,EACA8I,EACAC,EACAC,EACAC,EACAC,IAMR,OAFAlJ,EAASpoC,OAEFqoC,CACV,CAYMrlC,uBACH4oB,EACAvrB,EACAC,EACAqC,EACAhB,EACAuvC,EACAC,EACAC,EACAC,EACAC,GAEA,IAAIlJ,EAAWxD,GAAUgD,QAAQjlC,GAEjC5I,KAAK+qC,IAAI9hC,uBACL4oB,EAAYkZ,IACZzkC,EAAOykC,IACPxkC,EAAUwkC,IACVsD,EACAzmC,EACAuvC,EACAC,EACAC,EACAC,EACAC,GAGJlJ,EAASpoC,MACZ,CAsBMkD,UACH0oB,EACAvrB,EACAC,EACAwB,EACAC,EACAoB,EACAnB,EACA4vC,EACAnxC,EACAoxC,EACAX,EACAC,EACAC,EACAC,EACAC,GAEA,IAAII,EAAS9M,GAAUgD,QAAQ9lC,GAC3BgrC,EAAS5H,GAAY0C,QAAQ7lC,GAC7B4lC,EAAS/C,GAAUgD,QAAQzkC,GAC3BwuC,EAAW3vC,EAAM4lC,UAEjBS,EAASyI,GAAqB1J,QAC9B9mC,EACAvG,KAAK+qC,IAAI5hC,UACL0oB,EAAYkZ,IACZzkC,EAAOykC,IACPxkC,EAAUwkC,IACV4M,EACA5E,EACAnF,EACAgK,EACAC,EACAnxC,EACAoxC,EACAX,EACAC,EACAC,EACAC,EACAC,IASR,OALAI,EAAO1xC,OACP8sC,EAAO9sC,OACP2nC,EAAO3nC,OACP2xC,EAAS3xC,OAEFqoC,CACV,CAaM7kC,uBACHooB,EACAvrB,EACAC,EACAwB,EACAC,EACAC,EACAL,EACAuvC,EACAC,EACAC,EACAC,EACAC,GAEA,IAAII,EAAS9M,GAAUgD,QAAQ9lC,GAC3BgrC,EAAS5H,GAAY0C,QAAQ7lC,GAC7B4vC,EAAW3vC,EAAM4lC,UAErB7tC,KAAK+qC,IAAIthC,uBACLooB,EAAYkZ,IACZzkC,EAAOykC,IACPxkC,EAAUwkC,IACV4M,EACA5E,EACA6E,EACAhwC,EACAuvC,EACAC,EACAC,EACAC,EACAC,GAGJI,EAAO1xC,OACP8sC,EAAO9sC,OACP2xC,EAAS3xC,MACZ,CAUM0D,kCACHkoB,EACAvrB,EACAC,EACAqD,EACAC,EACAjC,GAEA,IAAImwC,EAAYlN,GAAUgD,QAAQjkC,GAC9BouC,EAAiBnN,GAAUgD,QAAQhkC,GACvC7J,KAAK+qC,IAAIphC,kCACLkoB,EAAYkZ,IACZzkC,EAAOykC,IACPxkC,EAAUwkC,IACVgN,EACAC,EACApwC,GAEJmwC,EAAU9xC,OACV+xC,EAAe/xC,MAClB,QC5fQgyC,GAcT/xC,YAAY6kC,GACR/qC,KAAK+qC,IAAMA,GAAO,IAAI9jC,GACtBjH,KAAKk4C,aAAe,IAAIC,GAAoB,KAC/C,CAVMlyC,OACGjG,KAAK+qC,KACP/qC,KAAK+qC,IAAI9kC,OAEbjG,KAAK+qC,SAAM3rC,CACd,CAaMg5C,iBACH59B,EACA3a,GAEAG,KAAK+qC,IAAItc,mBAAmBjU,EAAW3a,EAC1C,CAMMw4C,sBACH79B,EACA3a,GAEAG,KAAK+qC,IAAIlc,wBAAwBrU,EAAW3a,EAC/C,CAWMy4C,YACH99B,EACAC,EACA5a,GAEA,MAAM04C,EAAUv4C,KAAK+qC,IAAIpc,aAAanU,EAAWC,GAEjD,GAAM89B,EAAS,CACX,MAAMC,EAAUD,EAAQ/9B,aAAeA,EAEvC,IAAI0B,EACJ,IAAKA,EAAI,EAAGA,EAAIq8B,EAAQt6B,wBAAyB/B,EAC7Clc,KAAKk4C,aAAanN,IAAMwN,EAAQp6B,gBAAgBjC,GAC1Clc,KAAKk4C,aAAanN,KACpBlrC,EAAEG,KAAKk4C,aAAcM,GAMzBx4C,KAAKk4C,aAAajyC,OAEtBsyC,EAAQtyC,MACX,CACJ,CAOMwyC,iBACHj+B,EACAC,GAEA,OAAOza,KAAK+qC,IAAIhc,kBAAkBvU,EAAWC,EAChD,QAGQ09B,GAUTjyC,YAAY6kC,GACR/qC,KAAK+qC,IAAMA,CACd,CATM9kC,OACGjG,KAAK+qC,KACP/qC,KAAK+qC,IAAI9kC,OAEbjG,KAAK+qC,SAAM3rC,CACd,CAMMic,SACH,OAAOwvB,GAAUwC,QAAQrtC,KAAK+qC,IAAI1vB,SACrC,CAEMq9B,eACH,OAAO7N,GAAUwC,QAAQrtC,KAAK+qC,IAAIxvB,WACrC,CAEMo9B,eACH,OAAO9N,GAAUwC,QAAQrtC,KAAK+qC,IAAItvB,WACrC,CAEME,YACH,OAAO3b,KAAK+qC,IAAIpvB,WACnB,CAEME,YACH,OAAO7b,KAAK+qC,IAAIlvB,WACnB,CAEM+8B,cACH,OAAO54C,KAAK+qC,IAAIhvB,cACnB,CAEM88B,mBAAmB38B,GACtB,OAAO2uB,GAAUwC,QAAQrtC,KAAK+qC,IAAI9uB,iBAAiBC,GACtD,CAEM48B,mBAAmB58B,GACtB,OAAO2uB,GAAUwC,QAAQrtC,KAAK+qC,IAAI3uB,iBAAiBF,GACtD,CAEM68B,YAAY78B,GACf,OAAOlc,KAAK+qC,IAAIzuB,aAAaJ,EAChC,CAEM88B,YAAY98B,GACf,OAAOlc,KAAK+qC,IAAIvuB,aAAaN,EAChC,CAEM+8B,YAAY/8B,GACf,OAAOlc,KAAK+qC,IAAIruB,aAAaR,EAChC,CAEMg9B,eAAeh9B,GAClB,OAAOlc,KAAK+qC,IAAInuB,gBAAgBV,EACnC,CAGMi9B,sBAAsBj9B,GACzB,OAAOlc,KAAK+qC,IAAIjuB,wBAAwBZ,EAC3C,CAIMk9B,oBACH,OAAOp5C,KAAK+qC,IAAI/tB,qBACnB,CAEMq8B,mBAAmBn9B,GACtB,OAAO2uB,GAAUwC,QAAQrtC,KAAK+qC,IAAI7tB,qBAAqBhB,GAC1D,CAEMo9B,kBAAkBp9B,GACrB,OAAOlc,KAAK+qC,IAAI3tB,oBAAoBlB,EACvC,CAEMq9B,sBAAsBr9B,GACzB,OAAOlc,KAAK+qC,IAAIztB,wBAAwBpB,EAC3C,CAEMs9B,yBAAyBt9B,GAC5B,OAAOlc,KAAK+qC,IAAIvtB,2BAA2BtB,EAC9C,CAEMu9B,6BAA6Bv9B,GAChC,OAAO2uB,GAAUwC,QAAQrtC,KAAK+qC,IAAIrtB,gCAAgCxB,GACrE,QC1LQw9B,GA4BTxzC,YACIyzC,EACAtU,EACAC,EACArrB,EACAE,GAEAna,KAAK4rB,SAAW+tB,EAChB35C,KAAKqlC,OAASA,EACdrlC,KAAKslC,OAASA,EACdtlC,KAAKia,QAAUA,EACfja,KAAKma,QAAUA,CAClB,CAEMvU,eAAemlC,GAClB,IAAKA,EAAK,OAAO,KAEjB,MAAMuD,EAAS,IAAIoL,GACf3O,EAAInf,WACJif,GAAUwC,QAAQtC,EAAI1F,UACtBwF,GAAUwC,QAAQtC,EAAIzF,UACtBuF,GAAUwC,QAAQtC,EAAI9wB,WACtB4wB,GAAUwC,QAAQtC,EAAI5wB,YAG1B,OADA4wB,EAAI9kC,OACGqoC,CACV,QnBpDiBsL,GAWXh0C,eACHymC,EACA9hC,GAEA,MAAMsvC,EAAUxN,EAAOx/B,YAAYtC,GAEnC,IAAIuvC,EACAhY,EACAiY,EACAlX,EACAV,EACAH,EACA3mB,EAEJ,OAAQw+B,GACJ,KAAKv1C,EAAaC,KACd,OAAO,IAAIA,GAAK8nC,EAAO/+B,SAAS/C,IACpC,KAAKjG,EAAaE,OAGd,OAFAs1C,EAAUzN,EAAOp/B,cAAc1C,GAExB,IAAI/F,GAAOs1C,EAAQ34C,EAAG24C,EAAQ5tC,GAIzC,KAAK5H,EAAaW,YAKd,OAJA60C,EAAUzN,EAAOp/B,cAAc1C,GAC/Bu3B,EAAeuK,EAAOr+B,cAAczD,GAG7B,IAAItF,GAAY60C,EAAQ34C,EAAG24C,EAAQ5tC,EAAG41B,GAIjD,KAAKx9B,EAAaG,QAGd,OAFA09B,EAAakK,EAAO1+B,aAAapD,GACjCy3B,EAASqK,EAAO/+B,SAAS/C,GAClB,IAAI9F,GAAQ09B,EAAYH,GACnC,KAAK19B,EAAaI,QAId,OAHAq1C,EAAK1N,EAAO38B,WAAWnF,GAGhB,IAAI7F,GACPmmC,GAAUC,IAAIiP,EAAG,GAAIA,EAAG,IACxBlP,GAAUC,IAAIiP,EAAG,GAAIA,EAAG,KAKhC,KAAKz1C,EAAaK,SAGd,OAFAo1C,EAAK1N,EAAO38B,WAAWnF,GACvBs4B,EAAUwJ,EAAOz8B,UAAUrF,GACpB,IAAI5F,GAASo1C,EAAIlX,GAC5B,KAAKv+B,EAAaM,SAId,OAHAm1C,EAAK1N,EAAO38B,WAAWnF,GAGhB,IAAI3F,GACPimC,GAAUC,IAAIiP,EAAG,GAAIA,EAAG,IACxBlP,GAAUC,IAAIiP,EAAG,GAAIA,EAAG,IACxBlP,GAAUC,IAAIiP,EAAG,GAAIA,EAAG,KAKhC,KAAKz1C,EAAaY,cAKd,OAJA60C,EAAK1N,EAAO38B,WAAWnF,GACvBu3B,EAAeuK,EAAOr+B,cAAczD,GAG7B,IAAIrF,GACP2lC,GAAUC,IAAIiP,EAAG,GAAIA,EAAG,IACxBlP,GAAUC,IAAIiP,EAAG,GAAIA,EAAG,IACxBlP,GAAUC,IAAIiP,EAAG,GAAIA,EAAG,IACxBjY,GAKR,KAAKx9B,EAAac,UAEd,OADAiW,EAASwvB,GAAUwC,QAAQhB,EAAOt/B,kBAAkBxC,IAC7C,IAAInF,GAAUiW,GAEzB,KAAK/W,EAAae,OACd,MAAM20C,EAAW3N,EAAOh+B,YAAY9D,GAC9B0vC,EAAW5N,EAAO19B,YAAYpE,GACpC,OAAO,IAAIlF,GAAO20C,EAAUC,GAEhC,KAAK31C,EAAaO,QACdk1C,EAAK1N,EAAO38B,WAAWnF,GACvBs4B,EAAUwJ,EAAOz8B,UAAUrF,GAC3B,MAAM2vC,EAAY7N,EAAOt8B,eAAexF,GACxC,OAAO,IAAI1F,GAAQk1C,EAAIlX,EAASqX,GAEpC,KAAK51C,EAAaQ,YACd,MAAMs+B,EAAQiJ,EAAOl8B,mBAAmB5F,GAClC44B,EAAUkJ,EAAOp8B,qBAAqB1F,GAG5C,OAAO,IAAI4vC,GAAYhX,EAASC,GAKpC,KAAK9+B,EAAaU,cAEd,OADA+0C,EAAK1N,EAAO38B,WAAWnF,GAChB,IAAIvF,GAAc+0C,GAAI,GACjC,KAAKz1C,EAAaa,mBAGd,OAFA40C,EAAK1N,EAAO38B,WAAWnF,GACvBu3B,EAAeuK,EAAOr+B,cAAczD,GAC7B,IAAIpF,GAAmB40C,EAAIjY,GAAc,GAIpD,QACI,MAAM,IAAIthC,MAAM,uBAAyBq5C,GAEpD,CAqBM1wC,UACH66B,EACAC,EACAC,EACAvxB,EACAa,EACAC,EACA0wB,EACA0T,EACAnxC,EACAoxC,GAEA,IAAIsC,EAAUvP,GAAUgD,QAAQ7J,GAC5BqW,EAAUlP,GAAY0C,QAAQ5J,GAC9BqW,EAAUzP,GAAUgD,QAAQ3J,GAC5BqW,EAAU1P,GAAUgD,QAAQr6B,GAC5BgnC,EAAUrP,GAAY0C,QAAQp6B,GAC9BgnC,EAAU5P,GAAUgD,QAAQ1J,GAE5BuW,EAAY16C,KAAK6tC,UACjB8M,EAAYhoC,EAAOk7B,UAEnBS,EAASwI,GAAazJ,QACtB,KACAqN,EAAUvxC,UACNixC,EACAC,EACAC,EACAK,EACAJ,EACAC,EACAC,EACA5C,EACAnxC,EACAoxC,IAcR,OAVAsC,EAAQn0C,OACRo0C,EAAQp0C,OACRq0C,EAAQr0C,OACRs0C,EAAQt0C,OACRu0C,EAAQv0C,OACRw0C,EAAQx0C,OAERy0C,EAAUz0C,OACV00C,EAAU10C,OAEHqoC,CACV,CAYMjK,gBACHL,EACAC,EACAtxB,EACAa,EACAC,GAEA,IAAI2mC,EAAUvP,GAAUgD,QAAQ7J,GAC5BqW,EAAUlP,GAAY0C,QAAQ5J,GAC9BsW,EAAU1P,GAAUgD,QAAQr6B,GAC5BgnC,EAAUrP,GAAY0C,QAAQp6B,GAE9BinC,EAAY16C,KAAK6tC,UACjB8M,EAAYhoC,EAAOk7B,UAEnBS,EAASoM,EAAUrW,gBACnB+V,EACAC,EACAM,EACAJ,EACAC,GAWJ,OARAJ,EAAQn0C,OACRo0C,EAAQp0C,OACRs0C,EAAQt0C,OACRu0C,EAAQv0C,OAERy0C,EAAUz0C,OACV00C,EAAU10C,OAEHqoC,CACV,CAaD/J,aACIP,EACAC,EACAtxB,EACAa,EACAC,EACAG,GAEA,IAAIwmC,EAAUvP,GAAUgD,QAAQ7J,GAC5BqW,EAAUlP,GAAY0C,QAAQ5J,GAC9BsW,EAAU1P,GAAUgD,QAAQr6B,GAC5BgnC,EAAUrP,GAAY0C,QAAQp6B,GAE9BinC,EAAY16C,KAAK6tC,UACjB8M,EAAYhoC,EAAOk7B,UAEnBS,EAASoL,GAAarM,QACtBqN,EAAUnW,aACN6V,EACAC,EACAM,EACAJ,EACAC,EACA5mC,IAYR,OARAwmC,EAAQn0C,OACRo0C,EAAQp0C,OACRs0C,EAAQt0C,OACRu0C,EAAQv0C,OAERy0C,EAAUz0C,OACV00C,EAAU10C,OAEHqoC,CACV,CAED7J,cACI18B,EACAC,EACAY,GAEA,IAAI+uC,EAAS9M,GAAUgD,QAAQ9lC,GAC3BgrC,EAAS5H,GAAY0C,QAAQ7lC,GAC7BqmC,EAAWxD,GAAUgD,QAAQjlC,GAC7BgvC,EAAW53C,KAAK6tC,UAEhBS,EAASsJ,EAASnT,cAAckT,EAAQ5E,EAAQ1E,GAOpD,OALAsJ,EAAO1xC,OACP8sC,EAAO9sC,OACPooC,EAASpoC,OACT2xC,EAAS3xC,OAEFqoC,CACV,CAED3lC,aACIZ,EACAC,EACAY,EACAjC,GAEA,IAAIgxC,EAAS9M,GAAUgD,QAAQ9lC,GAC3BgrC,EAAS5H,GAAY0C,QAAQ7lC,GAC7BqmC,EAAWxD,GAAUgD,QAAQjlC,GAC7BgvC,EAAW53C,KAAK6tC,UAEhBS,EAASsI,GAAgBvJ,QACzBuK,EAASjvC,aAAagvC,EAAQ5E,EAAQ1E,EAAU1nC,IAQpD,OALAgxC,EAAO1xC,OACP8sC,EAAO9sC,OACPooC,EAASpoC,OACT2xC,EAAS3xC,OAEFqoC,CACV,CAED1J,cACIsS,EACAnvC,EACAC,EACAtB,GAEA,IAAIixC,EAAS9M,GAAUgD,QAAQ9lC,GAC3BgrC,EAAS5H,GAAY0C,QAAQ7lC,GAC7B4yC,EAAa/P,GAAUgD,QAAQqJ,EAAIZ,QACnCuE,EAAYhQ,GAAUgD,QAAQqJ,EAAIX,KAClCqB,EAAW53C,KAAK6tC,UAEhBS,EAASsJ,EAAShT,cAClB+S,EACA5E,EACA6H,EACAC,EACAn0C,GASJ,OANAixC,EAAO1xC,OACP8sC,EAAO9sC,OACP20C,EAAW30C,OACX40C,EAAU50C,OACV2xC,EAAS3xC,OAEFqoC,CACV,CAEDloC,QACI8wC,EACAnvC,EACAC,EACAtB,EACAC,GAEA,IAAIgxC,EAAS9M,GAAUgD,QAAQ9lC,GAC3BgrC,EAAS5H,GAAY0C,QAAQ7lC,GAC7B4yC,EAAa/P,GAAUgD,QAAQqJ,EAAIZ,QACnCuE,EAAYhQ,GAAUgD,QAAQqJ,EAAIX,KAClCqB,EAAW53C,KAAK6tC,UAEhBS,EAASsJ,EAASxxC,QAClBuxC,EACA5E,EACA6H,EACAC,EACAn0C,EACAC,GASJ,OANAgxC,EAAO1xC,OACP8sC,EAAO9sC,OACP20C,EAAW30C,OACX40C,EAAU50C,OACV2xC,EAAS3xC,OAEFqoC,CACV,CAED9mC,oBACI0vC,EACAnvC,EACAC,EACAtB,EACAC,GAEA,IAAIgxC,EAAS9M,GAAUgD,QAAQ9lC,GAC3BgrC,EAAS5H,GAAY0C,QAAQ7lC,GAC7B4yC,EAAa/P,GAAUgD,QAAQqJ,EAAIZ,QACnCuE,EAAYhQ,GAAUgD,QAAQqJ,EAAIX,KAClCqB,EAAW53C,KAAK6tC,UAEhBS,EAASmI,GAAgBpJ,QACzBuK,EAASpwC,oBACLmwC,EACA5E,EACA6H,EACAC,EACAn0C,EACAC,IAUR,OANAgxC,EAAO1xC,OACP8sC,EAAO9sC,OACP20C,EAAW30C,OACX40C,EAAU50C,OACV2xC,EAAS3xC,OAEFqoC,CACV,GAOL,SAAY3C,GACRA,EAAAA,EAAA,KAAA,GAAA,OACAA,EAAAA,EAAA,OAAA,GAAA,SACAA,EAAAA,EAAA,QAAA,GAAA,UACAA,EAAAA,EAAA,QAAA,GAAA,UACAA,EAAAA,EAAA,SAAA,GAAA,WACAA,EAAAA,EAAA,SAAA,GAAA,WACAA,EAAAA,EAAA,QAAA,GAAA,UACAA,EAAAA,EAAA,YAAA,GAAA,cAEAA,EAAAA,EAAA,cAAA,GAAA,gBACAA,EAAAA,EAAA,YAAA,IAAA,cACAA,EAAAA,EAAA,cAAA,IAAA,gBACAA,EAAAA,EAAA,mBAAA,IAAA,qBACAA,EAAAA,EAAA,UAAA,IAAA,YACAA,EAAAA,EAAA,OAAA,IAAA,QACH,CAhBD,CAAYA,KAAAA,GAgBX,CAAA,IAUD,SAAYC,GAiBRA,EAAAA,EAAA,8BAAA,GAAA,gCAMAA,EAAAA,EAAA,SAAA,GAAA,WAOAA,EAAAA,EAAA,yBAAA,IAAA,2BAQAA,EAAAA,EAAA,4BAAA,IAAA,8BASAA,EAAAA,EAAA,2BAAA,IAAA,6BAWAA,EAAAA,EAAA,mBAAA,KAAA,oBACH,CA3DD,CAAYA,KAAAA,GA2DX,CAAA,IAKK,MAAOrnC,WAAaq1C,GAYtB1zC,YAAY87B,GACRgV,QAZKh3C,KAAAuvC,KAAO5D,GAAUpnC,KAatBvE,KAAKgiC,OAASA,CACjB,CAEM6L,UACH,OAAOxlC,GAASyyC,KAAK96C,KAAKgiC,OAC7B,EAGC,MAAO58B,WAAkBw0C,GAa3B1zC,YAAYmV,GACR27B,QAbKh3C,KAAAuvC,KAAO5D,GAAUvmC,UActBpF,KAAKqb,OAASA,CACjB,CAEMwyB,UACH,IAAIkN,EAAIlQ,GAAUgD,QAAQ7tC,KAAKqb,QAC3BizB,EAASjmC,GAAS2yC,UAAUD,GAEhC,OADAA,EAAE90C,OACKqoC,CACV,EAMC,MAAO9pC,WAAeo1C,GAcxB1zC,YAAYy7B,EAAYC,GACpBoV,QAdKh3C,KAAAuvC,KAAO5D,GAAUnnC,OAetBxE,KAAKi7C,YAAcpQ,GAAUC,IAAInJ,EAAIC,EACxC,CAKMiM,UAEH,OAAOxlC,GAAS6yC,OAAOl7C,KAAKi7C,YAAY95C,EAAGnB,KAAKi7C,YAAY/uC,EAG/D,EAMC,MAAOjH,WAAoB20C,GAqB7B1zC,YAAYy7B,EAAYC,EAAYE,GAChCkV,QArBKh3C,KAAAuvC,KAAO5D,GAAU1mC,YAsBtBjF,KAAKi7C,YAAcpQ,GAAUC,IAAInJ,EAAIC,GACrC5hC,KAAK8hC,aAAeA,CACvB,CAKM+L,UAEH,OAAOxlC,GAAS8yC,YACZn7C,KAAKi7C,YAAY95C,EACjBnB,KAAKi7C,YAAY/uC,EACjBlM,KAAK8hC,aAIZ,EAMC,MAAOr9B,WAAgBm1C,GAkBzB1zC,YAAYi8B,EAAoBH,GAC5BgV,QAlBKh3C,KAAAuvC,KAAO5D,GAAUlnC,QAmBtBzE,KAAKmiC,WAAaA,EAClBniC,KAAKgiC,OAASA,CACjB,CAEM6L,UACH,OAAOxlC,GAAS+yC,QAAQp7C,KAAKmiC,WAAYniC,KAAKgiC,OACjD,EAMC,MAAOt9B,WAAgBk1C,GAkBzB1zC,YAAYm1C,EAAWC,GACnBtE,QAlBKh3C,KAAAuvC,KAAO5D,GAAUjnC,QAmBtB1E,KAAKq7C,EAAIA,EACTr7C,KAAKs7C,EAAIA,CACZ,CAEMzN,UACH,IAAI0N,EAAK1Q,GAAUgD,QAAQ7tC,KAAKq7C,GAC5BzI,EAAK/H,GAAUgD,QAAQ7tC,KAAKs7C,GAC5BhN,EAASjmC,GAASmzC,QAAQD,EAAI3I,GAGlC,OAFA2I,EAAGt1C,OACH2sC,EAAG3sC,OACIqoC,CACV,EAMC,MAAO1pC,WAAiBg1C,GAyB1B1zC,YAAYm1C,EAAWC,EAAWG,GAC9BzE,QAzBKh3C,KAAAuvC,KAAO5D,GAAU/mC,SA0BtB5E,KAAKq7C,EAAIA,EACTr7C,KAAKs7C,EAAIA,EACTt7C,KAAKy7C,EAAIA,CACZ,CAEM5N,UACH,IAAI0N,EAAK1Q,GAAUgD,QAAQ7tC,KAAKq7C,GAC5BzI,EAAK/H,GAAUgD,QAAQ7tC,KAAKs7C,GAC5BI,EAAK7Q,GAAUgD,QAAQ7tC,KAAKy7C,GAC5BnN,EAASjmC,GAASszC,SAASJ,EAAI3I,EAAI8I,GAIvC,OAHAH,EAAGt1C,OACH2sC,EAAG3sC,OACHy1C,EAAGz1C,OACIqoC,CACV,EAMC,MAAOppC,WAAsB00C,GAiC/B1zC,YAAYm1C,EAAWC,EAAWG,EAAW3Z,GACzCkV,QAjCKh3C,KAAAuvC,KAAO5D,GAAUzmC,cAkCtBlF,KAAKq7C,EAAIA,EACTr7C,KAAKs7C,EAAIA,EACTt7C,KAAKy7C,EAAIA,EACTz7C,KAAK8hC,aAAeA,CACvB,CAEM+L,UACH,IAAI0N,EAAK1Q,GAAUgD,QAAQ7tC,KAAKq7C,GAC5BzI,EAAK/H,GAAUgD,QAAQ7tC,KAAKs7C,GAC5BI,EAAK7Q,GAAUgD,QAAQ7tC,KAAKy7C,GAC5BnN,EAASjmC,GAASuzC,cAAcL,EAAI3I,EAAI8I,EAAI17C,KAAK8hC,cAIrD,OAHAyZ,EAAGt1C,OACH2sC,EAAG3sC,OACHy1C,EAAGz1C,OACIqoC,CACV,EAMC,MAAO3pC,WAAiBi1C,GAoB1B1zC,YAAYuY,EAAwBokB,GAChCmU,QApBKh3C,KAAAuvC,KAAO5D,GAAUhnC,SAqBtB3E,KAAKye,SAAWA,EAChBze,KAAK6iC,QAAUA,QAAAA,EAAW,IAAIngC,YAAY,EAC7C,CAEMmrC,UACH,OAAOxlC,GAASwzC,SAAS77C,KAAKye,SAAUze,KAAK6iC,QAChD,EAMC,MAAOx9B,WAAeu0C,GAyBxB1zC,YAAY24B,EAAiCid,GACzC9E,QAzBKh3C,KAAAuvC,KAAO5D,GAAUtmC,OA0BtBrF,KAAK6+B,KAAOA,EACZ7+B,KAAK87C,UAAYA,CACpB,CAEMjO,UACH,IAEIS,EAFAwN,EAAYjR,GAAUgD,QAAQ7tC,KAAK87C,WAUvC,OANIxN,EADAtuC,KAAK6+B,gBAAgB18B,WACZkG,GAAS0zC,OAAOD,EAAW97C,KAAK6+B,MAEhCx2B,GAAS2zC,iBAAiBF,EAAW97C,KAAK6+B,MAGvDid,EAAU71C,OACHqoC,CACV,EAMC,MAAOzpC,WAAgB+0C,GAwBzB1zC,YACIuY,EACAokB,EACAI,GAEA+T,QA5BKh3C,KAAAuvC,KAAO5D,GAAU9mC,QA6BtB7E,KAAKye,SAAWA,EAChBze,KAAK6iC,QAAUA,EACf7iC,KAAKijC,MAAQA,CAChB,CAEM4K,UACH,OAAOxlC,GAAS4zC,QAAQj8C,KAAKye,SAAUze,KAAK6iC,QAAS7iC,KAAKijC,MAC7D,EAOC,MAAOj+B,WAAsB40C,GAqB/B1zC,YAAYuY,EAAwBy9B,GAChClF,QArBKh3C,KAAAuvC,KAAO5D,GAAU3mC,cAsBtBhF,KAAKye,SAAWA,EAChBze,KAAKk8C,4BAA8BA,CACtC,CAEMrO,UACH,OAAI7tC,KAAKk8C,0BACE7zC,GAAS8zC,eAAen8C,KAAKye,UAE7BpW,GAAS+zC,WAAWp8C,KAAKye,SAEvC,EAMC,MAAOtZ,WAA2By0C,GA2BpC1zC,YACIuY,EACAqjB,EACAoa,GAEAlF,QA/BKh3C,KAAAuvC,KAAO5D,GAAUxmC,mBAgCtBnF,KAAKye,SAAWA,EAChBze,KAAK8hC,aAAeA,EACpB9hC,KAAKk8C,4BAA8BA,CACtC,CAEMrO,UACH,OAAI7tC,KAAKk8C,0BACE7zC,GAASg0C,oBACZr8C,KAAKye,SACLze,KAAK8hC,cAGFz5B,GAASi0C,gBAAgBt8C,KAAKye,SAAUze,KAAK8hC,aAE3D,EAMC,MAAOqY,WAAoBP,GAmB7B1zC,YAAYi9B,EAAuBC,GAC/B4T,QAnBKh3C,KAAAuvC,KAAO5D,GAAU7mC,YAoBtB9E,KAAKmjC,QAAUA,EACfnjC,KAAKojC,MAAQA,CAChB,CAEMyK,UACH,IAAI0O,EAAW1R,GAAUgD,QAAQ7tC,KAAKojC,OAClCwU,EAAWvvC,GAASm0C,YAAYx8C,KAAKmjC,QAASoZ,GAElD,OADAA,EAASt2C,OACF2xC,CACV,QoBriCQ6E,GAUTv2C,YAAY6kC,GACR/qC,KAAK+qC,IAAMA,GAAO,IAAI5b,EACzB,CATMlpB,OACGjG,KAAK+qC,KACP/qC,KAAK+qC,IAAI9kC,OAEbjG,KAAK+qC,SAAM3rC,CACd,CAMMqyB,KACHC,EACAC,EACA3Y,EACA4Y,EACAC,EACAvrB,EACAC,EACA0sC,EACAC,EACAwJ,EACAvqB,EACAhc,GAEA,IAAIwmC,EAAO9R,GAAUgD,QAAQnc,GAEvBS,EACFnyB,KAAK+qC,IAAI7Y,eACLyqB,EACAhrB,EAAsBoZ,IACtB/xB,EAAQ+xB,IACRnZ,EAAWmZ,IACXlZ,EAAYkZ,IACZzkC,EAAOykC,IACPxkC,EAAUwkC,IACVkI,EAAclI,IACdmI,EAAgBnI,IAChB2R,EAAU3R,IACV5Y,EAAW4Y,IACX50B,EACEA,EAAQA,EAAMymC,kBAAoB,KAClCzmC,EAAQA,EAAM0mC,uBAAyB,MAG7C78C,KAAK+qC,IAAItZ,KACLkrB,EACAhrB,EAAsBoZ,IACtB/xB,EAAQ+xB,IACRnZ,EAAWmZ,IACXlZ,EAAYkZ,IACZzkC,EAAOykC,IACPxkC,EAAUwkC,IACVkI,EAAclI,IACdmI,EAAgBnI,IAChB2R,EAAU3R,KAIlB4R,EAAK12C,MACR,QCjEQ62C,GAaT52C,YAAY6kC,GACR/qC,KAAK+qC,IAAMA,GAAO,IAAI3J,EACzB,CATDn7B,OACUjG,KAAK+qC,KACP/qC,KAAK+qC,IAAI9kC,OAEbjG,KAAK+qC,SAAM3rC,CACd,CAiBMiiC,aACH3P,EACAC,EACA3Y,EACA4Y,EACAC,EACAvrB,EACAC,EACA0sC,EACAC,GAEA,IAAI6J,EAASlS,GAAUgD,QAAQnc,GAE/B,MAAMsZ,EAAMhrC,KAAK+qC,IAAI1J,aACjB0b,EACAprB,EAAsBoZ,IACtB/xB,EAAQ+xB,IACRnZ,EAAWmZ,IACXlZ,EAAYkZ,IACZzkC,EAAOykC,IACPxkC,EAAUwkC,IACVkI,EAAclI,IACdmI,EAAgBnI,KAIpB,OAFAgS,EAAO92C,OAEA+kC,CACV,CAOMzJ,eAAe1C,GAClB,OAAOme,GAAM3P,QAAQrtC,KAAK+qC,IAAIxJ,eAAe1C,GAChD,QCnEQoe,GAeT/2C,YAAYuY,EAAwBE,GAChC3e,KAAKye,SAAWA,EAChBze,KAAK2e,OAASA,CACjB,QASQu+B,GAiBTh3C,YAAY6kC,GACR/qC,KAAK+qC,IAAMA,GAAO,IAAIxsB,CACzB,CAXDtY,OACUjG,KAAK+qC,KACP/qC,KAAK+qC,IAAI9kC,OAEbjG,KAAK+qC,SAAM3rC,EACXY,KAAKye,cAAWrf,EAChBY,KAAK2e,YAASvf,CACjB,CAMMyf,OACHvY,EACAC,EACAuY,EACAC,EACA1Y,EACA8wC,EACAI,GAEAv3C,KAAK+qC,IAAIlsB,OACLvY,EAAOykC,IACPxkC,EAAUwkC,IACVjsB,EAAeisB,IACfhsB,EAAiBgsB,IACjB1kC,EAAa0kC,IACboM,EACA5wC,EAAU42C,YAAY5F,IAE1Bv3C,KAAKye,SAAWze,KAAK+qC,IAAItsB,WACzBze,KAAK2e,OAAS3e,KAAK+qC,IAAIpsB,QAC1B,QCnEQy+B,UAuBAC,GAYTn3C,YACIkjB,EACA5D,EACAoM,EACAC,EACAvrB,EACAC,GAEAvG,KAAKwlB,OAASA,EACdxlB,KAAKsG,OAASA,EACdtG,KAAKuG,UAAYA,EACjBvG,KAAK4xB,WAAaA,EAClB5xB,KAAK6xB,YAAcA,EACnB7xB,KAAK+qC,IAAM,IAAI5hB,GAAgCC,GAC/CppB,KAAKs9C,sBAAwB,IAAIjzC,EACjCrK,KAAKu9C,+BAAgC,EACrCv9C,KAAKw9C,eAAiB,IACzB,CAGMv3C,OACGjG,KAAK+qC,MACP/qC,KAAK+qC,IAAI9kC,OACTjG,KAAKs9C,sBAAsBr3C,QAG/BjG,KAAK+qC,SAAM3rC,EACXY,KAAKs9C,2BAAwBl+C,CAChC,CAKMkqB,KACH,OAAOtpB,KAAK+qC,IAAIzhB,IACnB,CAKMC,MAAMC,GACT,IAAIi0B,EAAU5S,GAAUgD,QAAQrkB,GAChC,OAAOxpB,KAAK+qC,IAAIxhB,MAAMk0B,EAEzB,CAEMC,+BACH,OAAO19C,KAAKu9C,6BACf,CAEMI,gCAAgCntC,GACnCxQ,KAAKu9C,8BAAgC/sC,CACxC,CAKMotC,gBACH,OAAO59C,KAAKw9C,cACf,CAYMK,iBAAiBzmC,GACpBpX,KAAKw9C,eAAiBpmC,CACzB,CAQMgS,SACH,OAAOppB,KAAK+qC,IAAI3hB,QACnB,CAQMU,UAAUpC,GACb1nB,KAAK+qC,IAAIjhB,UAAUpC,EACtB,CAUMgC,oBACH,OAAO1pB,KAAK+qC,IAAIrhB,mBACnB,CAUME,qBAAqBlC,GACxB1nB,KAAK+qC,IAAInhB,qBAAqBlC,EACjC,CAKMsC,eACH,OAAOhqB,KAAK+qC,IAAI/gB,cACnB,CAKME,gBAAgB1Z,GACnBxQ,KAAK+qC,IAAI7gB,gBAAgB1Z,EAC5B,CAKM4Z,oBACH,OAAOpqB,KAAK+qC,IAAI3gB,mBACnB,CAKME,mBACH,OAAOtqB,KAAK+qC,IAAIzgB,kBACnB,CAKME,gCACH,OAAOxqB,KAAK+qC,IAAIvgB,+BACnB,CAKME,kBACH,OAAO1qB,KAAK+qC,IAAIrgB,iBACnB,CASME,eACHC,EACAC,EACAC,GAEA/qB,KAAK+qC,IAAIngB,eAAeC,EAAWC,EAAUC,EAChD,CAKME,kBACH,OAAOjrB,KAAK+qC,IAAI9f,iBACnB,CAMME,qBACH,OAAOnrB,KAAK+qC,IAAI5f,oBACnB,CAMMC,sBAAsB7e,GACzBvM,KAAK+qC,IAAI3f,sBAAsB7e,EAClC,CAMM8e,qBACH,OAAOrrB,KAAK+qC,IAAI1f,oBACnB,CAMME,sBAAsBhf,GACzBvM,KAAK+qC,IAAIxf,sBAAsBhf,EAClC,CAMMkf,uBACH,OAAOzrB,KAAK+qC,IAAItf,sBACnB,CAMME,mBAAmBC,GACtB5rB,KAAK+qC,IAAIpf,mBAAmBC,EAC/B,CAKME,sBACH9rB,KAAK+qC,IAAIjf,qBACZ,CAKME,sBACH,OAAOhsB,KAAK+qC,IAAI/e,qBACnB,CAaME,wBACHgjB,EACA4O,EACA3G,EACAC,EACAG,GAEA,IAAIwG,EAAsBlT,GAAUgD,QAAQiQ,GAC5C99C,KAAK+qC,IAAI7e,wBACLlsB,KAAKwlB,OAAOgB,GACZxmB,KAAK4xB,WAAWmZ,IAChB/qC,KAAK6xB,YAAYkZ,IACjB/qC,KAAKsG,OAAOykC,IACZ/qC,KAAKuG,UAAUwkC,IACfmE,EAAS3kC,OACTwzC,EACA/9C,KAAKu9C,8BACLv9C,KAAKw9C,eACLrG,EACAC,EACAp3C,KAAKuG,UAAU42C,YAAY5F,IAE/BwG,EAAoB93C,MACvB,CAKM0mB,mBACH,OAAOke,GAAUwC,QAAQrtC,KAAK+qC,IAAIpe,mBACrC,CAKME,mBACH,OAAO7sB,KAAK+qC,IAAIle,kBACnB,CAMME,wBACH,OAAO/sB,KAAK+qC,IAAIhe,uBACnB,CASME,kBACH/Q,EACA+uB,GAEA,GAAKjrC,KAAK+qC,IAAI9d,kBAAkB/Q,EAAGlc,KAAKs9C,uBAEjC,CACH,IAAI7B,EAAIz7C,KAAKs9C,sBAcb,OAbArS,EAAMA,QAAAA,EAAO,IAAImS,IACb3yC,wBAA0BogC,GAAUwC,QACpCoO,EAAEhxC,2BAENwgC,EAAItgC,0BAA4BkgC,GAAUwC,QACtCoO,EAAE9wC,6BAENsgC,EAAIpgC,IAAM4wC,EAAE5wC,MACZogC,EAAIpxB,SAAWgxB,GAAUwC,QAAQoO,EAAE1wC,iBACnCkgC,EAAIlxB,SAAW8wB,GAAUwC,QAAQoO,EAAExwC,iBACnCggC,EAAIhxB,QAAU4wB,GAAUwC,QAAQoO,EAAEtwC,gBAClC8/B,EAAI9wB,QAAU0wB,GAAUwC,QAAQoO,EAAEpwC,gBAClC4/B,EAAIiE,SAAWlvC,KAAKuG,UAAU4jC,IAAIsR,EAAElxC,UAC7B0gC,CACV,CAjBG,OAAO,IAkBd,GtB1WL,SAAYY,GACRA,EAAAA,EAAA,KAAA,GAAA,OACAA,EAAAA,EAAA,KAAA,GAAA,OACAA,EAAAA,EAAA,KAAA,GAAA,OACAA,EAAAA,EAAA,KAAA,GAAA,OACAA,EAAAA,EAAA,KAAA,IAAA,OAEAA,EAAAA,EAAA,OAAA,GAAA,SACAA,EAAAA,EAAA,OAAA,IAAA,SAEAA,EAAAA,EAAA,IAAA,IAAA,KACH,CAXD,CAAYA,KAAAA,GAWX,CAAA,UAMYmS,GAMT93C,YACIsf,EACAlf,EACAqsB,EACAC,EACAC,EACAI,GAEAjzB,KAAKwlB,OAASA,EACdxlB,KAAKsG,OAASA,EACdtG,KAAK+qC,IAAM,IAAIrY,GAAiBC,EAAIC,EAAIC,EAAII,EAC/C,CAGMhtB,OACGjG,KAAK+qC,KACP/qC,KAAK+qC,IAAI9kC,OAGbjG,KAAK+qC,SAAM3rC,CACd,CAEM6+C,MAAMtrB,EAAYM,GACrBjzB,KAAK+qC,IAAI/X,OAAOL,EAAIM,EACvB,CAEMirB,MAAMtrB,EAAYK,GACrBjzB,KAAK+qC,IAAI/X,OAAOJ,EAAIK,EACvB,CAEMkrB,MAAMtrB,EAAYI,GACrBjzB,KAAK+qC,IAAI/X,OAAOH,EAAII,EACvB,CAEMmrB,QAAQnrB,GACXjzB,KAAK+qC,IAAIxX,cAAcN,EAC1B,CAEMorB,iBACHr+C,KAAK+qC,IAAItX,iBACZ,CAEM6qB,sBACHn4B,EACAo4B,EACAC,GAEA,IAAI7G,EAAS9M,GAAUgD,QAAQ0Q,GAC3B3Q,EAAS/C,GAAUgD,QAAQ2Q,GAC/Bx+C,KAAK+qC,IAAIpX,wBACL3zB,KAAKwlB,OAAOgB,GACZxmB,KAAKsG,OAAOykC,IACZ5kB,EAAK5b,OACLotC,EACA/J,GAEJ+J,EAAO1xC,OACP2nC,EAAO3nC,MACV,CAGMw4C,uBACHt4B,EACAu4B,EACAC,GAEA3+C,KAAK+qC,IAAI/W,yBACLh0B,KAAKwlB,OAAOgB,GACZxmB,KAAKsG,OAAOykC,IACZ5kB,EAAK5b,OACLm0C,EACAC,EAEP,CAIMC,iBACHz4B,EACAo4B,EACAC,GAEA,IAAI7G,EAAS9M,GAAUgD,QAAQ0Q,GAC3B3Q,EAAS/C,GAAUgD,QAAQ2Q,GAC3BK,EAAa7+C,KAAK+qC,IAAI3W,kBACtBp0B,KAAKwlB,OAAOgB,GACZxmB,KAAKsG,OAAOykC,IACZ5kB,EAAK5b,OACLotC,EACA/J,GAKJ,OAHA+J,EAAO1xC,OACP2nC,EAAO3nC,OAEA4kC,GAAUwC,QAAQwR,EAC5B,CAGMC,kBACH34B,EACAu4B,EACAC,GAEA,OAAO3+C,KAAK+qC,IAAIzW,mBACZt0B,KAAKwlB,OAAOgB,GACZxmB,KAAKsG,OAAOykC,IACZ5kB,EAAK5b,OACLm0C,EACAC,EAEP,QuBtFQ3B,GA0DT92C,YACIwrB,EACAqtB,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,GAEA1/C,KAAK0xB,QAAUA,EACf1xB,KAAK2xB,sBAAwB,IAAI2hB,GAC7ByL,GAEJ/+C,KAAKgZ,QAAU,IAAIo9B,GAAc4I,GACjCh/C,KAAK4xB,WAAa,IAAIqlB,GAAWgI,GACjCj/C,KAAK6xB,YAAc,IAAIomB,GAAYiH,GACnCl/C,KAAKsG,OAAS,IAAIosC,GAAayM,GAC/Bn/C,KAAKuG,UAAY,IAAIo5C,GAAYP,GACjCp/C,KAAKizC,cAAgB,IAAIwC,GAAgB4J,GACzCr/C,KAAKkzC,gBAAkB,IAAIgD,GAAkBoJ,GAC7Ct/C,KAAK08C,UAAY,IAAIvG,GAAUoJ,GAC/Bv/C,KAAK4/C,gBAAkB,IAAInD,GAAgB+C,GAC3Cx/C,KAAK6/C,sBAAwB,IAAI/C,GAC7B2C,GAEJz/C,KAAK8/C,oBAAsB,IAAI5C,GAC3BwC,GAEJ1/C,KAAK+/C,qBAAuB,IAAIC,IAChChgD,KAAKigD,eAAiB,IAAID,IAG1BhgD,KAAKizC,cAAc1G,wBAAwBvsC,KAAKsG,QAChDtG,KAAKsG,OAAOimC,wBAAwBvsC,KAAKuG,WACzCvG,KAAKuG,UAAUgmC,wBAAwBvsC,KAAKsG,OAC/C,CA3EML,OACHjG,KAAK2xB,sBAAsB1rB,OAC3BjG,KAAKgZ,QAAQ/S,OACbjG,KAAK4xB,WAAW3rB,OAChBjG,KAAK6xB,YAAY5rB,OACjBjG,KAAKsG,OAAOL,OACZjG,KAAKuG,UAAUN,OACfjG,KAAKizC,cAAchtC,OACnBjG,KAAKkzC,gBAAgBjtC,OACrBjG,KAAK08C,UAAUz2C,OACfjG,KAAK4/C,gBAAgB35C,OACrBjG,KAAK6/C,sBAAsB55C,OAC3BjG,KAAK8/C,oBAAoB75C,OACzBjG,KAAK+/C,qBAAqBzN,SAAS4N,GAAeA,EAAWj6C,SAC7DjG,KAAKigD,eAAe3N,SAAS4N,GAAeA,EAAWj6C,SAGvDjG,KAAK2xB,2BAAwBvyB,EAC7BY,KAAKgZ,aAAU5Z,EACfY,KAAK4xB,gBAAaxyB,EAClBY,KAAK6xB,iBAAczyB,EACnBY,KAAKsG,YAASlH,EACdY,KAAKuG,eAAYnH,EACjBY,KAAK08C,eAAYt9C,EACjBY,KAAKizC,mBAAgB7zC,EACrBY,KAAKkzC,qBAAkB9zC,EACvBY,KAAK4/C,qBAAkBxgD,EACvBY,KAAK6/C,2BAAwBzgD,EAC7BY,KAAK8/C,yBAAsB1gD,EAC3BY,KAAK+/C,0BAAuB3gD,EAC5BY,KAAKigD,oBAAiB7gD,CAEzB,CA6CMwG,eAAemlC,GAClB,OAAKA,EAEE,IAAIiS,GACPnS,GAAUwC,QAAQtC,EAAIzrB,eACtByrB,EAAIvrB,4BACJurB,EAAIprB,oBACJorB,EAAIlrB,iBACJkrB,EAAIhrB,kBACJgrB,EAAI9qB,aACJ8qB,EAAI5qB,gBACJ4qB,EAAI1qB,oBACJ0qB,EAAIxqB,uBAXS,IAapB,CAQM4/B,eACH,OAAOngD,KAAK6/C,sBAAsBxe,aAC9BrhC,KAAK0xB,QACL1xB,KAAK2xB,sBACL3xB,KAAKgZ,QACLhZ,KAAK4xB,WACL5xB,KAAK6xB,YACL7xB,KAAKsG,OACLtG,KAAKuG,UACLvG,KAAKizC,cACLjzC,KAAKkzC,gBAEZ,CAOMttC,uBAAuBi5B,GAE1B,OADY,IAAIie,IACHvb,eAAe1C,EAC/B,CASMuhB,YACHjJ,EACAI,GAWA,OATAv3C,KAAK8/C,oBAAoBjhC,OACrB7e,KAAKsG,OACLtG,KAAKuG,UACLvG,KAAKizC,cACLjzC,KAAKkzC,gBACLlzC,KAAK6xB,YACLslB,EACAI,GAEG,IAAI0F,GACPj9C,KAAK8/C,oBAAoBrhC,SACzBze,KAAK8/C,oBAAoBnhC,OAEhC,CAUM8S,KAAKU,EAAyBhc,GACjCnW,KAAK4/C,gBAAgBnuB,KACjBzxB,KAAK0xB,QACL1xB,KAAK2xB,sBACL3xB,KAAKgZ,QACLhZ,KAAK4xB,WACL5xB,KAAK6xB,YACL7xB,KAAKsG,OACLtG,KAAKuG,UACLvG,KAAKizC,cACLjzC,KAAKkzC,gBACLlzC,KAAK08C,UACLvqB,EACAhc,EAEP,CASMqqB,4CACHxgC,KAAKsG,OAAOykC,IAAIvK,0CACZxgC,KAAKuG,UAAUwkC,IAEtB,CAgBGsV,eACA,OAAOrgD,KAAK2xB,sBAAsBnL,EACrC,CAcG65B,aAAS75B,GACTxmB,KAAK2xB,sBAAsBnL,GAAKA,CACnC,CAOGiB,iBACA,OAAOznB,KAAK2xB,sBAAsBlK,UACrC,CAiBGA,eAAW64B,GACXtgD,KAAK2xB,sBAAsBlK,WAAa64B,CAC3C,CAKGv5B,0BACA,OAAO/mB,KAAK2xB,sBAAsB5K,mBACrC,CAUGA,wBAAoBw5B,GACpBvgD,KAAK2xB,sBAAsB5K,oBAAsBw5B,CACpD,CAKGt5B,sCACA,OAAOjnB,KAAK2xB,sBAAsB1K,+BACrC,CAUGA,oCAAgCs5B,GAChCvgD,KAAK2xB,sBAAsB1K,gCAAkCs5B,CAChE,CAKGp5B,+BACA,OAAOnnB,KAAK2xB,sBAAsBxK,wBACrC,CAUGA,6BAAyBo5B,GACzBvgD,KAAK2xB,sBAAsBxK,yBAA2Bo5B,CACzD,CAKGh5B,qBACA,OAAOvnB,KAAK2xB,sBAAsBpK,cACrC,CAYGA,mBAAei5B,GACfxgD,KAAK2xB,sBAAsBpK,eAAiBi5B,CAC/C,CAaMl4B,4BACHtoB,KAAK2xB,sBAAsBrJ,2BAC9B,CAWME,8BACHxoB,KAAK2xB,sBAAsBnJ,6BAC9B,CAWME,8CACH1oB,KAAK2xB,sBAAsBjJ,6CAC9B,CAOM0W,gBAAgBjZ,GACnB,OAAOnmB,KAAKsG,OAAO84B,gBAAgBp/B,KAAKuG,UAAW4f,EACtD,CAOMs6B,0BACHr3B,GAEA,IAAI82B,EAAa,IAAI7C,GACjBj0B,EACAppB,KAAK2xB,sBACL3xB,KAAK4xB,WACL5xB,KAAK6xB,YACL7xB,KAAKsG,OACLtG,KAAKuG,WAGT,OADAvG,KAAK+/C,qBAAqBW,IAAIR,GACvBA,CACV,CAOMS,0BAA0BT,GAC7BlgD,KAAK+/C,qBAAqB1N,OAAO6N,GACjCA,EAAWj6C,MACd,CAiBM26C,oBACHjuB,EACAC,EACAC,EACAI,GAEA,IAAIitB,EAAa,IAAIlC,GACjBh+C,KAAK2xB,sBACL3xB,KAAKsG,OACLqsB,EACAC,EACAC,EACAI,GAGJ,OADAjzB,KAAKigD,eAAeS,IAAIR,GACjBA,CACV,CAOMW,oBAAoBX,GACvBlgD,KAAKigD,eAAe5N,OAAO6N,GAC3BA,EAAWj6C,MACd,CASM6R,eAAe+6B,EAAoBh6B,GACtC,IAAIioC,EAAejoC,EAASA,EAAOtO,YAASnL,EAC5C,OAAOY,KAAKuG,UAAUuR,eAAe9X,KAAKsG,OAAQusC,EAAMiO,EAC3D,CAUMC,mBACHv7B,EACAC,EACAC,EACAzM,GAEA,OAAOjZ,KAAKizC,cAAc1tB,YACtBvlB,KAAKsG,OACLkf,EACAC,EAAQlb,OACRmb,EAAQnb,OACR0O,EAEP,CAUM+nC,qBACHx7B,EACAC,EACAC,EACAzM,GAEA,OAAOjZ,KAAKkzC,gBAAgB3tB,YACxBC,EACAC,EAAQlb,OACRmb,EAAQnb,OACR0O,EAEP,CAOMgoC,aAAa12C,GAChB,OAAOvK,KAAKsG,OAAO6jC,IAAI5/B,EAC1B,CAOM22C,YAAY32C,GACf,OAAOvK,KAAKuG,UAAU4jC,IAAI5/B,EAC7B,CAOM42C,gBAAgB52C,GACnB,OAAOvK,KAAKizC,cAAc9I,IAAI5/B,EACjC,CAOM62C,kBAAkB72C,GACrB,OAAOvK,KAAKkzC,gBAAgB/I,IAAI5/B,EACnC,CAUM82C,gBAAgBl7B,GACfnmB,KAAKsG,QACLtG,KAAKsG,OAAOyS,OACRoN,EAAK5b,OACLvK,KAAKgZ,QACLhZ,KAAKuG,UACLvG,KAAKizC,cACLjzC,KAAKkzC,gBAGhB,CAQMoO,eAAepS,EAAoBj2B,GAClCjZ,KAAKuG,WACLvG,KAAKuG,UAAUwS,OACXm2B,EAAS3kC,OACTvK,KAAKgZ,QACLhZ,KAAKsG,OACL2S,EAGX,CAQMsoC,mBAAmB5L,EAAqB18B,GACvCjZ,KAAKizC,eACLjzC,KAAKizC,cAAcl6B,OAAO48B,EAAMprC,OAAQ0O,EAE/C,CAQMuoC,qBAAqB7L,EAAuB18B,GAC3CjZ,KAAKizC,eACLjzC,KAAKkzC,gBAAgBn6B,OAAO48B,EAAMprC,OAAQ0O,EAEjD,CAOMwoC,gBAAgB5hD,GACnBG,KAAKuG,UAAU+rC,QAAQzyC,EAC1B,CAOM6hD,iBAAiB7hD,GACpBG,KAAKsG,OAAOgsC,QAAQzyC,EACvB,CAWMwzC,uBAAuBxzC,GAC1BG,KAAKsG,OAAO+sC,uBAAuBrzC,KAAKgZ,QAASnZ,EACpD,CAcMuG,QACH8wC,EACAxwC,EACAC,EACAwwC,EACAC,EACAC,EACAC,EACAC,GAEA,OAAOv3C,KAAK4xB,WAAWxrB,QACnBpG,KAAK6xB,YACL7xB,KAAKsG,OACLtG,KAAKuG,UACL2wC,EACAxwC,EACAC,EACAwwC,EACAC,EACAC,EAAwBA,EAAsB9sC,OAAS,KACvD+sC,EAAyBA,EAAuB/sC,OAAS,KACzDvK,KAAKuG,UAAU42C,YAAY5F,GAElC,CAcM/vC,oBACH0vC,EACAxwC,EACAC,EACAwwC,EACAC,EACAC,EACAC,EACAC,GAEA,OAAOv3C,KAAK4xB,WAAWpqB,oBACnBxH,KAAK6xB,YACL7xB,KAAKsG,OACLtG,KAAKuG,UACL2wC,EACAxwC,EACAC,EACAwwC,EACAC,EACAC,EAAwBA,EAAsB9sC,OAAS,KACvD+sC,EAAyBA,EAAuB/sC,OAAS,KACzDvK,KAAKuG,UAAU42C,YAAY5F,GAElC,CAeM5vC,qBACHuvC,EACAxwC,EACAC,EACAiB,EACAuvC,EACAC,EACAC,EACAC,EACAC,GAEAv3C,KAAK4xB,WAAWjqB,qBACZ3H,KAAK6xB,YACL7xB,KAAKsG,OACLtG,KAAKuG,UACL2wC,EACAxwC,EACAC,EACAiB,EACAuvC,EACAC,EACAC,EAAwBA,EAAsB9sC,OAAS,KACvD+sC,EAAyBA,EAAuB/sC,OAAS,KACzDvK,KAAKuG,UAAU42C,YAAY5F,GAElC,CAWMzvC,sBACHC,EACAC,EACAC,EACAkvC,EACAC,EACAC,EACAC,EACAC,GAEA,IAAIhtC,EAASvK,KAAK4xB,WAAW9pB,sBACzB9H,KAAK6xB,YACL7xB,KAAKsG,OACLtG,KAAKuG,UACLwB,EACAC,EACAC,EACAkvC,EACAC,EACAC,EAAwBA,EAAsB9sC,OAAS,KACvD+sC,EAAyBA,EAAuB/sC,OAAS,KACzDvK,KAAKuG,UAAU42C,YAAY5F,IAE/B,OAAiB,MAAVhtC,EAAiBvK,KAAKuG,UAAU4jC,IAAI5/B,GAAU,IACxD,CAcM5B,aACHC,EACAjC,EACAwwC,EACAC,EACAC,EACAC,EACAC,GAEA,OAAOv3C,KAAK4xB,WAAWjpB,aACnB3I,KAAK6xB,YACL7xB,KAAKsG,OACLtG,KAAKuG,UACLqC,EACAjC,EACAwwC,EACAC,EACAC,EAAwBA,EAAsB9sC,OAAS,KACvD+sC,EAAyBA,EAAuB/sC,OAAS,KACzDvK,KAAKuG,UAAU42C,YAAY5F,GAElC,CASMxuC,0BACHH,EACAuuC,EACAC,EACAC,EACAC,EACAC,GAEA,OAAOv3C,KAAK4xB,WAAW7oB,0BACnB/I,KAAK6xB,YACL7xB,KAAKsG,OACLtG,KAAKuG,UACLqC,EACAuuC,EACAC,EACAC,EAAwBA,EAAsB9sC,OAAS,KACvD+sC,EAAyBA,EAAuB/sC,OAAS,KACzDvK,KAAKuG,UAAU42C,YAAY5F,GAElC,CAWMtuC,uBACHL,EACAhB,EACAuvC,EACAC,EACAC,EACAC,EACAC,GAEAv3C,KAAK4xB,WAAW3oB,uBACZjJ,KAAK6xB,YACL7xB,KAAKsG,OACLtG,KAAKuG,UACLqC,EACA5I,KAAKuG,UAAU42C,YAAYv1C,GAC3BuvC,EACAC,EACAC,EAAwBA,EAAsB9sC,OAAS,KACvD+sC,EAAyBA,EAAuB/sC,OAAS,KACzDvK,KAAKuG,UAAU42C,YAAY5F,GAElC,CAqBMpuC,UACHpB,EACAC,EACAoB,EACAnB,EACA4vC,EACAnxC,EACAoxC,EACAX,EACAC,EACAC,EACAC,EACAC,GAEA,OAAOv3C,KAAK4xB,WAAWzoB,UACnBnJ,KAAK6xB,YACL7xB,KAAKsG,OACLtG,KAAKuG,UACLwB,EACAC,EACAoB,EACAnB,EACA4vC,EACAnxC,EACAoxC,EACAX,EACAC,EACAC,EAAwBA,EAAsB9sC,OAAS,KACvD+sC,EAAyBA,EAAuB/sC,OAAS,KACzDvK,KAAKuG,UAAU42C,YAAY5F,GAElC,CAYM9tC,uBACH1B,EACAC,EACAC,EACAL,EACAuvC,EACAC,EACAC,EACAC,EACAC,GAEAv3C,KAAK4xB,WAAWnoB,uBACZzJ,KAAK6xB,YACL7xB,KAAKsG,OACLtG,KAAKuG,UACLwB,EACAC,EACAC,EACAjI,KAAKuG,UAAU42C,YAAYv1C,GAC3BuvC,EACAC,EACAC,EAAwBA,EAAsB9sC,OAAS,KACvD+sC,EAAyBA,EAAuB/sC,OAAS,KACzDvK,KAAKuG,UAAU42C,YAAY5F,GAElC,CAUM5tC,kCACHC,EACAC,EACAjC,GAEA5H,KAAK4xB,WAAWjoB,kCACZ3J,KAAK6xB,YACL7xB,KAAKsG,OACLtG,KAAKuG,UACLqD,EACAC,EACA7J,KAAKuG,UAAU42C,YAAYv1C,GAElC,CAQMwwC,iBACH59B,EACA3a,GAEAG,KAAK6xB,YAAYumB,iBACb59B,EAAUjQ,OACVvK,KAAKuG,UAAU42C,YAAYt9C,GAElC,CAMMw4C,sBACH79B,EACA3a,GAEAG,KAAK6xB,YAAYwmB,sBACb79B,EAAUjQ,OACVvK,KAAKuG,UAAU42C,YAAYt9C,GAElC,CAWMy4C,YACH99B,EACAC,EACA5a,GAEAG,KAAK6xB,YAAYymB,YAAY99B,EAAUjQ,OAAQkQ,EAAUlQ,OAAQ1K,EACpE,CAOM44C,iBAAiBj+B,EAAqBC,GACzC,OAAOza,KAAK6xB,YAAY4mB,iBACpBj+B,EAAUjQ,OACVkQ,EAAUlQ,OAEjB,CAOGo3C,oBAAgBnxC,GAChBxQ,KAAK4/C,gBAAgB7U,IAAI1b,qBAAqB7e,EACjD,CAOGmxC,sBACA,OAAO3hD,KAAK4/C,gBAAgB7U,IAAIxb,qBACnC,CAOMqyB,aACH,OAAO5hD,KAAK4/C,gBAAgB7U,IAAItb,aACnC,CAQMoyB,2BACH,OAAO7hD,KAAK4/C,gBAAgB7U,IAAIpb,4BACnC,CAQMmyB,mBACH,OAAO9hD,KAAK4/C,gBAAgB7U,IAAIlb,oBACnC,CAQMkyB,oBACH,OAAO/hD,KAAK4/C,gBAAgB7U,IAAIhb,qBACnC,CAOMiyB,eACH,OAAOhiD,KAAK4/C,gBAAgB7U,IAAI9a,eACnC,CASMgyB,yBACH,OAAOjiD,KAAK4/C,gBAAgB7U,IAAI5a,0BACnC,CASM+xB,2BACH,OAAOliD,KAAK4/C,gBAAgB7U,IAAI1a,4BACnC,CASM8xB,uBACH,OAAOniD,KAAK4/C,gBAAgB7U,IAAIxa,wBACnC,CASM6xB,0BACH,OAAOpiD,KAAK4/C,gBAAgB7U,IAAIta,2BACnC,CAOM4xB,YACH,OAAOriD,KAAK4/C,gBAAgB7U,IAAIpa,YACnC,CAQM2xB,0BACH,OAAOtiD,KAAK4/C,gBAAgB7U,IAAIla,4BACnC,CAQM0xB,sBACH,OAAOviD,KAAK4/C,gBAAgB7U,IAAIha,wBACnC,CAQMyxB,uBACH,OAAOxiD,KAAK4/C,gBAAgB7U,IAAI9Z,yBACnC,CAQMwxB,kBACH,OAAOziD,KAAK4/C,gBAAgB7U,IAAI5Z,mBACnC,CAOMuxB,2BACH,OAAO1iD,KAAK4/C,gBAAgB7U,IAAI1Z,4BACnC,CAOMsxB,oBACH,OAAO3iD,KAAK4/C,gBAAgB7U,IAAIxZ,qBACnC,GtB9xCL,SAAYua,GACRA,EAAAA,EAAA,KAAA,GAAA,OAIAA,EAAAA,EAAA,iBAAA,GAAA,mBAIAA,EAAAA,EAAA,qBAAA,GAAA,sBACH,CAVD,CAAYA,KAAAA,GAUX,CAAA,UASY8W,GAGF38C,OACGjG,KAAK+qC,KACP/qC,KAAK+qC,IAAI9kC,OAEbjG,KAAK+qC,SAAM3rC,CACd,CAKMob,YACH,OAAOxa,KAAK+qC,IAAIvwB,WACnB,CAKMC,YACH,OAAOza,KAAK+qC,IAAItwB,WACnB,CAKMooC,aACH,OAAOhY,GAAUwC,QAAQrtC,KAAK+qC,IAAIpwB,cACrC,CASMmoC,sBACH,OAAO9iD,KAAK+qC,IAAIlwB,uBACnB,CAKMkoC,oBACH,OAAOlY,GAAUwC,QAAQrtC,KAAK+qC,IAAIhwB,sBACrC,CAKMioC,oBACH,OAAOhjD,KAAK+qC,IAAI/vB,qBACnB,QAUQioC,GAWT/8C,YAAY0a,EAAoBmqB,GAC5B/qC,KAAK+qC,IAAMA,GAAO,IAAIpqB,EAAcC,EACvC,CAKM3a,OACGjG,KAAK+qC,KACP/qC,KAAK+qC,IAAI9kC,OAEbjG,KAAK+qC,SAAM3rC,CACd,CAWM0hB,qBACHjhB,GAMAG,KAAK+qC,IAAIjqB,qBAAqBjhB,EACjC,CASMmhB,wBAAwBnhB,GAC3B,IAAIqjD,EAAQ,IAAIN,GAChB5iD,KAAK+qC,IAAI/pB,yBAAyB+pB,IAC9BmY,EAAMnY,IAAMA,EACZlrC,EAAEqjD,GACFA,EAAMj9C,MAAM,GAEnB,CAKMib,QACHlhB,KAAK+qC,IAAI7pB,OACZ,GCzJL,SAAY6qB,GACRA,EAAAA,EAAA,KAAA,GAAA,OACAA,EAAAA,EAAA,qBAAA,GAAA,uBACAA,EAAAA,EAAA,0BAAA,GAAA,2BAEH,CALD,CAAYA,KAAAA,GAKX,CAAA,IAED,SAAYC,GACRA,EAAAA,EAAA,MAAA,GAAA,QACAA,EAAAA,EAAA,gBAAA,GAAA,iBACH,CAHD,CAAYA,KAAAA,GAGX,CAAA,ICMD,SAAYC,GAIRA,EAAAA,EAAA,cAAA,GAAA,gBAIAA,EAAAA,EAAA,kBAAA,GAAA,oBAIAA,EAAAA,EAAA,gBAAA,GAAA,kBAIAA,EAAAA,EAAA,gBAAA,GAAA,kBAIAA,EAAAA,EAAA,eAAA,IAAA,iBAIAA,EAAAA,EAAA,aAAA,GAAA,eAKAA,EAAAA,EAAA,eAAA,GAAA,iBAMAA,EAAAA,EAAA,WAAA,GAAA,YAEH,CArCD,CAAYA,KAAAA,GAqCX,CAAA,ICfD,SAAYC,GAKRA,EAAAA,EAAA,gBAAA,GAAA,kBAKAA,EAAAA,EAAA,kBAAA,IAAA,oBAKAA,EAAAA,EAAA,cAAA,GAAA,gBAKAA,EAAAA,EAAA,oBAAA,OAAA,sBAMAA,EAAAA,EAAA,gBAAA,MAAA,kBAOAA,EAAAA,EAAA,YAAA,IAAA,cAKAA,EAAAA,EAAA,QAAA,IAAA,UAIAA,EAAAA,EAAA,IAAA,OAAA,KAMH,CAhDD,CAAYA,KAAAA,GAgDX,CAAA,UAWYiX,GAMTj9C,YACIomC,EACA/hC,EACAsO,EACA5Q,GAEAjI,KAAKssC,YAAcA,EACnBtsC,KAAKuK,OAASA,EACdvK,KAAKojD,QAAUvqC,EACf7Y,KAAKqjD,OAASp7C,CACjB,CAGMskC,wBAAwBjmC,GACR,MAAftG,KAAKuK,SACLvK,KAAKojD,QAAU98C,EAAO6jC,IAClBnqC,KAAKssC,YAAYvB,IAAI16B,SAASrQ,KAAKuK,SAG9C,CAEO+4C,sBACCtjD,KAAKqjD,SACNrjD,KAAKqjD,OAASzJ,GAAMvM,QAAQrtC,KAAKssC,YAAYvB,IAAK/qC,KAAKuK,QAC9D,CAKUtC,YAEP,OADAjI,KAAKsjD,sBACEtjD,KAAKqjD,MACf,CAUME,kBACHvjD,KAAKqjD,OAAS,IACjB,CAMM7W,UACH,OAAOxsC,KAAKssC,YAAYvB,IAAInzB,SAAS5X,KAAKuK,OAC7C,CAKMwN,cACH,OAAO8yB,GAAUwC,QACbrtC,KAAKssC,YAAYvB,IAAIt/B,cAAczL,KAAKuK,QAE/C,CAOMi5C,uBACH,OAAO3Y,GAAUwC,QACbrtC,KAAKssC,YAAYvB,IAAIl/B,uBAAuB7L,KAAKuK,QAExD,CAKMyN,WACH,OAAOmzB,GAAYkC,QACfrtC,KAAKssC,YAAYvB,IAAIp/B,WAAW3L,KAAKuK,QAE5C,CAOMk5C,oBACH,OAAOtY,GAAYkC,QACfrtC,KAAKssC,YAAYvB,IAAIh/B,oBAAoB/L,KAAKuK,QAErD,CAKM6N,WACH,OAAOpY,KAAKssC,YAAYvB,IAAIp+B,WAAW3M,KAAKuK,OAC/C,CAMMm5C,UAAUtrC,GACbpY,KAAKssC,YAAYvB,IAAIp2B,YAAY3U,KAAKuK,OAAQ6N,EACjD,CAMMurC,SAAS17C,GACZ,IAAI2vC,EAAW3vC,EAAM4lC,UACrB7tC,KAAKssC,YAAYvB,IAAIp0B,WAAW3W,KAAKuK,OAAQqtC,GAC7CA,EAAS3xC,OACTjG,KAAKqjD,OAASp7C,CACjB,CAOMknC,WAAW3+B,GACdxQ,KAAKssC,YAAYvB,IAAIx6B,aAAavQ,KAAKuK,OAAQiG,EAClD,CAKM4+B,YACH,OAAOpvC,KAAKssC,YAAYvB,IAAIr6B,YAAY1Q,KAAKuK,OAChD,CASMq5C,eAAe7uC,GAClB/U,KAAKssC,YAAYvB,IAAIj2B,iBAAiB9U,KAAKuK,OAAQwK,EACtD,CASM8uC,YAAY3uC,GACflV,KAAKssC,YAAYvB,IAAI91B,cAAcjV,KAAKuK,OAAQ2K,EACnD,CAMMgD,sBACH,OAAOlY,KAAKssC,YAAYvB,IAAI31B,sBAAsBpV,KAAKuK,OAC1D,CAQMu5C,uBAAuBvuC,GAC1BvV,KAAKssC,YAAYvB,IAAIz1B,yBAAyBtV,KAAKuK,OAAQgL,EAC9D,CAMM4C,yBACH,OAAOnY,KAAKssC,YAAYvB,IAAIt1B,yBAAyBzV,KAAKuK,OAC7D,CAQMw5C,0BAA0BxuC,GAC7BvV,KAAKssC,YAAYvB,IAAIp1B,4BAA4B3V,KAAKuK,OAAQgL,EACjE,CAUMyuC,mBAAmBluC,GACtB9V,KAAKssC,YAAYvB,IAAIl1B,qBAAqB7V,KAAKuK,OAAQuL,EAC1D,CAWMmuC,gBAAgBnuC,GACnB9V,KAAKssC,YAAYvB,IAAI/0B,kBAAkBhW,KAAKuK,OAAQuL,EACvD,CAOM6C,cACH,OAAO3Y,KAAKssC,YAAYvB,IAAIh6B,cAAc/Q,KAAKuK,OAClD,CASM25C,eAAeC,GAClB,OAAOnkD,KAAKssC,YAAYvB,IAAIn6B,iBAAiB5Q,KAAKuK,OAAQ45C,EAC7D,CAKM3rC,cACH,OAAOxY,KAAKssC,YAAYvB,IAAIh5B,cAAc/R,KAAKuK,OAClD,CASM65C,eAAe5rC,GAClBxY,KAAKssC,YAAYvB,IAAI70B,iBAAiBlW,KAAKuK,OAAQiO,EACtD,CAKMC,eACH,OAAOzY,KAAKssC,YAAYvB,IAAI54B,eAAenS,KAAKuK,OACnD,CASM85C,gBAAgB5rC,GACnBzY,KAAKssC,YAAYvB,IAAI10B,kBAAkBrW,KAAKuK,OAAQkO,EACvD,CAKMF,uBACH,OAAOvY,KAAKssC,YAAYvB,IAAI94B,uBAAuBjS,KAAKuK,OAC3D,CAOM+5C,8BAA8BxtC,GACjC,OAAO9W,KAAKssC,YAAYvB,IAAIl0B,gCACxB7W,KAAKuK,OACLuM,EAEP,CAKM4B,6BACH,OAAO1Y,KAAKssC,YAAYvB,IAAI14B,6BAA6BrS,KAAKuK,OACjE,CAOMg6C,wBAAwBhsC,GAC3BvY,KAAKssC,YAAYvB,IAAIv0B,0BACjBxW,KAAKuK,OACLgO,EAEP,CAYMisC,WAAWvtC,GACdjX,KAAKssC,YAAYvB,IAAI/zB,aAAahX,KAAKuK,OAAQ0M,EAClD,CAYMwtC,QAAQrtC,GACXpX,KAAKssC,YAAYvB,IAAI5zB,UAAUnX,KAAKuK,OAAQ6M,EAC/C,CAWMstC,kBACHttC,EACAG,EACAC,GAEA,IAAIy4B,EAASpF,GAAUgD,QAAQt2B,GAC/BvX,KAAKssC,YAAYvB,IAAIzzB,oBACjBtX,KAAKuK,OACL6M,EACA64B,EACAz4B,GAEJy4B,EAAOhqC,MACV,CASMunC,eAAeC,GAElBztC,KAAKssC,YAAYvB,IAAI9+B,iBAAiBjM,KAAKuK,OAAQkjC,EAAItsC,EAAGssC,EAAIvhC,EAEjE,CASMy4C,wBAAwBlX,GAE3BztC,KAAKssC,YAAYvB,IAAI3+B,0BACjBpM,KAAKuK,OACLkjC,EAAItsC,EACJssC,EAAIvhC,EAGX,CAQM6hC,YAAYxhC,GACfvM,KAAKssC,YAAYvB,IAAIz+B,cAActM,KAAKuK,OAAQgC,EACnD,CASMq4C,qBAAqBr4C,GACxBvM,KAAKssC,YAAYvB,IAAIt+B,uBAAuBzM,KAAKuK,OAAQgC,EAC5D,CAOMs4C,YACH,OAAO7kD,KAAKssC,YAAYvB,IAAIl+B,YACxB7M,KAAKuK,OAEZ,CAKM0wC,cACH,OAAOpQ,GAAUwC,QACbrtC,KAAKssC,YAAYvB,IAAI99B,cAAcjN,KAAKuK,QAE/C,CAOMu6C,eAAe13C,GAClB,MAAMihC,EAAWxD,GAAUgD,QAAQzgC,GACnCpN,KAAKssC,YAAYvB,IAAI59B,iBAAiBnN,KAAKuK,OAAQ8jC,EACtD,CAKMrM,SACH,OAAOhiC,KAAKssC,YAAYvB,IAAIz9B,SAAStN,KAAKuK,OAC7C,CAOMw6C,UAAUt3C,GACbzN,KAAKssC,YAAYvB,IAAIv9B,YAAYxN,KAAKuK,OAAQkD,EACjD,CAKMu3C,cACH,OAAOhlD,KAAKssC,YAAYvB,IAAI/8B,cAAchO,KAAKuK,OAClD,CAOM06C,eAAe92C,GAClBnO,KAAKssC,YAAYvB,IAAI78B,iBAAiBlO,KAAKuK,OAAQ4D,EACtD,CAKMg0B,aACH,OAAOniC,KAAKssC,YAAYvB,IAAIp9B,aAAa3N,KAAKuK,OACjD,CAOM26C,cAAcp3C,GACjB9N,KAAKssC,YAAYvB,IAAIl9B,gBAAgB7N,KAAKuK,OAAQuD,EACrD,CAaMq3C,SACHr2C,EACAC,EACAC,GAEAhP,KAAKssC,YAAYvB,IAAIl8B,WACjB7O,KAAKuK,OACLuE,EACAC,EACAC,GAMJhP,KAAKqjD,OAAS,IACjB,CAoBM+B,qBACHC,EACAv2C,EACAC,EACAM,EACAC,GAEAtP,KAAKssC,YAAYvB,IAAI77B,uBACjBlP,KAAKuK,OACL86C,EAAQ96C,OACRuE,EACAC,EACAM,EACAC,GAMJtP,KAAKqjD,OAAS,IACjB,CAkBMiC,mBACHD,EACAh2C,EACAC,GAEAtP,KAAKssC,YAAYvB,IAAIv7B,qBACjBxP,KAAKuK,OACL86C,EAAQ96C,OACR8E,EACAC,GAMJtP,KAAKqjD,OAAS,IACjB,CAMM5kC,WACH,OAAOze,KAAKssC,YAAYvB,IAAIr7B,WAAW1P,KAAKuK,OAC/C,CAMMs4B,UACH,OAAO7iC,KAAKssC,YAAYvB,IAAIn7B,UAAU5P,KAAKuK,OAC9C,CAOMg7C,qBACH,OAAOvlD,KAAKssC,YAAYvB,IAAI96B,qBAAqBjQ,KAAKuK,OACzD,CAMMi7C,mBACH,IAAIpiB,EAAQpjC,KAAKssC,YAAYvB,IAAI56B,mBAAmBnQ,KAAKuK,QACzD,OAAOsgC,GAAUwC,QAAQjK,EAC5B,CAMMvqB,SACH,OAAO7Y,KAAKojD,OACf,CAKMluC,WACH,OAAOlV,KAAKssC,YAAYvB,IAAI95B,WAAWjR,KAAKuK,OAC/C,CAKMwK,cACH,OAAO/U,KAAKssC,YAAYvB,IAAI55B,cAAcnR,KAAKuK,OAClD,CAKM0M,UACH,OAAOjX,KAAKssC,YAAYvB,IAAI15B,UAAUrR,KAAKuK,OAC9C,CAKM6M,OACH,OAAOpX,KAAKssC,YAAYvB,IAAIx5B,OAAOvR,KAAKuK,OAC3C,CAKMk7C,SACH,OAAOzlD,KAAKssC,YAAYvB,IAAIt5B,SAASzR,KAAKuK,OAC7C,CAKM8N,kBACH,OAAOrY,KAAKssC,YAAYvB,IAAIp5B,kBAAkB3R,KAAKuK,OACtD,CAKM+N,eACH,OAAOtY,KAAKssC,YAAYvB,IAAIl5B,eAAe7R,KAAKuK,OACnD,CAOMk6B,cAAc77B,GACjB,IAAIylC,EAAWxD,GAAUgD,QAAQjlC,GAC7B0lC,EAAStuC,KAAKssC,YAAYvB,IAAIx4B,gBAC9BvS,KAAKuK,OACL8jC,GAKJ,OAFAA,EAASpoC,OAEFqoC,CACV,CAYM3lC,aAAaC,EAAejC,GAC/B,IAAI0nC,EAAWxD,GAAUgD,QAAQjlC,GAC7B0lC,EAASsI,GAAgBvJ,QACzBrtC,KAAKssC,YAAYvB,IAAI92B,eAAejU,KAAKuK,OAAQ8jC,EAAU1nC,IAK/D,OAFA0nC,EAASpoC,OAEFqoC,CACV,CASM1J,cAAcsS,EAAUxwC,GAC3B,IAAI8wC,EAAU3M,GAAUgD,QAAQqJ,EAAIZ,QAChCmB,EAAS5M,GAAUgD,QAAQqJ,EAAIX,KAC/BjI,EAAStuC,KAAKssC,YAAYvB,IAAI32B,gBAC9BpU,KAAKuK,OACLitC,EACAC,EACA/wC,GAMJ,OAHA8wC,EAAQvxC,OACRwxC,EAAOxxC,OAEAqoC,CACV,CAkBMnlC,UACH+J,EACAP,EACAC,EACAC,EACAC,EACA+kC,EACAnxC,EACAoxC,GAEA,IAAI4N,EAAkB7a,GAAUgD,QAAQ36B,GACpCyyC,EAAe9a,GAAUgD,QAAQj7B,GACjCgzC,EAAeza,GAAY0C,QAAQh7B,GACnCgzC,EAAehb,GAAUgD,QAAQ/6B,GACjC6nC,EAAYhoC,EAAOk7B,UAEnBS,EAASwI,GAAazJ,QACtBrtC,KAAKssC,YACLtsC,KAAKssC,YAAYvB,IAAIt4B,YACjBzS,KAAKuK,OACLm7C,EACA/K,EACAgL,EACAC,EACAC,EACAhO,EACAnxC,EACAoxC,IAUR,OANA4N,EAAgBz/C,OAChB0/C,EAAa1/C,OACb2/C,EAAa3/C,OACb4/C,EAAa5/C,OACb00C,EAAU10C,OAEHqoC,CACV,CAgBMwX,aACH5yC,EACAuH,EACArH,EACAykC,EACAnxC,EACAoxC,GAEA,IAAI4N,EAAkB7a,GAAUgD,QAAQ36B,GACpC6yC,EAAkBlb,GAAUgD,QAAQz6B,GAEpCk7B,EAASyI,GAAqB1J,QAC9BrtC,KAAKssC,YACLtsC,KAAKssC,YAAYvB,IAAI93B,eACjBjT,KAAKuK,OACLm7C,EACAjrC,EAAUlQ,OACVw7C,EACAlO,EACAnxC,EACAoxC,IAOR,OAHA4N,EAAgBz/C,OAChB8/C,EAAgB9/C,OAETqoC,CACV,CAEMjK,gBACH1xB,EACAa,EACAC,GAEA,IAAI8mC,EAAU1P,GAAUgD,QAAQr6B,GAC5BgnC,EAAUrP,GAAY0C,QAAQp6B,GAC9BknC,EAAYhoC,EAAOk7B,UAEnBS,EAAStuC,KAAKssC,YAAYvB,IAAIx3B,kBAC9BvT,KAAKuK,OACLowC,EACAJ,EACAC,GAOJ,OAJAD,EAAQt0C,OACRu0C,EAAQv0C,OACR00C,EAAU10C,OAEHqoC,CACV,CAWD/J,aACI5xB,EACAC,EACAC,EACAe,GAEA,IAAI2mC,EAAU1P,GAAUgD,QAAQj7B,GAC5B4nC,EAAUrP,GAAY0C,QAAQh7B,GAC9B8nC,EAAYhoC,EAAOk7B,UAEnBS,EAASoL,GAAarM,QACtBrtC,KAAKssC,YAAYvB,IAAIp3B,eACjB3T,KAAKuK,OACLowC,EACAJ,EACAC,EACA5mC,IAQR,OAJA2mC,EAAQt0C,OACRu0C,EAAQv0C,OACR00C,EAAU10C,OAEHqoC,CACV,CASD0X,gBACIvrC,EACA7G,GAUA,OARa8lC,GAAarM,QACtBrtC,KAAKssC,YAAYvB,IAAIh3B,kBACjB/T,KAAKuK,OACLkQ,EAAUlQ,OACVqJ,GAKX,CAcMxN,QAAQ8wC,EAAUxwC,EAAgBC,GACrC,IAAI6wC,EAAU3M,GAAUgD,QAAQqJ,EAAIZ,QAChCmB,EAAS5M,GAAUgD,QAAQqJ,EAAIX,KAC/BjI,EAAStuC,KAAKssC,YAAYvB,IAAIz2B,UAC9BtU,KAAKuK,OACLitC,EACAC,EACA/wC,EACAC,GAMJ,OAHA6wC,EAAQvxC,OACRwxC,EAAOxxC,OAEAqoC,CACV,CAaM9mC,oBACH0vC,EACAxwC,EACAC,GAEA,IAAI6wC,EAAU3M,GAAUgD,QAAQqJ,EAAIZ,QAChCmB,EAAS5M,GAAUgD,QAAQqJ,EAAIX,KAC/BjI,EAASmI,GAAgBpJ,QACzBrtC,KAAKssC,YAAYvB,IAAIv2B,sBACjBxU,KAAKuK,OACLitC,EACAC,EACA/wC,EACAC,IAOR,OAHA6wC,EAAQvxC,OACRwxC,EAAOxxC,OAEAqoC,CACV,GAGL,SAAYnC,GACRA,EAAAA,EAAA,QAAA,GAAA,UACAA,EAAAA,EAAA,KAAA,GAAA,OACAA,EAAAA,EAAA,UAAA,GAAA,WACH,CAJD,CAAYA,KAAAA,GAIX,CAAA,UAEY8Z,GA+BT//C,YAAY+B,GACRjI,KAAKwQ,SAAU,EACfxQ,KAAKiI,MAAQA,EACbjI,KAAKiY,cAAgBk0B,GAAc+Z,QACnClmD,KAAKiX,QAAU,EACfjX,KAAKkV,SAAW,GAChBlV,KAAK+U,YAAc,EACnB/U,KAAKgY,SAAWmzB,GAAY+F,WAC5BlxC,KAAK+X,YAAc8yB,GAAUoG,QAC7BjxC,KAAKoY,UAAW,EAChBpY,KAAKqY,gBAAkB,WACvBrY,KAAKsY,aAAe,WACpBtY,KAAKkY,oBAAsBuzB,GAAuB0a,QAClDnmD,KAAKmY,uBAAyBszB,GAAuB0a,QACrDnmD,KAAKuY,qBAAuB2zB,GAAqBka,QACjDpmD,KAAKyY,aAAeqzB,GAAaua,KACjCrmD,KAAKwY,YAAcuzB,GAAYsa,KAC/BrmD,KAAKoX,KAAO,EACZpX,KAAKuX,aAAeszB,GAAUoG,QAC9BjxC,KAAK0Y,2BAA6B,EAClC1Y,KAAK2Y,YAAc,EAGnB3Y,KAAKwX,wBAA0B,EAC/BxX,KAAKy/B,kBAAmB,CAE3B,CAOM75B,YAAYo8B,GACf,MAAM/5B,EAAQ,IAAI1D,GAAKy9B,GACvB,OAAO,IAAIikB,GAAah+C,EAC3B,CAQMrC,eAAeu8B,EAAoBH,GACtC,MAAM/5B,EAAQ,IAAIxD,GAAQ09B,EAAYH,GACtC,OAAO,IAAIikB,GAAah+C,EAC3B,CAQMrC,eAAey1C,EAAWC,GAC7B,MAAMrzC,EAAQ,IAAIvD,GAAQ22C,EAAGC,GAC7B,OAAO,IAAI2K,GAAah+C,EAC3B,CASMrC,gBAAgBy1C,EAAWC,EAAWG,GACzC,MAAMxzC,EAAQ,IAAIrD,GAASy2C,EAAGC,EAAGG,GACjC,OAAO,IAAIwK,GAAah+C,EAC3B,CAWMrC,qBACHy1C,EACAC,EACAG,EACA3Z,GAEA,MAAM75B,EAAQ,IAAI/C,GAAcm2C,EAAGC,EAAGG,EAAG3Z,GACzC,OAAO,IAAImkB,GAAah+C,EAC3B,CASMrC,gBACH6Y,EACAokB,GAEA,MAAM56B,EAAQ,IAAItD,GAAS8Z,EAAUokB,GACrC,OAAO,IAAIojB,GAAah+C,EAC3B,CAcMrC,cACHm2C,EACAD,GAEA,MAAM7zC,EAAQ,IAAI5C,GAAO02C,EAAQD,GACjC,OAAO,IAAImK,GAAah+C,EAC3B,CAQMrC,eACH6Y,EACAokB,EACAI,GAEA,MAAMh7B,EAAQ,IAAIpD,GAAQ4Z,EAAUokB,EAASI,GAC7C,OAAO,IAAIgjB,GAAah+C,EAC3B,CASMrC,cAAc+7B,EAAYC,GAC7B,MAAM35B,EAAQ,IAAIzD,GAAOm9B,EAAIC,GAC7B,OAAO,IAAIqkB,GAAah+C,EAC3B,CASMrC,mBACH+7B,EACAC,EACAE,GAEA,MAAM75B,EAAQ,IAAIhD,GAAY08B,EAAIC,EAAIE,GACtC,OAAO,IAAImkB,GAAah+C,EAC3B,CAOMrC,iBAAiByV,GACpB,MAAMpT,EAAQ,IAAI7C,GAAUiW,GAC5B,OAAO,IAAI4qC,GAAah+C,EAC3B,CAQMrC,mBACHu9B,EACAC,GAEA,MAAMn7B,EAAQ,IAAIkyC,GAAYhX,EAASC,GACvC,OAAO,IAAI6iB,GAAah+C,EAC3B,CAQMrC,kBAAkB+8B,GACrB,MAAM16B,EAAQ,IAAIjD,GAAc29B,GAAQ,GACxC,OAAO,IAAIsjB,GAAah+C,EAC3B,CAQMrC,sBAAsB6Y,GACzB,MAAMxW,EAAQ,IAAIjD,GAAcyZ,GAAU,GAC1C,OAAO,IAAIwnC,GAAah+C,EAC3B,CAUMrC,uBACH+8B,EACAb,GAEA,MAAM75B,EAAQ,IAAI9C,GAAmBw9B,EAAQb,GAAc,GAC3D,OAAO,IAAImkB,GAAah+C,EAC3B,CASMrC,2BACH6Y,EACAqjB,GAEA,MAAM75B,EAAQ,IAAI9C,GAAmBsZ,EAAUqjB,GAAc,GAC7D,OAAO,IAAImkB,GAAah+C,EAC3B,CASMulC,eAAersC,EAAW+K,GAC7B,GAAgB,iBAAL/K,GAA6B,iBAAL+K,EAC/B,MAAMmlC,UAAU,+CAGpB,OADArxC,KAAK+X,YAAc,CAAC5W,EAAGA,EAAG+K,EAAGA,GACtBlM,IACV,CAUM+tC,YAAYuD,GAIf,OAFAtxC,KAAKgY,SAAWs5B,EAETtxC,IACV,CAUM0jD,UAAU4C,GAEb,OADAtmD,KAAKoY,SAAWkuC,EACTtmD,IACV,CAMMmvC,WAAW3+B,GAEd,OADAxQ,KAAKwQ,QAAUA,EACRxQ,IACV,CAaMkkD,eAAeC,GAElB,OADAnkD,KAAK2Y,YAAcwrC,EACZnkD,IACV,CAUMwkD,WAAWvtC,GAGd,OAFAjX,KAAKiY,cAAgBk0B,GAAc+Z,QACnClmD,KAAKiX,QAAUA,EACRjX,IACV,CASMykD,QAAQrtC,GAGX,OAFApX,KAAKiY,cAAgBk0B,GAAcoa,KACnCvmD,KAAKoX,KAAOA,EACLpX,IACV,CAaM0kD,kBACHttC,EACAG,EACAC,GAMA,OAJAxX,KAAKiY,cAAgBk0B,GAAcqa,UACnCxmD,KAAKoX,KAAOA,EACZyzB,GAAU0G,KAAKvxC,KAAKuX,aAAcA,GAClCvX,KAAKwX,wBAA0BA,EACxBxX,IACV,CAYM4jD,eAAe7uC,GAElB,OADA/U,KAAK+U,YAAcA,EACZ/U,IACV,CASM6jD,YAAY3uC,GAEf,OADAlV,KAAKkV,SAAWA,EACTlV,IACV,CAQM8jD,uBAAuBvuC,GAE1B,OADAvV,KAAKkY,oBAAsB3C,EACpBvV,IACV,CAQM+jD,0BACHxuC,GAGA,OADAvV,KAAKmY,uBAAyB5C,EACvBvV,IACV,CAUMgkD,mBAAmBluC,GAEtB,OADA9V,KAAKqY,gBAAkBvC,EAChB9V,IACV,CAWMikD,gBAAgBnuC,GAEnB,OADA9V,KAAKsY,aAAexC,EACb9V,IACV,CASMokD,eAAe5rC,GAElB,OADAxY,KAAKwY,YAAcA,EACZxY,IACV,CASMqkD,gBAAgB5rC,GAEnB,OADAzY,KAAKyY,aAAeA,EACbzY,IACV,CAOMukD,wBACHhsC,GAGA,OADAvY,KAAKuY,qBAAuBA,EACrBvY,IACV,CAOMskD,8BAA8BxtC,GAEjC,OADA9W,KAAK0Y,2BAA6B5B,EAC3B9W,IACV,QoB1kDQ2/C,GAmBTz5C,YAAY6kC,GACR/qC,KAAK+qC,IAAMA,GAAO,IAAI5jC,EACtBnH,KAAK2yC,IAAM,IAAIZ,GAEXhH,GACAA,EAAI1xB,uBAAuB9O,IACvBvK,KAAK2yC,IAAI5vC,IAAIwH,EAAQ,IAAI44C,GAASnjD,KAAMuK,EAAQ,MAAM,GAGjE,CArBMtE,OACGjG,KAAK+qC,KACP/qC,KAAK+qC,IAAI9kC,OAEbjG,KAAK+qC,SAAM3rC,EAELY,KAAK2yC,KACP3yC,KAAK2yC,IAAIzxB,QAEblhB,KAAK2yC,SAAMvzC,CACd,CAcM+9C,YACHt9C,GAEA,OAAQ0K,GACE1K,EACKA,EAAEG,KAAKmqC,IAAI5/B,SAElB,CAGX,CAGMgiC,wBAAwBjmC,GAC3BtG,KAAK2yC,IAAIL,SAASpD,GACdA,EAAS3C,wBAAwBjmC,IAExC,CASMwR,eACHxR,EACAusC,EACAiO,GAEA,IAAIloC,EAA4BxZ,MAAhB0hD,GAA6C,MAAhBA,EAE7C,GAAIloC,GAAa6tC,MAAM3F,GACnB,MAAMtgD,MACF,kFAGR,IAAIo3C,EAAW/E,EAAK5qC,MAAM4lC,UACtBiF,EAASjI,GAAUgD,QAAQgF,EAAK96B,aAChCg7B,EAAS5H,GAAY0C,QAAQgF,EAAK76B,UAClCi4B,EAASpF,GAAUgD,QAAQgF,EAAKt7B,cAGhChN,EAASvK,KAAK+qC,IAAIjzB,eAClB+6B,EAAKriC,QACLonC,EACA9E,EACAC,EACAF,EAAK56B,cACL46B,EAAKz7B,KACL64B,EAEA4C,EAAKr7B,wBAELq7B,EAAK57B,QACL47B,EAAK39B,SACL29B,EAAK99B,YACL89B,EAAK36B,oBACL26B,EAAK16B,uBACL06B,EAAKz6B,SACLy6B,EAAKx6B,gBACLw6B,EAAKv6B,aACLu6B,EAAKt6B,qBACLs6B,EAAKr6B,YACLq6B,EAAKp6B,aACLo6B,EAAKn6B,2BACLm6B,EAAKl6B,YACLC,EACAA,EAAYkoC,EAAe,EAC3Bx6C,EAAOykC,KAGX6M,EAAS3xC,OACT6sC,EAAO7sC,OACP8sC,EAAO9sC,OACPgqC,EAAOhqC,OAGP,IAAI4S,EAASD,EAAYtS,EAAO6jC,IAAI2W,GAAgB,KAChD5R,EAAW,IAAIiU,GAASnjD,KAAMuK,EAAQsO,EAAQg6B,EAAK5qC,OAEvD,OADAjI,KAAK2yC,IAAI5vC,IAAIwH,EAAQ2kC,GACdA,CACV,CASMn2B,OACHxO,EACAyO,EACA1S,EACA2S,GAEAjZ,KAAK+qC,IAAIhyB,OAAOxO,EAAQyO,EAAQ+xB,IAAKzkC,EAAOykC,IAAK9xB,GACjDjZ,KAAKmzC,MAAM5oC,EACd,CAMM4oC,MAAM5oC,GACTvK,KAAK2yC,IAAIN,OAAO9nC,EACnB,CAOM4/B,IAAI5/B,GACP,OAAOvK,KAAK2yC,IAAIxI,IAAI5/B,EACvB,CAKM3J,MACH,OAAOZ,KAAK2yC,IAAI/xC,KACnB,CAOMgX,SAASrN,GACZ,OAA2B,MAApBvK,KAAKmqC,IAAI5/B,EACnB,CAOM+nC,QAAQzyC,GACXG,KAAK2yC,IAAIL,QAAQzyC,EACpB,CAOM2yC,SACH,OAAOxyC,KAAK2yC,IAAIH,QACnB,EC9HE,SAASkU,GAAUC,EAASC,EAAYC,EAAGC,GAE9C,OAAO,IAAKD,IAAMA,EAAIE,WAAU,SAAUC,EAASC,GAC/C,SAASC,EAAUx/B,GAAS,IAAM+J,EAAKq1B,EAAUK,KAAKz/B,IAAW,MAAOznB,GAAKgnD,EAAOhnD,GAAO,CAC3F,SAASmnD,EAAS1/B,GAAS,IAAM+J,EAAKq1B,EAAiB,MAAEp/B,IAAW,MAAOznB,GAAKgnD,EAAOhnD,GAAO,CAC9F,SAASwxB,EAAK6c,GAJlB,IAAe5mB,EAIa4mB,EAAO+Y,KAAOL,EAAQ1Y,EAAO5mB,QAJ1CA,EAIyD4mB,EAAO5mB,MAJhDA,aAAiBm/B,EAAIn/B,EAAQ,IAAIm/B,GAAE,SAAUG,GAAWA,EAAQt/B,EAAO,KAIhB4/B,KAAKJ,EAAWE,EAAY,CAC9G31B,GAAMq1B,EAAYA,EAAU/mD,MAAM4mD,EAASC,GAAc,KAAKO,OACtE,GACA,CClEA,YATAI,WAuCA,SAAqBC,GACnB,IAAIC,EAAOC,GAAQF,GACfG,EAAWF,EAAK,GAChBG,EAAkBH,EAAK,GAC3B,OAAuC,GAA9BE,EAAWC,GAAuB,EAAKA,CAClD,EA3CAL,YAiDA,SAAsBC,GACpB,IAAIK,EAcA3rC,EAbAurC,EAAOC,GAAQF,GACfG,EAAWF,EAAK,GAChBG,EAAkBH,EAAK,GAEvBK,EAAM,IAAIC,GAVhB,SAAsBP,EAAKG,EAAUC,GACnC,OAAuC,GAA9BD,EAAWC,GAAuB,EAAKA,CAClD,CAQoBI,CAAYR,EAAKG,EAAUC,IAEzCK,EAAU,EAGVrnD,EAAMgnD,EAAkB,EACxBD,EAAW,EACXA,EAGJ,IAAKzrC,EAAI,EAAGA,EAAItb,EAAKsb,GAAK,EACxB2rC,EACGK,GAAUV,EAAIW,WAAWjsC,KAAO,GAChCgsC,GAAUV,EAAIW,WAAWjsC,EAAI,KAAO,GACpCgsC,GAAUV,EAAIW,WAAWjsC,EAAI,KAAO,EACrCgsC,GAAUV,EAAIW,WAAWjsC,EAAI,IAC/B4rC,EAAIG,KAAcJ,GAAO,GAAM,IAC/BC,EAAIG,KAAcJ,GAAO,EAAK,IAC9BC,EAAIG,KAAmB,IAANJ,EAGK,IAApBD,IACFC,EACGK,GAAUV,EAAIW,WAAWjsC,KAAO,EAChCgsC,GAAUV,EAAIW,WAAWjsC,EAAI,KAAO,EACvC4rC,EAAIG,KAAmB,IAANJ,GAGK,IAApBD,IACFC,EACGK,GAAUV,EAAIW,WAAWjsC,KAAO,GAChCgsC,GAAUV,EAAIW,WAAWjsC,EAAI,KAAO,EACpCgsC,GAAUV,EAAIW,WAAWjsC,EAAI,KAAO,EACvC4rC,EAAIG,KAAcJ,GAAO,EAAK,IAC9BC,EAAIG,KAAmB,IAANJ,GAGnB,OAAOC,CACT,EA5FAP,cAkHA,SAAwBa,GAQtB,IAPA,IAAIP,EACAjnD,EAAMwnD,EAAM3oD,OACZ4oD,EAAaznD,EAAM,EACnB0nD,EAAQ,GACRC,EAAiB,MAGZrsC,EAAI,EAAGssC,EAAO5nD,EAAMynD,EAAYnsC,EAAIssC,EAAMtsC,GAAKqsC,EACtDD,EAAM/oD,KAAKkpD,GAAYL,EAAOlsC,EAAIA,EAAIqsC,EAAkBC,EAAOA,EAAQtsC,EAAIqsC,IAI1D,IAAfF,GACFR,EAAMO,EAAMxnD,EAAM,GAClB0nD,EAAM/oD,KACJmpD,GAAOb,GAAO,GACda,GAAQb,GAAO,EAAK,IACpB,OAEsB,IAAfQ,IACTR,GAAOO,EAAMxnD,EAAM,IAAM,GAAKwnD,EAAMxnD,EAAM,GAC1C0nD,EAAM/oD,KACJmpD,GAAOb,GAAO,IACda,GAAQb,GAAO,EAAK,IACpBa,GAAQb,GAAO,EAAK,IACpB,MAIJ,OAAOS,EAAMK,KAAK,GACpB,GA/IID,GAAS,GACTR,GAAY,GACZH,GAA4B,oBAAfjnD,WAA6BA,WAAa5B,MAEvD0pD,GAAO,mEACF1sC,GAAI,EAAGtb,GAAMgoD,GAAKnpD,OAAQyc,GAAItb,KAAOsb,GAC5CwsC,GAAOxsC,IAAK0sC,GAAK1sC,IACjBgsC,GAAUU,GAAKT,WAAWjsC,KAAMA,GAQlC,SAASwrC,GAASF,GAChB,IAAI5mD,EAAM4mD,EAAI/nD,OAEd,GAAImB,EAAM,EAAI,EACZ,MAAM,IAAIJ,MAAM,kDAKlB,IAAImnD,EAAWH,EAAIqB,QAAQ,KAO3B,OANkB,IAAdlB,IAAiBA,EAAW/mD,GAMzB,CAAC+mD,EAJcA,IAAa/mD,EAC/B,EACA,EAAK+mD,EAAW,EAGtB,CAmEA,SAASc,GAAaL,EAAOU,EAAOC,GAGlC,IAFA,IAAIlB,EARoBmB,EASpBC,EAAS,GACJ/sC,EAAI4sC,EAAO5sC,EAAI6sC,EAAK7sC,GAAK,EAChC2rC,GACIO,EAAMlsC,IAAM,GAAM,WAClBksC,EAAMlsC,EAAI,IAAM,EAAK,QACP,IAAfksC,EAAMlsC,EAAI,IACb+sC,EAAO1pD,KAdFmpD,IADiBM,EAeMnB,IAdT,GAAK,IACxBa,GAAOM,GAAO,GAAK,IACnBN,GAAOM,GAAO,EAAI,IAClBN,GAAa,GAANM,IAaT,OAAOC,EAAON,KAAK,GACrB,UC3GsBO,qDACZC,GAASC,GAAOC,gqomDAA6CroD,UACtE,UCTesoD,KACZ,OnCqEG,WACH,IAAIC,EACAC,EACJ,IACI,MAAMthD,EAASlJ,EAAKmJ,iCAAiC,IACrDnJ,EAAKsqD,QAAQphD,GACb,IAAIK,EAAKlH,IAAqBmH,SAASN,EAAS,GAAO,GACnDqG,EAAKlN,IAAqBmH,SAASN,EAAS,GAAO,GAGvD,OAFAqhD,EAAchhD,EACdihD,EAAcj7C,EACP7N,EAAmB6H,EAAIgG,EAIjC,CAHS,QACNvP,EAAKmJ,gCAAgC,IACrCnJ,EAAK0P,oBAAoB66C,EAAaC,EAAa,EACtD,CACL,CmCpFWC,EACX,CAaM,SAAUC,GAAcC,GnC2EvB,IAAwBC,ImC1EnBD,EnC2ER3qD,EAAK6qD,eAAeD,EmC1ExB,CFDA1B,GAAU,IAAIC,WAAW,IAAM,GAC/BD,GAAU,IAAIC,WAAW,IAAM"}